\documentclass{lmcs}
%\usepackage{etex}
\usepackage[utf8]{inputenc}

\usepackage{color}
\usepackage{hyperref}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{proof}
\usepackage{mathpartir}
\usepackage{mathrsfs}
\usepackage{stmaryrd}
\usepackage{cmll}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage[all]{xy}
\usepackage{listings}
\usepackage{todonotes}
\usepackage{Guyboxes}
\input{macros}
%\input{newmacros}
\newtheorem{theorem}{Theorem}
\newcommand{\s}{\mathrm{s}}
\newcommand{\Rec}{\mathrm{R}}
\newcommand{\Ta}{\mathrm{T}}
\newcommand{\ta}{\mathrm{t}}
\newcommand{\Ru}{\mathcal{R}}
\newcommand{\Nhat}{\hat{\N}}
\newcommand{\Pihat}{\hat{\Pi}}
\newcommand{\Tan}{\Ta_n}
\newcommand{\Un}{\U_n}
\newcommand{\Nhatn}{\N^n}
\newcommand{\Pihatn}{\Pi^n}
\newcommand{\Nn}{\Nhatn}
\newcommand{\Pin}{\Pihatn}
\newcommand{\TRu}{\Ta_\Ru}
\newcommand{\URu}{\U_\Ru}
\newcommand{\NRu}{\N_\Ru}
\newcommand{\PiRu}{\Pi_\Ru}
\newcommand{\TRun}{{(\Ta_\Ru)}_n}
\newcommand{\URun}{{(\U_\Ru)}_n}
\newcommand{\NRun}{{(\N_\Ru)}^n}
\newcommand{\PiRun}{{(\Pi_\Ru)}^n}
\newcommand{\TRum}{{(\Ta_\Ru)}_m}
\newcommand{\URum}{{(\\U_\Ru)}_m}
\newcommand{\TC}{\Ta_\C}
\newcommand{\UC}{\U_\C}
\newcommand{\NC}{\N_\C}
\newcommand{\PiC}{\Pi_\C}
\newcommand{\Level}{\mathrm{Level}}
\def\Sort{\mathcal{S}}
\def\Op{\mathcal{O}}
\def\Eq{\mathcal{E}}
\def\D{\mathcal{D}}
\def\V{\mathrm{V}}
\def\Cwf{\mathbf{CwF}}
\def\Obj{\mathrm{Obj}}
\def\Ctx{\mathrm{Ctx}}
\def\Hom{\mathrm{Hom}}
\def\id{\mathrm{id}}
\def\Mon{\mathrm{M}}
\def\idmon{\mathrm{e}}
\def\comp{\mathrm{*}}
\newcommand{\ctx}{\mathrm{ctx}}
\newcommand{\sub}{\mathrm{sub}}
\newcommand{\ty}{\mathrm{ty}}
\newcommand{\tm}{\mathrm{tm}}
%\newcommand{\hom}{\mathrm{hom}}


\title[Generalized Algebraic Theories and Categories with Families]{A Note\\ on Finitely Presented Generalized Algebraic Theories\\and Categories with Families}\author{Marc Bezem, Thierry Coquand, Peter Dybjer, Mart\'in Escard\'o}

\begin{document}

\maketitle

\begin{abstract}
We define a new version of generalized algebraic theories. It differs from Cartmell's original syntactic definition in two respects. Whereas Cartmell allows possibly infinite sets of sort and operator symbols and equations, we only allow a finite number. Moreover, our definition is syntax independent in the sense that it is expressed in terms of uniform families in categories of models of generalized algebraic theories. 
These categories of models are categories of categories with families with extra structure. Our main result is that they all have initial objects defined in terms of syntax and inference rules. This result is obtained by extending Castellan, Clairambault, and Dybjer's construction of an initial cwf. We provide examples of gats for monoids, categories, cwfs, and cwfs with extra structure for a first universe. We also point out that cwfs with extra structure for  gats of monoids, categories, cwfs are cwfs with an internal monoid, category, and cwf, respectively.
\end{abstract}

\section{Introduction}

Generalized algebraic theories (gats) were introduced by Cartmell in his PhD thesis \cite{cartmell:phd} as a dependently typed generalization of many sorted algebraic theories. Each gat is specified by a signature with (possibly infinite) sets of sort symbols, operator symbols, and equations. Cartmell's definition of gats \cite{cartmell:phd,cartmell:apal} is based on a notion of {\em derived rule} expressed in terms of a traditional syntactic system for dependent type theory. He also defines a notion of model whereby sort symbols are interpreted as families of sets.

Categories with families (cwfs) \cite{dybjer:torino} were introduced as a new notion of model of dependent type theory. Cwfs arise by reformulating the notion of category with attributes (cwa) in Martin Hofmann's sense \cite{hofmann:csl}. The key point is to make it clear that cwfs arise as models of a certain generalized algebraic theory closely related to Martin-Löf's substitution calculus \cite{martinlof:gbg92}. As such it becomes a useful intermediary between traditional syntactic systems for dependent type theory and a variety of categorical notions of model.

The gat of cwfs is a kind of idealized formal system of dependent type theory. In contrast to Martin-Löf's substitution calculus, and other syntactic systems for dependent type thoery, it is {\em not} formulated in terms of grammars and inference rules for the forms of judgment of type theory. Instead it is formulated in terms of sort symbols (corresponding to the judgment forms), operator symbols (corresponding to the formation, introduction, and elimination rules), and equations (corresponding to the equality rules for the type formers). Some of the general reasoning (about equality, substitution, and assumptions) are taken care of by the underlying machinery of dependent type theory. This makes it possible to abstract away from various details in the formulation of grammars and inference rules. In contrast to the various syntactic systems, we would like to argue that the gat of cwfs appears to be "canonical". We may define dependent type theory in a syntax independent way as the initial object in a category of cwfs with extra structure for interpreting the type formers. 

However, the reader may now object that we have a circular definition. We learn what dependent type theory is provided we already know what dependent type theory is!

In this paper we explore and resolve this circularity. The main novelty is to get a syntax independent definition of gats in terms of cwfs with extra structure. We define a new finitely presented notion of generalized algebraic theory and simultaneosly a general categorical notion of model. We simultaneously define what it means to be a valid signature $\Sigma$ for a gat and the category $\Cwf_\Sigma$ with extra structure for $\Sigma$. This definition refers to uniform families of contexts, types, and terms in $\Cwf_\Sigma$, a purely semantic notion. Afterwards, we construct initial objects $\T_\Sigma \in \Cwf_\Sigma$ by extending Castellan, Clairambault, and Dybjer's  construction of the initial object in the category $\Cwf$ of cwfs \cite{castellan:tlca2015,castellan:lmcs}.

Once one has the appropriate definition of gats in terms of cwfs, the details become natural and there are no surprises. The definition becomes canonical once we accept the abstract definition of dependent type theories as initial cwfs with extra structure.

\subsection*{Plan of the paper}

In Section 2 we define the category $\Cwf$ of categories with families and morphisms preserving cwf-structure on the nose. Section 3 contains our main definition of a syntax independent notion of valid signature $\Sigma$ for a gat and its associated category $\Cwf_\Sigma$ of cwfs with a $\Sigma$-structure. In Section 4 we construct an initial object $\T_\Sigma$ in $\Cwf_\Sigma$. In Section 5 we show several examples of gats: for monoids, categories, cwfs, and cwfs with extra structure for a first universe. We also point out that cwfs with extra structure for  gats of monoids, categories, cwfs are cwfs with an internal monoid, category, and cwf, respectively. Finally, in Section 6 we discuss related work, for example relating to Voevodsky's initiality conjecture \cite{voevodsky:initiality} and Altenkirch and Kaprosi's quotient inductive-inductive types \cite{altenkirch:qiits}.

We remark that we work in set-theoretic metalanguage throughout the paper. Everything we do is constructive and should be possible to formalize in Aczel's CZF \cite{AczelP:typtic}. We also remark that it would be interesting to work in type-theoretic metalanguage, for example, in homotopy type theory and Voevodsky's univalent foundations. As such it could contribute to the recent work by several researchers inspired by Voevodsky's initiality conjecture.

\subsection*{Martin Hofmann's work on the categorical semantics of dependent type theory}

We are writing this note in honour of Martin Hofmann. The introduction of categories with families was strongly influenced by his work on categories with attributes, which for example play the role of "syntax" in his paper on the interpretation of Martin-Löf type theory in locally cartesian closed categories \cite{hofmann:csl}. Moreover, his lecture notes on "Syntax and Semantics of Dependent Types" \cite{hofmann:cambridge} are based on cwfs and developed many useful basic results about them, including a conservativity theorem for logical framework encodings using the cwf of presheaves.

Martin's perhaps most well-known contribution is probably his work with Thomas Streicher on the groupoid model of dependent type theory. This seminal work can be seen as a forerunner to Voevodsky's univalent foundations. Their axiom of universe extensionality is a special case of the univalence axiom. 

The groupoid model advanced our understanding of the relationship between intensional and extensional type theory in an important way. This question was also the motivation for Martin's PhD thesis "Extensional Concepts in Intensional Type Theory" \cite{hofmann:phd} on the setoid model of type theory. Yet another contribution to this question was his conservativity theorem for extensional type theory over intensional type theory \cite{hofmann:conservativity}.

Martin was also influential in many other topic. Some of us had the honour of collaborating with him.

More to write about? Semantical analysis of higher-order abstract syntax. Normalization by evaluation.

\section{Categories with families}\label{sec:def_cwf}

\subsection{The category of cwfs and strict cwf-morphisms}

In this section (whole paper?), the meta-language is set-theoretic.
Much of the vocabulary is category-theoretic, but we freely use
equality of objects in a categorical context.
We first define the category $\Fam$, and then the category $\Cwf$.

\begin{definition}\label{def:catFam}
$\Fam$ is a category whose objects are
set-indexed families of sets, denoted as $(U_x)_{x\in X}$.
A morphism of $\Fam$ with source $(U_x)_{x\in X}$ and target $(V_y)_{y\in Y}$
consists of a re-indexing function $f: X\to Y$ together with a family
$(g_x)_{x\in X}$ of functions $g_x : U_x \to V_{f(x)}$. %, for all $x\in X$.
\end{definition}

The next step is to define the category $\Cwf$. 
We split this definition in two: first the objects, 
which are called \emph{categories with families}, in Definition~\ref{def:Cwfobj},
and then the morphisms in Definition~\ref{def:Cwfmor}. 
Since $\Cwf$ has been developed as a categorical framework for the semantics of
type theory, much of the terminology (contexts, substitutions,
types, terms) refers to the syntax of type theory, 
suggesting the intended interpretation of this syntax in the 
so-called $\Cwf$-semantics.

The main novelty of this note is to use $\Cwf$ as a framework
to define a new notion of a generalised algebraic theory. 
Contexts, substitutions and terms also make
sense in relation to gat's. Perhaps it would have been natural
to replace the phrase `type' by `sort' (ref to Makkai, FOLDS?),
but we have chosen to stick to existing terminology.
It is important to stress, however, that the definition
of the notion of a generalised algebraic theory in this note
is not a syntactical one. 

\begin{definition}\label{def:Cwfobj} 
A category with families (cwf) consists of the following data:

\begin{enumerate} 

\item A category $\C$; 

\item A $\Fam$-valued presheaf on $\C$, that is, a functor
$T : \Cop \to \Fam$;

\item A terminal object $1\in \C$, and unique maps
$\tuple{}_\Gamma \in \C(\Gamma, 1)$ for all objects $\Gamma$ of $\C$;

\item Operations ${\cext\,},~\tuple{\_,\_},~\p$ and $\q$ 
explained in the following paragraphs.
These four operations and their associated equations
are referred to as \emph{context comprehension}.
\end{enumerate}

We let $\Gamma, \Delta,\ldots$ range over objects of $\C$, 
and refer to them as \emph{contexts}. 
We let $\delta, \gamma,\ldots$ range over morphisms, 
and refer to them as \emph{substitutions}. 
We refer to $1$ as the \emph{empty} context; the terminal maps
$\tuple{}_\Gamma$ represent the \emph{empty} substitutions.

If $T(\Gamma) = (U_x)_{x\in X}$, we write $\Ty(\Gamma)$ for the set $X$.
We call the elements of $\Ty(\Gamma)$ \emph{types in context $\Gamma$}, 
and let $A, B, C$ range over such types. 
Furthermore, for $A \in \Ty(\Gamma)$, we write $\Tm(\Gamma, A)$ for the set $U_A$
and call the elements of $\Tm(\Gamma, A)$ 
\emph{terms of type $A$ in context $\Gamma$}. 

For $\gamma : \Delta \to \Gamma$,
the functorial action of $T$ yields a morphism
\[
T(\gamma) \in  \Fam\left((\Tm(\Gamma, A))_{A\in \Ty(\Gamma)}, % \to 
                (\Tm(\Delta, B))_{B\in \Ty(\Delta)}\right)
\]
consisting of a reindexing function $\_\,[\gamma] : \Ty(\Gamma) \to
\Ty(\Delta)$ referred to as \emph{substitution in types}, and for each $A\in
\Ty(\Gamma)$ a function $\_\,[\gamma] : \Tm(\Gamma, A) \to \Tm(\Delta,
A[\gamma])$, referred to as \emph{substitution in terms}.

Now we turn to the explanation of the operations 
${\cext\,},~\tuple{\_,\_},~\p,~\q$.
Given $\Gamma \in \C$, $A \in \Ty(\Gamma)$, $\gamma : \Delta \to \Gamma$,
and $a\in \Tm(\Delta, A[\gamma])$, we have
\[
\Gamma \cext A \in \C
\quad\qquad
\p_{\Gamma, A} : \Gamma \cext A \to \Gamma
\quad\qquad
\q_{\Gamma, A} \in \Tm(\Gamma\cext A, A[\p_{\Gamma,A}])
\quad\qquad
\tuple{\gamma, a} : \Delta \to \Gamma \cext A.
\] 
We call $\Gamma \cext A$ the \emph{extended} context 
and $\tuple{\gamma, a}$ the \emph{extended} substitution.

The operations  ${\cext\,},~\tuple{\_,\_},~\p,~\q$
satisfy the following universal property:
$\tuple{\gamma, a}$ is the unique substitution satisfying
\[
\p_{\Gamma, A} \circ \tuple{\gamma, a} = \gamma
\qquad \text{and}\qquad
\q_{\Gamma, A} [\tuple{\gamma, a}] = a\,.
\]
We refer (colloquially) to $\p$ as the \emph{first projection},
and to $\q$ as the \emph{second projection}. %\footnote%
{Note that the first equation implies that
$\Tm(\Delta,A[\p_{\Gamma,A}][\tuple{\gamma, a}]) = \Tm(\Delta,A[\gamma])$
so that $\q_{\Gamma, A} [\tuple{\gamma, a}]$ and $a$ are elements of the same set.}
(End Definition~\ref{def:Cwfobj}.)
\end{definition}



A cwf is thus a structure $(\C,1,\tuple{},T,\cext\, , \tuple{\_,\_},\p, \q)$, 
subject to equations, for the category and the presheaf, and universal
properties for the terminal object and for context comprehension. 
The morphisms to be defined next preserve this structure,
even in a strict way (`on the nose').
We often shorten the notation of a cwf to $(\C,T)$, or even just $\C$, 
leaving the remaining structure implicit.

\begin{definition}\label{def:Cwfmor}  
A \emph{(strict) cwf-morphism $F$ between cwfs $(\C,T_\C)$ and $(\D,T_\D)$}
consists of

\begin{enumerate}

\item A functor $F_{cat} : \C \to \D$, preserving $1$ on the nose,
that is, $F_{cat}(1_{\C}) = 1_{\D}$;

\item A natural transformation $F_{nat} : T_\C \Rightarrow (T_\D \circ F_{cat})$,
preserving context comprehension on the nose (explained below).

\end{enumerate}
 
As $F_{nat}$ is a natural transformation between $\Fam$-valued presheaves,
$F_{nat}$ has a component for any object $\Gamma$ of $\C$, and
these components are morphisms in $\Fam(T_C(\Gamma),T_\D(F_{cat}(\Gamma)))$.
Recall that morphisms in $\Fam$ consist of a reindexing function
and a family of functions. It is convenient to denote $F_{cat}$,
all reindexing functions, as well as all members of the families of functions,
simply by $F$. Thus we have $F(A) \in \Ty_\D(F(\Gamma))$ 
and $F(a) \in \Tm_\D(F(\Gamma), F(A))$, for all $\Gamma$
and $A\in\Ty_\C(\Gamma)$ and $a\in \Tm_\C(\Gamma, A)$.

Naturality of $F_{nat}$
amounts to preservation of substitution, {i.e.}, for all 
$\gamma : \Delta \to \Gamma$ in $\C$, we have
\[
F(A[\gamma]) = F(A)[F(\gamma)] \qquad \qquad 
F(a[\gamma]) = F(a)[F\gamma]\,.
\]

Last but not least, we turn to the preservation of context comprehension
on the nose, and require
\[ 
F(\Gamma\cext A) = F(\Gamma)\cext F(A) \qquad
%F(\tuple{\gamma,a}) = \tuple{F(\gamma),F(a)} \qquad
F(\p_{\Gamma, A}) = \p_{F(\Gamma), F(A)} \qquad
F(\q_{\Gamma, A}) = \q_{F(\Gamma), F(A)}\,.
\]

Note that the universal property implies that also
$F(\tuple{\gamma,a}) = \tuple{F(\gamma),F(a)}$.
The same is true for the terminal maps:
$F(\tuple{}_\Gamma) = \tuple{}_{F(\Gamma)}$.
(End Definition~\ref{def:Cwfmor}.)
\end{definition}

Small cwfs with strict cwfs-morphisms form a category, written $\Cwf$. 

\footnote{200805: The following is removed for the time being. Some of it should probably be moved to the introduction of section 5:
"One of the main features of cwfs is that they are models of a certain generalized algebraic theory which arises naturally by unfolding the definition above. Moreover, this gat bears a close resemblance to Martin-Löf's substitution calculus. However a main difference is that Martin-Löf's calculus uses ordinary named variables whereas the gat for cwfs uses a combinator language quite similar to the ccc-combinators that arise from the definition of cartesian closed categories. Another main difference is that a gat is not a usual formal system defined in terms of a raw syntax and inference rules. Instead it is a dependently typed generalization of many sorted algebras. The formalism assumes a basic framework for dependent type theory. In this language you specify a {\em signature} consisting of a list of sort symbols and operator symbols, with dependent typings, and equations (between terms). (Cartmell \cite{cartmell:phd,cartmell:apal} also allows equations between sort terms, but most examples do not make use of such. It would be straightforward to include such equations in our account too.) 

We shall now display the sort symbols, operator symbols, and equations of the gat of cwfs. Note that the four sort symbols $\Ctx, \Hom, \Ty,$ and $\Tm$ correspond to the respective four of the judgment forms of Martin-Löf's substitution calculus:
\begin{eqnarray*}
\\&&\Gamma \vdash
\\&&\Delta \vdash \gamma : \Gamma
\\&&\Gamma \vdash A
\\&&\Gamma \vdash a : A
\end{eqnarray*}
In addition to these the substitution calculus have the following forms of equality judgments:
\begin{eqnarray*}
\\&&\Gamma = \Gamma' \vdash
\\&&\Delta \vdash \gamma = \gamma' : \Gamma
\\&&\Gamma \vdash A = A'
\\&&\Gamma \vdash a = a' : A
\end{eqnarray*}
Furthermore, the operator symbols correspond to syntactic constructions of contexts, substitutions, types, and terms, with their typing rules. Finally, the equations correspond to certain equality rules, expressed in terms of the equality judgments. 

We will now specify the sort symbols, operators symbols and equations of the gat of cwfs in traditional notation with variables. Here we assume that the reader is familiar with dependent type theory to get an informal understanding of what a gat is. Note that mutual dependence of the notions of gat and cwf. Here we define cwfs as a gat and in the next section we will define valid signatures and models of gats in terms of initial cwfs. Note also that the official metalanguage of this article is set theory, and that definition X should be understood in set-theoretic metalanguage.

We shall give the signature of the cwf of gats stepwise: first the signature for categories, then we extend it with a family-valued functor, then with a terminal object, and finally with context comprehension.
}

\section{Signatures and models of generalized algebraic theories}

We now come to the main point of this note.
We define how to build a valid gat signature $\Sigma$ and the associated
category $\Cwf_{\Sigma}$ of cwfs with a $\Sigma$-structure.
Each object of $\Cwf_{\Sigma}$ is a cwf with extra structure and
each morphism will be a cwf morphism preserving this extra structure.
For this definition, we will need the following auxiliary notions.

A {\em uniform family of contexts} is a family of context $\Gamma = (\Gamma_{\C})$ for each
$\C \in \Cwf_{\Sigma}$ such that
$f(\Gamma_\C) = \Gamma_\D$ for all morphisms $f \in \Cwf_{\Sigma}(\C,\D)$.
If $\Gamma$ is such a family, a {\em uniform family of types} over $\Gamma$ is a
family of types $A = (A_{\C})$ with $A_{\C}$ type over $\Gamma_{\C}$ and
$f(A_{\C}) = A_{\D}$ for all morphisms $f \in \Cwf_{\Sigma}(\C,\D)$.
Finally, given $\Gamma$ and $A$, a {\em uniform family of terms} is a family
of terms $a = (a_{\C})$ in $\Tm_{\C}(\Gamma_{\C},A_{\C})$ such that
$f(a_{\C}) = a_{\D}$ for all morphisms $f \in \Cwf_{\Sigma}(\C,\D)$.



\begin{definition}
We define inductively how to build a valid signature $\Sigma$ and the category $\Cwf_\Sigma$ of cwfs with support for $\Sigma$ and cwf-morphisms that preserve it. First, the base case:
\begin{description}
\item[The empty signature] The empty signature $\emptyset$ is valid and $\Cwf_\emptyset = \Cwf$. 
\end{description}
Assume now that we have defined $\Sigma$ as a valid signature and the associated
category $\Cwf_{\Sigma}$.
Then we can add a new type symbol, or a new operator symbol, or a new equation, to get a new valid signature,
as follows:
\begin{description}
\item[Adding a sort symbol] 
  Let $\Gamma = (\Gamma_\C)$ be a uniform family of contexts.
  Then we can extend $\Sigma$ with a new sort symbol to obtain an extended gat
  $\Sigma' = (\Sigma,F)$.
  The objects of $\Cwf_{\Sigma'}$ are pairs $(\C,F_{\C})$, where $\C$ is an object of $\Cwf_{\Sigma}$
  and $F_{\C}$ is a type over $\Gamma_{\C}$.
  A morphism in $\Cwf_{\Sigma'}((\C,F_{\C}), (\D,F_{\D}))$
  is a morphism $f \in \Cwf_{\Sigma}(\C,\D)$ such that $f(F_\C) = F_\D$.
\item[Adding an operator symbol] 
  If $\Gamma$ is a uniform family of contexts and $A$ a uniform family of types over $\Gamma$,
  then we can extend $\Sigma$ with a new operator symbol $t$. An object of $\Cwf_{\Sigma'}$
  is a pair $\C,t_{\C}$ where $\C$ is an object in $\Cwf_{\Sigma}$ and $t_{\C}$ is
  in $\Tm_\C(\Gamma_\C,A_\C)$.
  A morphism in $(\C,t_{\C}) \to (\D,t_{\D})$ is a morphism $f$ in $\C\to \D$ such that $f(t_{\C}) = t_{\D}$
\item[Adding an equation] 
  If $\Gamma$ is a uniform family of contexts, $A$ a uniform family of types over $\Gamma$
  and $a,a'$ uniform family of terms in $A$, then we can extend $\Sigma$ with a new equation
  $a = a'$ (with context $\Gamma$ and type $A$). In this case,
  $\Cwf_{\Sigma'}$ is a full subcategory of $\Cwf_{\Sigma}$. An object $\C$ in $\Cwf_{\Sigma'}$ is an object
  $\C$ of $\Cwf_\Sigma$ such that $a_{\C} = a'_{\C}$.
\end{description}

\end{definition}

This definition is {\em syntax independent}. It corresponds however
to a purely syntactical definition of formal systems, which describe for each signature
$\Sigma$ an {\em initial object} $\T_{\Sigma}$ in $\Cwf_{\Sigma}$. To give a uniform
  family of contexts is then equivalent to give a context in
  $\T_{\Sigma}$ and similarly for uniform family of types and terms.
To build this initial object will be the topic of the next section.

%\section{Signatures and models of generalized algebraic theories}
%
%We now come to the main point of this note. We define how to build a valid gat signature $\Sigma$ and what it means for a cwf to support it. This definition relies on the construction of initial cwfs $\T_\Sigma$ supporting $\Sigma$, but we will postpone the construction of these until the next section. In this way we separate the abstract definition from the concrete syntactic details employed for building $\T_\Sigma$. 
%\footnote{Say something about the fact that we do not assume anything about the relationship between $\T_\Sigma$ and $\T_{\Sigma'}$ because all initial objects are isomorphic, and hence we can move between them.}
%\begin{definition}
%We define inductively how to build a valid signature $\Sigma$ and the category $\Cwf_\Sigma$ of cwfs with support for $\Sigma$ and cwf-morphisms that preserve it. First, the base case:
%\begin{description}
%\item[The empty signature] The empty signature $\emptyset$ is valid and $\Cwf_\emptyset = \Cwf$. 
%\end{description}
%Assume now that $\Sigma$ is a valid signature and that the category $\Cwf_\Sigma$ has an initial object $\T_\Sigma$ with $\inte{-} : \T_\Sigma \to \C$ as the unique morphism into an object $\C$. Then we can add a new type symbol, or a new operator symbol, or a new equation, to get a new valid signature, as follows:
%\begin{description}
%\item[Adding a new sort symbol (Thierry)] 
%Let $\Gamma_\C \in \C$ for $\C \in \Cwf_{\Sigma}$ be a uniform family of contexts, that is, if $f(\Gamma_\C) = \Gamma_\D$ for all morphisms $f \in \Cwf_{\Sigma}(\C,\D)$. Then we can extend $\Sigma$ with a new sort symbol to obtain an extended gat $\Sigma' = (\Sigma,F)$, where $F_\C \in \Ty_\C(\Gamma_\C)$ is a uniform family of types, that is $f(F_\C) = F_\D$. The objects of $\Cwf_{\Sigma'}$ are pairs $(\C,F)$, where $\C$ is an object of $\Cwf_{\Sigma}$. A morphism in $\Cwf_{\Sigma'}((\C,F), (\D,G))$ is a morphism $f \in \Cwf_{\Sigma}(\C,\D)$ such that $f(F_\C) = G_\D$.
%\item[Adding a new sort symbol] 
%If $\Gamma$ is a context in $\T_\Sigma$, then we can extend $\Sigma$ with a new sort symbol $F$ (with context $\Gamma$) to obtain an extended gat $\Sigma'$. The objects of $\Cwf_{\Sigma'}$ are pairs $(\C,F_\C)$, where $\C$ is an object of $\Cwf_{\Sigma}$ and $F_\C \in \Ty_\C(\inte{\Gamma})$. A morphism in $\Cwf_{\Sigma'}((\C,F_\C), (\D,F_\D))$ is a morphism in $\Cwf_{\Sigma}(\C,\D)$ that maps $F_\C$ to $F_\D$.
%\item[Adding a new operator symbol] 
%If $\Gamma$ is a context in $\T_\Sigma$ and $A \in \Ty_{\T_\Sigma}(\Gamma)$, then we can extend $\Sigma$ with a new operator symbol $f$ (with context $\Gamma$ and type $A$). A cwf $\C$ supports $\Sigma'$ if it supports $\Sigma$ and there is $f_\C \in\Tm_\C(\inte{\Gamma},\inte{A}_{\Gamma})$.
%A cwf-morphism in $\C \to \D$ preserves $\Sigma'$ if it preserves $\Sigma$ and maps $f_\C$ to $f_\D$.
%\item[Adding a new equation] 
%If $\Gamma$ is a context in $\T_\Sigma$, $A \in \Ty_{\T_\Sigma}(\Gamma)$, and $a, a' \in \Tm_{\T_\Sigma}(\Gamma,A)$, then we can extend $\Sigma$ with a new equation $a = a'$ (with context $\Gamma$ and type $A$). A cwf $\C$ supports $\Sigma'$ if it supports $\Sigma$ and $\inte{a}_{\Gamma,A}= \inte{a'}_{\Gamma,A} \in \Tm_\C(\inte{\Gamma},\inte{A}_\Gamma)$. A cwf-morphism in $\C \to \D$, where $\C$ and $\D$ support $\Sigma'$, preserves $\Sigma'$ iff it preserves $\Sigma$.
%\end{description}
%\end{definition}
%
%Note that the empty signature $\emptyset$ is the only valid signature that can be directly constructed from the definition. In order to form other signatures we need to construct initial cwfs supporting already constructed signatures. This is the topic of the next section.

\section{The construction of an initial object in $\Cwf_\Sigma$}

We shall now show our main theorem. It can be viewed as a generalization of Birkhoff's completeness theorem for equational logic \cite{birkhoff}:
\begin{theorem}
The category $\Cwf_\Sigma$ has an initial object $\T_\Sigma$ for every valid signature $\Sigma$.
\end{theorem}

The construction of $\T_\Sigma$ will be by induction on the construction of $\Sigma$. It is based on construction of initial cwfs in \cite{castellan:tlca2015,castellan:lmcs} and we refer the reader to those papers for more details. Here we will only provide a sketch and focus on how to extend the construction to $\T_\Sigma$.

For each $\Sigma$ we will define the following.
\begin{itemize}
\item 
A grammar for raw contexts in $\RawCtx_\Sigma$, raw substitutions in $\RawSub_\Sigma$, raw types in $\RawTy_\Sigma$, and raw terms in $\RawTm_\Sigma$. 
\item
A system of inference rules that generate four families of partial equivalence relations (pers) by a mutual inductive definition:
$$
\Gamma = \Gamma' \vdash_\Sigma
\qquad
\Gamma \vdash_\Sigma A = A' 
\qquad
\Delta \vdash_\Sigma \gamma = \gamma' : \Gamma
\qquad
\Gamma \vdash_\Sigma a = a' : A
$$
where $\Gamma, \Gamma' \in \RawCtx_\Sigma, \gamma, \gamma' \in \RawSub_\Sigma, A, A' \in \RawTy_\Sigma,$ and $a,a' \in \RawTm_\Sigma$. Instances of these pers correspond to valid equality judgments of a variable free version of dependent type theory with explicit substitutions based on the cwf-combinators. The ordinary judgments will be defined as the reflexive instances of these equality judgments. For example $\Gamma \vdash_\Sigma$ (meaning ”$\Gamma$ is a valid context") is defined as the reflexive instance $\Gamma = \Gamma \vdash_\Sigma$.
\item
A cwf $\T_\Sigma$ is then constructed from the equivalence classes of derivable judgments. For example, the contexts in $\T_\Sigma$ are equivalence classes $[\Gamma]$, such that $\Gamma \vdash_\Sigma$. We will show that $\T_\Sigma$ is a cwf that supports $\Sigma$, that is, an object of $\Cwf_\Sigma$.
\item
A $\Cwf_\Sigma$-morphism $\inte{-} : \T_\Sigma \to \C$ for every $\C \in \Cwf_\Sigma$. This is the {\em interpretation morphism}. This morphism is a partial function defined by induction on the raw syntax, such that it maps raw contexts to contexts in $\C$, raw substitutions to substitutions in $\C$, raw types to types in $\C$, and raw terms to terms in $\C$. We show that these partial functions preserve the partial equivalence relations so that we can define the interpretation morphism on the equivalence classes. Finally we show that it indeed is a $\Cwf_\Sigma$-morphism and the unique such into $\C$.
\end{itemize}
 
We begin with the construction for the base case: the {\bf empty signature} $\emptyset$. 
\begin{itemize}
\item 
We start with the following grammar for raw contexts, raw substitutions, raw types, and raw terms.
\begin{eqnarray*}
\Gamma \in \RawCtx_\emptyset &::=& 1  \ |\ \Gamma\cext A\\
\gamma \in \RawSub_\emptyset  \ &::=& \gamma \circ \gamma \ |\ \id_\Gamma \ |\ \langle\rangle_\Gamma \ |\ \p_{A} \ |\ \langle \gamma, a \rangle_A\\
A \in \RawTy_\emptyset  &::=& A[\gamma]\\
a \in \RawTm_\emptyset  &::=& a[\gamma] \ |\ \qI_A
\end{eqnarray*}
These grammars generate a language of {\em cwf-combinators}.
\item
The system of inference rules is displayed in \cite{castellan:tlca2015,castellan:lmcs}. It is a system of {\em general rules}, rules for dependent type theory which come before you introduce any sort symbols and operator symbols and equations (or any rules for the type formers of intuitionistic type theory). We do not have room here to display them, but note that they can be divided into the four groups: 
\begin{itemize}
\item the per rules, amounting to symmetry and transitivity for the four forms of equality judgments;
\item preservation rules for judgments amounting to substitution of equals for equals (an example of such a rule is the {\em type equality rule});
\item congruence rules for operators expressing that the cwf-combinators preserve equality;
\item conversion rules for the cwf-combinators.
\end{itemize}
\item
Note that the initial cwf $\T_\emptyset$ is rather uninteresting: its category of contexts contains only a terminal object (the empty context), and there are no types and terms. Nevertheless, the grammar and inference rules used in its definition form a starting point. The grammar for raw types and raw terms will be extended each time we add a new sort symbol or operator symbol, respectively. For each such new symbol and each new equation we will also add a new inference rule. As a consequence we will generate non-trivial $\T_\Sigma$.
\end{itemize}

Assume now for the induction step that we have defined the grammar, the inference rules, $\T_\Sigma$ and the interpretation morphism $\inte{-} : \T_{\Sigma} \to \C$ in $\Cwf_\Sigma$.
Let $\Sigma'$ be $\Sigma$ extended by a new sort symbol, a new operator symbol, or a new equation. We shall now explain how to define $\T_{\Sigma'}$.
\begin{description}
\item[Adding a sort symbol] If $\Gamma \vdash_\Sigma$, then we can introduce a new sort symbol $F$ in the context $\Gamma$ representing the sequence of types of the arguments of $F$.
\begin{itemize}
\item
We add a new production for raw types
$$
A ::= F
$$
to the productions for $\T_\Sigma$.
\item
We add  the inference rule
\begin{mathpar}
    \inferrule
    {}
    {\Gamma \vdash_{\Sigma'} F}
  \end{mathpar}
to the inference rules for $\T_\Sigma$. 
\item
We define $F_{\T_{\Sigma'}} = [F]$, so that $ \T_{\Sigma'}$ has a $\Sigma'$-structure $(\T_\Sigma,[F])$. 
\item
We extend the definition of the interpretation morphism $\inte{-}$  to an interpretation morphism $\inte{-}' : \T_{\Sigma'} \to \C$ by 
$$
\inte{[F]}' = F_\C
$$
It follows immediately that this is a morphism in $\Cwf_{\Sigma'}$ and that it is unique.
\end{itemize}

\item[Adding an operator symbol] If $\Gamma \vdash_\Sigma A$, then we can introduce a new operator symbol $t$, where the context $\Gamma$ represents the sequence of types of the arguments and $A$ is the type of the result.
\begin{itemize}
\item
We add a new production for raw terms
$$
a ::= t
$$
to the productions for $\T_\Sigma$.
\item
We add  the inference rule
\begin{mathpar}
    \inferrule
    {}
    {\Gamma \vdash_{\Sigma'} t : A}
  \end{mathpar}
to the inference rules for $\T_\Sigma$. 
\item
We define $t_{\T_{\Sigma'}} = [t]$, so that $ \T_{\Sigma'}$ has a $\Sigma'$-structure $(\T_\Sigma,[t])$.\item
We extend the definition of the interpretation morphism $\inte{-}$  to an interpretation morphism $\inte{-}' : \T_{\Sigma'} \to \C$ by 
$$
\inte{[t]}' = t_\C
$$
It follows immediately that this is a morphism in $\Cwf_{\Sigma'}$ and that it is unique.
\end{itemize}

\item[Adding an equation] If $\Gamma \vdash_\Sigma a : A$ and $\Gamma \vdash_\Sigma a' : A$ we can introduce a new equation $a = a'$.
\begin{itemize}
\item
$\T_\Sigma'$ has the same productions as $\T_\Sigma$.
\item
We add  the inference rule
\begin{mathpar}
    \inferrule
    {}
    {\Gamma \vdash_{\Sigma'} a = a' : A}
  \end{mathpar}
to the inference rules for $\T_\Sigma$. 
\item
$\T_{\Sigma'}$ is based on the same raw syntax as $\T_\Sigma$ but the equivalence relation has changed. To show that $\T_{\Sigma'} \in \Cwf_\Sigma'$ we just need to show that $[ a ] = [ a' ]$ but this immediate from the inference rule $\Gamma \vdash_{\Sigma'} a = a' : A$.
\item
In order to define $\inte{-}'$ we first define the partial function on the raw syntax to be identical to the partial function on the raw syntax for $\inte{-}$. We then prove that this partial function preserves the extended partial equivalence relation and define $\inte{-}'$ on the new equivalence classes. It follows immediately that $\inte{-}'$ is unique.
\end{itemize}
\end{description}

\section{Examples of generalized algebraic theories}

\subsection{Monoids} The one sorted algebraic theory of monoids has two operator symbols  $\idmon$ for identity and $\comp$ for composition, and associativity and identity laws as equations. As every other algebraic theory in the ordinary sense the algebraic theory of monoids yields a generalized algebraic theory. We first introduce one constant sort symbol $M$, and then the operator symbols $\id$ for identity and $\circ$ for composition, and the associativity and identity laws as equations. 

We shall now show in how to build a valid signature for monoids following the recipe in the previous section using the cwf-combinators. (Note that we drop the indices on $\p_A, \q_A,\tuple{\gamma,a}_A$ and $\id_\Gamma$
and the index on $\vdash_\Sigma$.)
\begin{itemize}
\item 
First, we have $1 \vdash$ for the empty signature, so we can add a production for the constant sort symbol $\Mon$ and the inference rule:
\begin{eqnarray*}
1 &\vdash& \Mon
\end{eqnarray*}
\item
We then add a production for the constant operator symbol $\idmon$ and the inference rule:
\begin{eqnarray*}
1 &\vdash& \idmon : \Mon
\end{eqnarray*}
\item
We then add a production for the binary operator symbol $\comp$. Since we can derive
$1.\Mon.\Mon[\p] \vdash$ using the previous inference rules, we can add the inference rule
\begin{eqnarray*}
1.\Mon.\Mon[\p] &\vdash& \comp : \Mon[\p][\p]
\end{eqnarray*}
Note that we need to weaken $\Mon$ by substituting with $\p$.
\item
Since we can derive $1.\Mon \vdash$, $1.\Mon \vdash \comp[\tuple{\tuple{\tuple{},\idmon[\tuple{}]},\q}] : \Mon[p]$ and $1.\Mon \vdash \q : \Mon[\p]$ using the previous inference rules, we can add the inference rule for the equation ($\idmon$ is a left identity):
\begin{eqnarray*}
1.\Mon &\vdash& \comp[\tuple{\tuple{\tuple{},\idmon[\tuple{}]},\q}] = \q : \Mon[\p]
\end{eqnarray*}
\item
We omit the rendering of the right identity and associativity laws.
\end{itemize}
We also display the sort symbols, operator symbols, and equations in ordinary notation with variables for comparison:
\begin{eqnarray*}
&\vdash& \Mon\\
&\vdash& e : \Mon\\
x, y : \Mon &\vdash& \comp(x,y) : \Mon\\
y : \Mon &\vdash& \comp(\idmon,y) = y : \Mon\\
x : \Mon &\vdash& \comp(x,\idmon) = x : \Mon\\
x, y, z : \Mon &\vdash& \comp(\comp(x,y),z) = \comp(x,\comp(y,z)) : \Mon
\end{eqnarray*}

A cwf $\C$ that supports this gat has an {\em internal monoid} in $\C$. This is a cwf-version of the notion of internal monoid which can be defined in any category with finite products. Ordinary (small) monoids come out as internal monoids in $\Set$, the cwf of small sets.

\subsection{Categories} We begin with the gat of categories, one of Cartmell's motivating examples. We first show it in ordinary notation with variables.

Sort symbols:\footnote{200810: I suggest to use Thierry's naming scheme, with $\ctx, \ty, \tm$ for internal contexts, types, and terms. Maybe we can overload the operator symbols, after having made a comment?}
\begin{eqnarray*}
&\vdash& \Obj\\
\Delta, \Gamma : \Obj &\vdash& \Hom(\Delta,\Gamma)\\
\end{eqnarray*}

Operator symbols\footnote{We must distinguish between notation for identity and composition in the cwf and in the gat based on the cwf}:
\begin{eqnarray*}
\Gamma : \Obj &\vdash& \id_\Gamma : \Hom(\Gamma,\Gamma)\\
\Xi,\Delta,\Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta) &\vdash&
\gamma \circ \delta : \Hom(\Xi,\Gamma)
\end{eqnarray*}

Equations:
\begin{eqnarray*}
\Delta, \Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma) &\vdash& \id_\Gamma \circ \gamma = \gamma : \Hom(\Delta,\Gamma)\\
\Delta, \Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma) &\vdash& \gamma \circ \id_\Delta = \gamma : \Hom(\Delta,\Gamma)\\
\Theta, \Xi,\Delta,\Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta), \xi : \Hom(\Theta,\Xi) &\vdash&
(\gamma \circ \delta) \circ \xi = \gamma \circ (\delta \circ \xi): \Hom(\Theta,\Gamma)
\end{eqnarray*}
%In order to build $\Hom(\Delta,\Gamma)$ for two concrete contexts $\vdash \Delta : \Ctx$ and $\vdash \Gamma : \Ctx$ we need to apply $\Hom$ to the context morphism consisting of $\Delta$ and $\Gamma$ to yield $\Hom(\Delta,\Gamma)$. (There is more to say ...)
Note that composition is officially an operator symbols with five arguments. In the official notation we should write $\gamma \circ_{\Xi,\Delta,\Gamma} \delta$, but we suppress the context arguments $\Xi,\Delta,\Gamma$. We will do so for some other operations too.

The rendering of the gat of categories in cwf-combinator language and the proof that it indeed yields a valid signature are similar to what they were for the gat of monoids. The inference rules for the two sort symbols in cwf-combinator language are
\begin{eqnarray*}
1 &\vdash& \Obj\\
1.\Obj.\Obj[\p] &\vdash& \Hom
\end{eqnarray*}
and the operator symbols for identity
\begin{eqnarray*}
1.\Obj &\vdash& \idmon : \Hom[\tuple{\id_{1.\Obj},\q_{1,\Obj}}]
\end{eqnarray*}
We omit the verbose cwf-renderings of the inference rule for composition and the equations.

A cwf that supports the generalized algebraic theory of categories is a cwf with an {\em internal category}. This is a cwf-based analogue of the usual notion of internal category in a category with finite limits. As shown by Martin Hofmann \cite{hofmann:csl,hofmann:cambridge}, every category with finite limits yields a category with attributes, and hence a cwf. However, not every cwf has finite limits. To achieve this we need more structure. As shown by Clairambault and Dybjer \cite{ClairambaultD11,ClairambaultD14} the 2-category of categories with finite limits is biequivalent to the 2-category of democratic cwfs that support $\Sigma$-types and extensional identity types.

An internal category in the cwf $\Set$ of small sets is a small category.

%\subsubsection{How to generate the valid signature using the combinator language} 
%The signature for the generalized algebraic theory of categories has sort symbols $\Obj$ 
%and $\Hom$, operator symbols $\id$ for identity and $\circ$ for composition, and associativity and identity laws as equations. We shall here sketch how to generate the valid signature for categories with reference to definition \ref{} and using cwf-combinators.
%\begin{itemize}
%\item The initial cwf $\T_\emptyset$ (as constructed above) has only one object (context) [1], one equivalence class of morphisms $[\id_1]$ (with several representatives: $\tuple{}_1, \id_1 \circ \id_1$, etc), and no types and terms. Hence we can add a new constant sort $\Obj$ of (internal) objects with context $1$ to the signature. 
%\item $\T_{([\Obj],[],[])}$ (as constructed above) contains the context $[(1.\Obj).\Obj[\p_{1,\Obj}]]$ (corresponding to the context $x : \Obj, y : \Obj$ in usual notation). Hence we can introduce a new sort $\Hom$ with this context. This sort represents the family $\Hom(x,y)$ of (internal) morphisms.
%\item $\T_{([\Obj, \Hom],[],[])}$ contains the context $[1.\Obj]$ (corresponding to the context $x : \Obj$) and the type $[\Hom[\tuple{\id_{1.\Obj},\q_{1,\Obj}}]]$ (corresponding to the type $\Hom(x,x)$). Hence we can introduce an operator symbol $\id$ with this context and type.
%\item In a similar way we can add the operator symbol for composition and the equations, but we omit the details.
%\end{itemize}

\subsection{Cwfs}

The gat of cwfs is obtained by extending the gat of categories with new sort symbols, operator symbols, and equations for a family valued functor, and then new operator symbols and equations for a terminal object, and context comprehension. We here rename the sort $\Obj$ of objects of the category of context to $\Ctx$.

\subsubsection{The extension with a family valued functor}
\mbox{ }

Sort symbols:
\begin{eqnarray*}
\Gamma : \Ctx &\vdash& \Ty(\Gamma)\\
\Gamma : \Ctx, A:\Ty(\Gamma) &\vdash& \Tm(\Gamma,A)
\end{eqnarray*}

Operator symbols:
\begin{eqnarray*}
\Gamma,\Delta : \Ctx, A:\Ty(\Gamma), \gamma : \Hom(\Delta,\Gamma) &\vdash& 
A[\gamma] : \Ty(\Delta)\\
\Gamma,\Delta : \Ctx, A:\Ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\Tm(\Gamma,A) &\vdash&  a[\gamma] : \Tm(\Delta,A[\gamma])
\end{eqnarray*}

Equations:
\begin{eqnarray*}
\Gamma : \Ctx, A:\Ty(\Gamma) &\vdash& A[\id_\Gamma] = A : \Ty(\Gamma)\\
\Gamma : \Ctx, A:\Ty(\Gamma), a:\Tm(\Gamma,A) &\vdash& a[\id_\Gamma] = a : \Tm(\Gamma,A)\\
\Xi,\Delta,\Gamma : \Ctx, \delta : \Hom(\Xi,\Delta), \gamma : \Hom(\Delta,\Gamma),
A:\Ty(\Gamma) &\vdash& A[\gamma\circ\delta] = A[\gamma][\delta]: \Ty(\Xi)\\
\Xi,\Delta,\Gamma : \Ctx, \delta : \Hom(\Xi,\Delta), \gamma : \Hom(\Delta,\Gamma),
A:\Ty(\Gamma), a:\Tm(\Gamma,A) &\vdash& 
a[\gamma\circ\delta] = a[\gamma][\delta]: \Tm(\Xi,A[\gamma\circ\delta])
\end{eqnarray*}

\subsubsection{The extension with a terminal object}
No new sorts are required.
  
Operator symbols:
\begin{eqnarray*}
&\vdash& 1 : \Ctx\\
\Gamma : \Ctx &\vdash& \tuple{}_\Gamma : \Hom(\Gamma,1)
\end{eqnarray*}

Equations:
\begin{eqnarray*}
 &\vdash& \id_1 = \tuple{}_1 : \Hom(1,1)\\
\Gamma,\Delta : \Ctx, \gamma : \Hom(\Delta,\Gamma) &\vdash& 
\tuple{}_\Gamma\circ\gamma = \tuple{}_\Delta : \Hom(\Delta,1)
\end{eqnarray*}
(The latter two equations are better for term rewriting then the
obvious single one expressing the uniqueness of $\tuple{}_\Gamma$.)

\subsubsection{The extension with context comprehension}

No new sorts are required.
  
Operator symbols:
\begin{eqnarray*}
\Gamma : \Ctx, A:\Ty(\Gamma) &\vdash& \Gamma\cext A : \Ctx\\
\Gamma,\Delta : \Ctx, A:\Ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\Tm(\Delta,A[\gamma]) &\vdash& \tuple{\gamma,a} : \Hom(\Delta,\Gamma\cext A)\\
\Gamma : \Ctx, A:\Ty(\Gamma) &\vdash& \p: \Hom(\Gamma\cext A,\Gamma)\\
\Gamma : \Ctx, A:\Ty(\Gamma) &\vdash& \q: \Tm(\Gamma\cext A,A[\p])
\end{eqnarray*}

Equations:
\begin{eqnarray*}
\Gamma,\Delta : \Ctx, A:\Ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\Tm(\Delta,A[\gamma]) &\vdash& \p\circ\tuple{\gamma,a} = \gamma : \Hom(\Delta,\Gamma)\\
\Gamma,\Delta : \Ctx, A:\Ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\Tm(\Delta,A[\gamma]) &\vdash& \q[\tuple{\gamma,a}] = a : \Tm(\Delta,A[\gamma]) \\
\Gamma,\Delta,\Xi : \Ctx, A:\Ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\Tm(\Delta,A[\gamma]), \delta : \Hom(\Xi,\Delta) &\vdash& 
\tuple{\gamma,a} \circ \delta = \tuple{\gamma\circ\delta,a[\delta]} : 
\Hom(\Xi,\Gamma\cext A) \\
\Gamma : \Ctx, A:\Ty(\Gamma) &\vdash& 
\id_{\Gamma\cext A} = \tuple{\p,\q} : \Hom(\Gamma\cext A,\Gamma\cext A)
\end{eqnarray*}
(If $\p\circ\delta = \gamma$ and $\q[\delta]=a$, we get
$\tuple{\gamma,a}=\tuple{\p\circ\delta, \q[\delta]} = \tuple{\p,\q}\circ\delta =
\delta$, the uniqueness requirement of the universal property.
However, the equation for surjective pairing is not left-linear and with
a variable on one side --- not good for rewriting.)

A cwf that supports the generalized algebraic theory of cwfs is a cwf with an {\em internal cwf}. An internal cwf in the cwf $\Set$ of small sets is a {\em small cwf}, that is, it is a cwf in the ordinary sense (see definition \ref{}) except that it has small sets of objects, morphisms, types, and terms.

An example of a cwf with an internal cwf is provided by the cwf $\Set$ of small sets with an internal category of very small sets. We can make this precise if we work in set theory with two Grothendieck universes $\V_0 \in \V_1$. We call the members of $\V_1$ "small sets" and the members of $\V_0$ "very small sets". The category of contexts of the cwf $\Set$ is the usual category of small sets, by which we here mean that the set of objects $\Ctx = \V_1$. Moreover, the types are also the small sets, that is, $\Ty(\Gamma) = \V_1$. To get an internal cwf, we interpret its sort of objects $\ctx$ as the small set $\V_0$ of very small sets, and the sorts of types $\ty(\Gamma)$ also as $\V_0$.

Further examples of internal cwfs inside $\Set$ are provided by cwfs supporting signatures of generalized algebraic theories, as constructed in the previous section.

\subsection{Cwfs with $\Pi$-types} 
We add operator symbols $\Pi, \lambda, \app$ and equations $\beta, \eta$ to the generalized algebraic theory of cwfs. 

\subsection{Cwfs with $\N$-types} 
We add operator symbols $\N, 0, \s, \Rec$ and equations for $\Rec$.

\subsection{Cwfs with $\U_0$ closed under $\Pi$ and $\N$} 
We add operator symbols
\begin{eqnarray*}
\Gamma : \Ctx &\vdash& (\U_0)_\Gamma : \Ty(\Gamma)\\
\Gamma : \Ctx, a : \Tm(\Gamma,(\U_0)_\Gamma) &\vdash& {\Ta_0}(a) : \Ty(\Gamma)\\
\Gamma : \Ctx &\vdash& (\N^0)_\Gamma : \Tm(\Gamma,(\U_0)_\Gamma) \\
\Gamma : \Ctx, 
a : \Tm(\Gamma,(\U_0)_\Gamma), 
b :  \Tm(\Gamma \cdot \Ta_0(a), (\U_0)_\Gamma))
&\vdash&
 \Pi^0(a,b) : \Tm(\Gamma,(\U_0)_\Gamma)
\end{eqnarray*}
$(\U_0)_\Gamma$ is the first universe (a type) relative to the context $\Gamma$; $\Ta_0$ is the decoding operation mapping a term in the first universe to the corresponding type; \footnote{add discussion of sort vs type in the introduction}; $\N^0$ is the code for $\N$ in the first universe, and $\Pi^0$ forms codes for $\Pi$-types in the first universe. (Note that we have dropped the context argument of $\Ta_0$ and $\Pi^0$.)

We add the decoding equations:
\begin{eqnarray*}
\Ta_0(\N^0_\Gamma) &=& \N_\Gamma\\
\Ta_0(\Pi^0(a,b)) &=& \Pi(\Ta_0(a),\Ta_0(b))
\end{eqnarray*}
and the equations for preservation of substitution:
\begin{eqnarray*}
{(\U_0)}_\Gamma [ \gamma ] &=& {(\U_0)}_\Delta\\
\Ta_0(a) [ \gamma ] &=& \Ta_0(a[ \gamma ] )\\
\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^0(a,b)[ \gamma ] &=& \Pi^0(a [ \gamma ], b[ \gamma^+ ])
\end{eqnarray*}
where $\gamma^+ = \tuple{\gamma \circ \p, \q}$.

We remark that the gat for the first universe is inevitably "a la Tarski" in the sense that we distinguish between types and terms in a cwf and we must have an operation decoding a term into a type. However, the terminology "a la Russell" vs "a la Tarski" in Martin-Löf's sense refers to two different formalizations of the raw syntax and inference rules of type theory. The a la Tarski formulation is the one which arises most directly by turning the gat signature into its initial cwf. However, we can prove that the a la Russell formulation also gives rise to an initial cwf for the same signature. It follows that a la Tarski and a la Russell give rise to isomorphic cwfs that support a first universe.

%\subsection{Cwfs with universe tower structures} 
%
%The first formulation of intuitionistic type theory with an infinite sequence of universes is due to Martin-Löf
%\cite{martinlof:predicative}. Rules for cumulativity (or lifting) were added in Martin-Löf \cite{martinlof:hannover}. Both formulations have an infinite sequence of universes indexed by external natural numbers, and as a consequence the theories have infinitely many rules. 
%
%We shall now formalize a notion of finitary gat closely related to Martin-Löf's cumulative version. The external natural number indices will be represented by internal level indices in the gat. To this end we introduce a new sort symbol 
%$$
%\vdash \Level
%$$
%in addition to the previous four sort symbols. (However, we do not have a {\em type} of levels.) An element $n : \Level$ represent an external natural number. (Note that the new sort $\Level$ corresponds to adding a new form of judgment $\vdash n\  \Level$ to the formal system.)
%
%We add operator symbols for levels
%\begin{eqnarray*}
%&\vdash& 0 : \Level\\
%n : \Level &\vdash& \s(n) : \Level
%\end{eqnarray*}
%and operator symbols for types and terms:
%\begin{eqnarray*}
%n : \Level, \Gamma : \Ctx &\vdash& (\U_n)_\Gamma : \Ty(\Gamma)\\
%n : \Level, \Gamma : \Ctx, a : \Tm(\Gamma,(\U_n)_\Gamma) &\vdash& {\Ta_n}(a) : \Ty(\Gamma)\\
%n : \Level, \Gamma : \Ctx &\vdash& (\N^n)_\Gamma : \Tm(\Gamma,(\U_n)_\Gamma) \\
%n : \Level, \Gamma : \Ctx, 
%a : \Tm(\Gamma,(\U_n)_\Gamma), 
%b :  \Tm(\Gamma \cdot \Ta_n(a), (\U_n)_\Gamma))
%&\vdash&
% \Pi^n(a,b) : \Tm(\Gamma,(\U_n)_\Gamma)\\
%n : \Level, \Gamma : \Ctx &\vdash& (\U^n)_\Gamma \in \Tm(\Gamma,(\U_{\s(n)})_\Gamma)\\
%n : \Level, \Gamma : \Ctx, a : \Tm(\Gamma,(\U_n)_\Gamma) &\vdash& \Ta_n^{n+1}(a)\footnote{200804: should we change notation $\Ta_n^{n+1}$ to $\Ta^n$?} : \Tm(\Gamma,(\U_{\s(n)})_\Gamma)
%\end{eqnarray*}
%The last operator symbol is the lifting (or cumulativity) operator. We have the following equations
%\begin{eqnarray*}
%\Tan((\N^n)_\Gamma) &=& \N_\Gamma\\
%\Ta_n(\Pi^{n}(a,b)) &=& \Pi(\Ta_n(a),\Tan(b))\\
%\Ta_{\s(n)}((\U^n)_\Gamma ) &=& (\U_n)_\Gamma\\
%%&\Ta_{n+1}(\Ta_n^{n+1}(a)) &=& \Ta_n(a)\\
%\Ta^{n+1}_n((\N^n)_\Gamma) &=& (\N^{\s(n)})_\Gamma\\
%\Ta^{n+1}_n(\Pi^{n}(a,b)) &=& \Pi^{\s(n)}(\Ta^{n+1}_n(a),\Ta^{n+1}_n(b))
%\end{eqnarray*}
%Finally, all operator symbols commute with substitution:
%\begin{eqnarray*}
%{(\Un)}_\Gamma [ \gamma ] &=& {(\Un)}_\Delta\\
%\Tan(a) [ \gamma ] &=& \Tan(a[ \gamma ] )\\
%\N^n_\Gamma [ \gamma ] &=&\N^n_\Delta\\
%\Pi^{n}(a,b)[ \gamma ] &=& \Pi^{n}(a [ \gamma ], b[ \gamma^+ ])\\
%\U^n[\gamma] &=& \U^n\\
%\Ta_n^{n+1}(a)[\gamma]  &=& \Ta_n^{n+1}(a[\gamma])
%\end{eqnarray*}
%Mention a la Russell initiality?
%
%\subsection{Removing cumulativity} Agda, cumulativity up to equivalence.
%
%\subsection{Cwfs with universe polymorphic tower structures} Here we need to extend the cwf-framework further to take into account contexts with level variables, etc.

\section{Related work}

Palmgren and Vickers \cite{palmgrenvickers}.

The first proof of initiality of a formal system with dependent types is due to Streicher \cite{streicher:semtt}. He proved that the formal system for the Calculus of Construction forms an initial object in a category of contextual categories with extra structure for interpreting the whole calculus. Recently, Brunerie \cite{brunerie:initiality} presented a formalized proof in the Agda system that a formal system for Martin-Löf type theory forms an initial object in a category of contextual categories with extra structure for interpreting
the type formers.

Voevodsky's initiality conjecture programme.

\footnote{Mention LF-encodings, mention work on initiality conjecture? Uemura}

Our $\T_\Sigma$ is closely related to Altenkirch and Kaprosi's quotient inductive-inductive types \cite{altenkirch:qiits}. Inductive-inductive types \cite{nordvallforsberg:iids} is a generalization of mutual inductive families, where one index set may depend on another. The motivating example is the formal system of type theory by simultaneously defining contexts, substitutions depending on contexts, types depending on context, and terms depending on types and contexts. We can do so by considering the sort symbols of the gat of cwfs as formation rules and the operator symbols as introduction rules. A quotient inductive-inductive type is a combination of quotient types and inductive-inductive types, where there are also constructors witnessing equations. Our $\T_\Sigma$ differs from Altenkirch and Kaprosi's notion in the following respects. The stipulated equations in $\Sigma$ generate judgmental equalities in a system for dependent type theory implementing $\T_\Sigma$. On the other hand quotient inductive-inductive types are developed in the setting of an intensional type theory, such as Agda's, and the stipulated equations are propositional equalities and hence we need to use transport maps when we move between equal types. 

%Given that we have definition of a valid signature $\Sigma$ and a semantics for $\T_\Sigma$ we could ask whether we could add the construction of these to type theory. This would make most sense in extensional type theory, since we can then move seamlessly between propositional and judgmental equalities. It is however, not clear how to provide canonical form semantics in the sense of Martin-Löf's meaning explanations for this notion. However, although our development takes place in set theory, everything we do is constructive and could be formalized in CZF presumably.

\bibliographystyle{plain}
\bibliography{refs}
%\input{referenc}
\end{document}
