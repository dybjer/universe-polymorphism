\section{Adding level-constraints}

\subsection{The level-indexed scwf of level constraints}

Constraints are lists of equations between level terms. We formalize the theory of constraints as level-indexed scwfs $(\cctx, \chom, \cty, \ctm)$.\footnote{Maybe we don't need the full scwf structure, but only lists of identities and projections to pull them out.} The gat of level-indexed scwf is the same as the gat of level-indexed cwfs defined above, except that in a scwf types don't depend on type contexts.\footnote{In a level-indexed scwf, types do depend on level contexts, though.} \footnote{In the published paper all constraint contexts are loop-free "The second condition is that the finite set of constraints in the extended context $\Gamma, \psi$ is loop-free." Here we prefer to allow arbitrary constraints as a first step. As a second step, suggested by Georges Gonthier, we add a rule that all types are equal to the unit type in a context that is not loop-free. Such a theory still has decidable type-checking.}

The following new sort symbols come from the structure of a level-indexed scwf:
\begin{eqnarray*}
n : \lctx &\vdash& \cctx_n\\
n : \lctx, \psi : \cctx(n), \psi' : \cctx(n) &\vdash& \chom_n(\psi,\psi')\\
n : \lctx &\vdash& \cty_n\\
n : \lctx, \psi : \cctx_n, c : \cty_n &\vdash& \ctm_n(\psi,c)
\end{eqnarray*}

The extra structure for level-indexed scwfs is given by the following operator symbol $\leq$ for {\em level equality} as types in the level-indexed scwf of constraints\footnote{equality reflection in ordinary type theory is the following equation in generalized algebraic theories:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), a, a' : \tm(\Gamma, A),p :  \tm(\Gamma,\Id_A(a,a'))&\vdash& a = a' : \tm(\Gamma,A)
\end{eqnarray*}
}
\begin{eqnarray*}
n : \lctx, l, l' : \ltm_n &\vdash& \leq(l,l') : \cty_n
\end{eqnarray*}
A constraint type $c : \cty_n$ is a level equation 
$\leq(l,l')$ in $n$ variables reflecting a level equation $l = l'$.
We note that $\leq$ is the only constructor for constraint types $\cty$. 
Consequently, by the basic structure for level-indexed scwfs,
a constraint "context" $\psi : \cctx_n$ is a list of constraint types, 
that is, a list of level equation types in $n$ variables. 
A constraint "term" $p : \ctm_n(\psi,c)$ is a proof that the equation $c$ is
in $\psi$.
% imply the equation $c$, see \cref{exa:cctx-entails-lattice-eqs}
%and \cref{lem:cctx-entails-lattice-eqs}.%
\footnote{We don't need 
any term constructors for $\leq$ beyond $\q$ from the basic
scwf set up. The reason is that all reasoning about level equations 
(except using a constraint assumption) is done using judgmental equalities.} 

Reasoning about level equality will be performed on the judgmental level. To this end we introduce a new sort for level terms with respect to constraints:
\begin{eqnarray*}
n : \lctx, \psi : \cctx_n &\vdash& \ltmq_n(\psi)
\end{eqnarray*}
This is to be understood as the quotient sort of $\ltm$ with respect to the equivalence relation generated by the constraints in $\psi$.
%and the laws for $\vee$ and $(-)^+$. 
We have a new operator symbol $[-]_{-}$ for equivalence class formation with its equation:
\begin{eqnarray*}
n : \lctx, \psi : \cctx_n,  l : \ltm_n &\vdash& [l]_\psi  : \ltmq_n(\psi)\\
n : \lctx, \psi : \cctx_n,  l, l' : \ltm_n, p : \ctm_n(\psi,\leq(l,l')) &\vdash& [l]_\psi  = [l']_\psi  : \ltmq_n(\psi)
\end{eqnarray*}
Note that the equation is a version of equality reflection: from a "propositional" level equality $\leq(l,l')$ we derive a judgmental level equality, and it is the latter that enables equational reasoning about $\vee$ and $(-)^+$ and $\psi$.
\begin{example}\label{exa:cctx-entails-lattice-eqs}
In our old paper we have a judgment form $\Gamma \vdash \psi\ \valid$ that expresses that the constraints in $\psi$
hold in $\Gamma$, that is, are implied by the constraints in $\Gamma$.
For example, if $\alpha$ and $\beta$ are level variables we can prove
$$
\alpha = \alpha\vee\beta, \beta\vee\alpha = \beta \vdash \alpha = \beta\ \valid
$$
by equational reasoning using commutativity of $\vee$ (one of the semilattice laws) in our system.

What does this correspond to in the present setting? Recall that each gat with sort symbols, operator symbols and equations in $\Sigma$ has an initial model $\T_\Sigma$. As shown in our paper on gats and cwfs, this can be defined as a variable free, explicit substitution calculus for dependent type theory built from cwf-combinators and the operator symbols in $\Sigma$\cite{bezem:hofmann}. In this calculus the above judgment corresponds to a level equation
$$
[\alpha]_{\psiab} = [\beta]_{\psiab} : \ltmq_2(\psiab)
$$
This is a judgment in the level context $2 = \s(\s(0)) : \lctx$ and the variables are defined as the projections $\alpha = \q[\p] : \ltm_2$ and $\beta = \q  : \ltm_2$ in the ucwf of levels. Moreover, 
$$
\psiab = 1.\leq(\alpha,\alpha\vee\beta).\leq(\beta\vee\alpha,\beta) : \cctx_2
$$
is a constraint context. The derivation of this in $\T_\Sigma$ uses that 
$\alpha$ and $\beta$ are level terms, and so are, 
$\alpha\vee\beta$ and $\beta\vee\alpha$, all in $\ltm_2$.
Hence we have the level equality types
$\leq(\alpha,\alpha\vee\beta)$ and $\leq(\beta\vee\alpha,\beta)$ both in $\cty_2$. Hence, we can form the constraint context $\psiab : \cctx_2$.
%$1.\leq(\alpha,\alpha\vee\beta).\leq(\beta\vee\alpha,\beta) : \cctx_2$,
%which we name $\psiab : \cctx_2$ for short.
We now instantiate the equation for equality reflection
with $n := 2$, $l :=  \beta\vee\alpha, l':= \beta, \psi:= \psiab$, and $p := \q: \ctm_2(\psiab,\leq(\beta\vee\alpha,\beta))$\footnote{check signs for instatiation and definition}
as above and get 
\[
%p : \ctm_2(\psiab,\leq(\beta\vee\alpha,\beta))
%\vdash 
[\beta\vee\alpha]_{\psiab} = [\beta]_{\psiab} : \ltmq_2(\psiab).
\]
We have used that the
level equality type $\leq(\beta\vee\alpha,\beta)$ is the last type
of the constraint context $\psiab$, so that we can use the operator $\q$ 
from the basic vocabulary of cwfs, see \ref{XYZ}.
%Thus the equation for equality reflection gives us:
%\[
%\vdash [\beta\vee\alpha]_{\psiab} = [\beta]_{\psiab} : \ltmq_2(\psiab)
%\]
that is, (MB: discuss) $\beta\vee\alpha$ and $\beta$ are equivalent
modulo $\psiab$, in the empty context.)

In much the same way, using the instantiation $l := \alpha,
l' := \alpha\vee\beta$ and $p := \q[\p]$ instead of $\q$, we get
\[
%p : \ctm_2(\psiab,\leq(\alpha,\alpha\vee\beta))
%\vdash 
[\alpha]_{\psiab}=[\alpha\vee\beta]_{\psiab} : \ltmq_2(\psiab).
\]
that $\alpha$ and $\alpha\vee\beta$ are equivalent modulo $\psiab$, 
in the empty context.

Next we explain how we can get, e.g.,
$
%\vdash 
[\alpha]_{\psiab} = [\beta]_{\psiab} : \ltmq_2(\psiab).
$
This result cannot be obtained by simply using the transitivity of $=$,
we also have to show that
$
%\vdash 
[\beta\vee\alpha]_{\psiab}=[\alpha\vee\beta]_{\psiab} : \ltmq_2(\psiab).
$
The latter follows from 
$
%\vdash 
\beta\vee\alpha=\alpha\vee\beta : \ltm_2$ and the fact that operator symbols preserve equality in gats.
\end{example}


An important observation in the above example is that
both $\leq(\alpha,\alpha\vee\beta)$ and $\leq(\beta\vee\alpha,\beta)$
are elements of $\psiab$, so that we can use the projections $\q$, $\q[\p]$. If there
are more elements in a constraint context, we can use the further projections $\q[\p][\p], \q[\p][\p][\p], \ldots$
to access the other equations in the constraint list.

%\begin{conjecture}\label{conj:cctx-entails-lattice-eqs}
\paragraph{The initiality conjecture for constraints.} We would like to extend the proof in section to 3 to constraints. Roughly, we need to show the following.
Let $n:\lctx$ be a level context, $l,l':\ltm_n$ level terms and 
$\psi:\cctx_n$ a constraint context. Then (in any initial model)
%\begin{eqnarray*}
%&\vdash& 
$$
[l]_\psi = [l']_\psi  : \ltmq_n(\psi)
$$
iff
$$
\psi^* \vdash l^* = l'^*
$$
in the system of our old paper, and $\psi^*$ (of length $n$) is the interpretation of $\psi$ in the initial gat generated by the system of our old paper. Similarly, the interpretation $l^*$ of $l : \ltm_n$ is a level term where variable names in $l^*$ have replaced the projections.
%\end{conjecture}

\subsection{The level- and constraint-indexed cwf of types}

{\bf All of this needs to be rethought!}

Let 
$$
\F : \L \to \SCwF
$$
be the level-indexed scwf of constraints described above.

We have a doubly indexed cwf of types (in our type theory)
$$
\T : (n : \L) \to (\psi : \F(n)) \to \L '(n,\psi) \to \CwF
$$
or alternatively (spell out what this means officially)
$$
\T : \sum_{n : \L}\F(n) \to \CwF
$$
So the contexts $\Ctx(n,\psi)$ in the cwf $\T(n,\psi)$ denotes the (type-theoretic) contexts in $n$ level variables satisfying the constraints in $\psi$, and similarly for the context morphisms, types, and terms.

\subsection{A level- and constraint-indexed non-cumulative tower of universes}


A finitary theory!
\\
\vspace{1ex}
Operator symbols: (We  factor out the common premises $n : \lctx, \psi : \cctx_n, l : \ltmq_n(\psi), \Gamma : \ctx_n(\psi)$. Note that $l$ now ranges over level terms quotiented by constraints in $\psi$).
%\begin{tiny}
\begin{eqnarray*}
%n : \lctx, \psi : \cctx_n, l : \ltm(n), \Gamma : \ctx_n(\psi) 
&\vdash& (\U_{l})_\Gamma : \ty_n(\psi,\Gamma)\\
%n : \lctx, \psi : \cctx_n, l : \ltm(n), \Gamma : \ctx_n(\psi), 
a : \tm_n(\psi,\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta_{l}}(a) : \ty_n(\psi,\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,(\U_0)_\Gamma) \\
%n : \lctx, \psi : \cctx_n,  l, 
l' : \ltmq_n(\psi),
a : \tm_n(\psi,\Gamma,(\U_{l})_\Gamma),
b :  \tm_n(\psi,\Gamma \cdot \Ta_{l}(a), (\U_{l'})_{\Gamma \cdot \Ta_{l}(a)})
&\vdash&
 \Pihat^{l,l'}(a,b) : \tm_n(\psi,\Gamma,(\U_{l \vee l'})_\Gamma)\\
 %n : \lctx, \psi : \cctx_n, l : \ltm(\psi,n),\Gamma : \ctx_n(\psi)
 &\vdash&\UU^l_\Gamma: \tm_n(\psi,\Gamma,(\UU_{l^+})_\Gamma)
\end{eqnarray*}
Equations:
\begin{eqnarray*}
&\vdots&
\end{eqnarray*}
%\end{tiny}
There are many equations. First for each $l$, $\U_l$ satisfies all the laws of a single universe, including laws of ordinary substitution. Then we have laws for level substitution $(\U_{l})_\Gamma[\sigma] = (\U_{l[\sigma]})_{\Gamma[\sigma]}$


\subsection{Constraint-indexed products of types}
%We add three operator symbols in addition to the operator symbols for cwfs in Section 5.2 and 5.3:
\def\l{\mathrm{l}}
%\begin{tiny}
Operator symbols (universal level quantification, abstraction, and application):
(We  factor out the common premises 
$
n : \lctx, \psi : \cctx_n, c : \cty_n, \Gamma : \ctx_n(\psi), A : \ty_n(\psi.c, \Gamma[\cp])
$.)
\begin{eqnarray*}
%n : \lctx, \psi : \cctx_n, c : \cty_n, \Gamma : \ctx_n(\psi), A : \ty_n(\psi.c, \Gamma[\cp])
&\vdash& [c]A : \ty_n(\psi,\Gamma)\\
%n : \lctx, \psi : \cctx_n, c : \cty_n, \Gamma : \ctx_n(\psi), A : \ty_n(\psi.c,\Gamma[\cp]), 
t : \tm_n(\psi.c,\Gamma[\cp], A) 
&\vdash& \langle c \rangle t : \tm_n(\psi,\Gamma,[c]A)\\
%n : \lctx, \psi : \cctx_n, c : \cty_n, \Gamma : \ctx_n(\psi), A : \ty_n(\psi.c,\Gamma[\cp]), 
f :  \tm_n(\psi,\Gamma,[c]A), pr : \ctm_n(\psi,c) &\vdash& \app_c(f,l) : \tm_n(\psi,\Gamma, A[\tuple{\cid,pr}])
\end{eqnarray*}
Equations ($\beta$ and $\eta$ for level abstraction and application):
 \begin{eqnarray*}
 \app_c(\langle c \rangle(b),pr) &=& b[\tuple{\cid,c}]\\
 \langle c \rangle(\app_c(f[\cp],\cq)) &=& f
 \end{eqnarray*}
 Equations for commutativity of operator symbols wrt constraint substitution $\sigma : \lhom(m,n)$ and a term substitution $\gamma : \hom_n(\Delta,\Gamma)$:
 \begin{eqnarray*}
 ([c]B)[ \sigma ] &=& [c](B[ \sigma^{+}])\\
 ([c]B)[ \gamma ] &=& [c](B[ \gamma^\dagger ])\\
&\vdots&
\end{eqnarray*}
where $\sigma^\dagger = \tuple{\sigma \circ \cp, \cq}$ and $\gamma^\dagger = \tuple{\gamma \circ \p, \q}$??
%\end{tiny}
\footnote{Check all this. It's easy to get wrong.}

\paragraph{Comparison with the rules in our old paper about explicit universe polymorphism.}
The first two operator symbols correspond $[c]A$ and $\langle c \rangle t$ to the first two rules (with implicit contexts) in our paper:
$$
\frac{\psi \vdash A\ type}{\vdash [\psi]A}
\hspace{5em}
\frac{\psi \vdash t : A}{\vdash \langle \psi \rangle t : [\psi]A}\
$$
The third operator symbol is the application of a constraint abstraction $\langle c \rangle t : [c]A$ to a proof that the constraint $c$ is valid. This suggests the following rule in the setup of our paper:
$$
\frac{\langle \psi \rangle t : [\psi]A\hspace{3em}\psi\ \valid}
{t : A}
$$
This rule is implied by the stronger rules in our paper:
$$
\frac
{\psi\ \valid}
{[\psi]A = A}
\hspace{5em}
\frac
{\psi\ \valid}
{[\psi]t  = t}
$$

\subsection{Level-indexed products of types in the presence of constraints}

{\bf I suggest to omit this although it's somewhat interesting.}
We can also do level-indexing in the theory with constraints, provided the constraints don't depend on the abstracted level variable.

\begin{tiny}
Operator symbols (universal level quantification, abstraction, and application):
\begin{eqnarray*}
n : \lctx, \psi : \cctx_{n}, \Gamma : \ctx_n(\psi), B : \ty_{\s(n)}(\psi[\lp],\Gamma[\lp])&\vdash& \forall_\l(B) : \ty_n(\psi,\Gamma)\\
n : \lctx, \psi : \cctx_{n}, \Gamma : \ctx_n(\psi), B : \ty_{\s(n)}(\psi[\lp],\Gamma[\lp]), b : \tm_{\s(n)}(\psi[\lp],\Gamma[\lp], B) &\vdash&  \lambda_\l(b) : \tm_n(\psi,\Gamma,\forall_\l(B))\\
n : \lctx, \psi : \cctx_{n}, \Gamma : \ctx_n(\psi), B : \ty_{\s(n)}(\psi[\lp],\Gamma[\lp]), f :  \tm_n(\psi,\Gamma,\forall_l(B)),  l : \ltm(n) &\vdash& \app_\l(f,l) : \tm_n(\psi,\Gamma, B[\tuple{\lid,l}])
\end{eqnarray*}
\end{tiny}

Note the similarity with with level-indexed products of types in the absence of constraints in 2.5. We only need to insert the dependence of constraints $\psi$ in $n$ level variables. Then we can abstract with respect to types and terms in $\s(n) = n+1$ variables.
\begin{tiny}
Equations ($\beta$ and $\eta$ for level abstraction and application):
 \begin{eqnarray*}
 \app_\l(\lambda_\l(b),l) &=& b[\tuple{\lid,l}]\\
 \lambda_\l(\app_\l(f[\lp],\lq)) &=& f
 \end{eqnarray*}
 Equations for commutativity of operator symbols wrt a level substitution $\sigma : \lhom(m,n)$ and a term substitution $\gamma : \hom_n(\Delta,\Gamma)$:
 \begin{eqnarray*}
 \forall_\l(B)[ \sigma ] &=& \forall_\l(B[ \sigma^{+}])\\
 \forall_\l(B)[ \gamma ] &=& \forall_\l(B[ \gamma^\dagger ])\\
&\vdots&
\end{eqnarray*}
where $\sigma^\dagger = \tuple{\sigma \circ \lp, \lq}$ and $\gamma^\dagger = \tuple{\gamma \circ \p, \q}$??
\end{tiny}

What about substitution with respect to constraints?

\subsection{The decision problem}

The decision problem is whether the judgments are decidable in the initial model. In the initial model the ucwf of levels is finitely presented, and so are the constraints.

There is an algorithm for deciding whether a set of constraints $\psi$ is consistent \cite{bezem-coquand:lattices}. If it is consistent then a small modification of the decision algorithm for type theory with an external hierarchy of universes can be employed for the theory with constraints on levels.

If $\psi$ is inconsistent, then the theory is undecidable. If we have a loop $l = l^+$, then $\UU_l : \UU_{l^+}$ implies $\UU_l : \UU_l$.

We can recover decidability by adding the rule that any type is equal to the unit type in an inconsistent level context $\psi$:
\begin{eqnarray*}
 \Gamma : \ctx, A  : \ty(\Gamma), c : \psi &\vdash& A = 1_\Gamma
\end{eqnarray*}

\paragraph{Appendix C.} Here we add the rules
$$
\frac{A\ type\hspace{3em}l < l}{A = \emptyset}
\hspace{5em}
\frac{t : A\hspace{3em}l < l}{t = \emptyset : A}
$$
The first rule corresponds to the following operator in generalized algebraic theories:
$$
n : \lctx, \psi : \cctx_n, \Gamma : \ctx_n(\psi), l : \ltm_n, p : \ctm_n(\psi,l < l), A : \ty_n(\psi,\Gamma)
\vdash
A = 1_\Gamma
$$
where $l < l : \cty_n$ abbreviates $\leq(l^+ \vee l,l) = \leq(l^+,l)$. If we have $A = 1$ rather than $A = \emptyset$ then we don't need an analogue of the second rule.  


\paragraph{Remark.} We need to think more about this.
