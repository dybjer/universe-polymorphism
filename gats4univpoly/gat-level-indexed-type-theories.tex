\documentclass[11pt,a4paper]{article}
%\ifx\pdfpageheight\undefined\PassOptionsToPackage{dvips}{graphicx}\else%
%\PassOptionsToPackage{pdftex}{graphicx}
\PassOptionsToPackage{pdftex}{color}
%\fi

%\usepackage{diagrams}

%\usepackage[all]{xy}
\usepackage{todonotes}
\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage{latexsym}
\usepackage{amssymb,amstext,amsmath,amsthm}
\usepackage{epsf}
\usepackage{epsfig}
\usepackage{float}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage{proof}
\usepackage{latexsym}
%\usepackage{mytheorems}
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}{Lemma}[theorem]
\newtheorem*{proposition*}{Proposition}%[theorem]
\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{remark}{Remark}[theorem]
\newtheorem{TODO}{TODO}[theorem]
\newtheorem{remark}{Remark}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{conjecture}{Conjecture}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}


%%%%%%%%%copied from SymmetryBook by Marc

% hyperref should be the package loaded last
\usepackage[backref=page,
            colorlinks,
            citecolor=linkcolor,
            linkcolor=linkcolor,
            urlcolor=linkcolor,
            unicode,
            pdfauthor={BCDE},
            pdftitle={Universes},
            pdfsubject={Mathematics},
            pdfkeywords={type theory, universes}]{hyperref}
% - except for cleveref!
\usepackage[capitalize,noabbrev]{cleveref}
%\usepackage{xifthen}
\usepackage{xcolor}
\definecolor{linkcolor}{rgb}{0,0,0.5}

%%%%%%%%%
\def\oge{\leavevmode\raise
.3ex\hbox{$\scriptscriptstyle\langle\!\langle\,$}}
\def\feg{\leavevmode\raise
.3ex\hbox{$\scriptscriptstyle\,\rangle\!\rangle$}}

%%%%%%%%%

\newcommand{\mkbox}[1]{\ensuremath{#1}}
\newcommand{\eraser}[1]{}

\newcommand{\conv}{=}
%\newcommand{\conv}{\mathsf{conv}}

\newcommand{\Id}{\mathsf{Id}}
\newcommand{\Eq}{\mathsf{Eq}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\NN}{\mathsf{N}}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\UU}{\mathsf{U}}
\newcommand{\JJ}{\mathsf{J}}
\newcommand{\AgdaLevel}{\mathsf{Level}}
\newcommand{\Level}{\mathsf{level}}
\newcommand{\Lev}{{\mathbb{L}}}
%\newcommand{\Type{\hbox{\sf Type}}
\newcommand{\ZERO}{\mathsf{0}}
\newcommand{\SUCC}{\mathsf{S}}
\newcommand{\valid}{\mathsf{valid}}
\newcommand{\level}{\mathsf{level}}
%\newcommand{\type}{\mathsf{type}}
\newcommand{\const}{\mathsf{const}}
\newcommand{\lam}[1]{{\langle}#1{\rangle}}
\newcommand{\mylam}[3]{\lambda_{#1:#2}#3}
\newcommand{\mypi}[3]{\Pi_{#1:#2}#3}
\newcommand{\Upi}[3]{\Pi^{#1}\,#2\,#3}
\newcommand{\mysig}[3]{\Sigma_{#1:#2}#3}
\newcommand{\Usig}[3]{\Sigma^{#1}\,#2\,#3}
\newcommand{\app}[2]{{#1\,#2}} % many applications still hard-coded with ~
\newcommand{\Sapp}[1]{\sapp{\SUCC}{#1}}
\newcommand{\sapp}[2]{{#1(#2)}} % strict app for Id, refl, J, natrec, not S (!)
\newcommand{\Idapp}[3]{\sapp{\Id}{#1,#2,#3}}
\newcommand{\Idnapp}[4]{\sapp{\Id^#4}{#1,#2,#3}}
\newcommand{\NRapp}[4]{\sapp{\RR}{#1,#2,#3,#4}}
\newcommand{\Rfapp}[2]{\sapp{\refl}{#1,#2}}
\newcommand{\Japp}[6]{\sapp{\JJ}{#1,#2,#3,#4,#5,#6}}
\newcommand{\RR}{\mathsf{R}}
%\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Group}{\mathsf{Group}}
%\newcommand{\El}{\mathsf{El}}
%\newcommand{\T}{\mathsf{T}}
%\newcommand{\Usuper}{\UU_{\mathrm{super}}}
%\newcommand{\Tsuper}{\T_{\mathrm{super}}}
%\newcommand{\idtoeq}{\mathsf{idtoeq}}
%\newcommand{\isEquiv}{\mathsf{isEquiv}}
%\newcommand{\Equiv}{\mathsf{Equiv}}
\newcommand{\isContr}{\mathsf{isContr}}
%\newcommand{\ua}{\mathsf{ua}}
%\newcommand{\UA}{\mathsf{UA}}
%\newcommand{\natrec}{\mathsf{natrec}}
%\newcommand{\set}[1]{\{#1\}}
%\newcommand{\sct}[1]{[\![#1]\!]}
%\newcommand{\refl}{\mathsf{refl}}
\newcommand{\ttt}[1]{\text{\tt #1}}

\newcommand{\Constraint}{\mathsf{Constraint}}
\newcommand{\Ordo}{\mathcal{O}}
\newcommand{\AFu}{\mathcal{A}}
\newcommand{\Fu}{\mathit{Fu}}

\newcommand{\Ctx}{\mathrm{Ctx}}
\newcommand{\Ty}{\mathrm{Ty}}
\newcommand{\Tm}{\mathrm{Tm}}
\newcommand{\op}{\mathrm{op}}

\newcommand{\CComega}{\mathrm{CC}^\omega}
\setlength{\oddsidemargin}{0in} % so, left margin is 1in
\setlength{\textwidth}{6.27in} % so, right margin is 1in
\setlength{\topmargin}{0in} % so, top margin is 1in
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{9.19in} % so, foot margin is 1.5in
\setlength{\footskip}{.8in}

% Definition of \placetitle
% Want to do an alternative which takes arguments
% for the names, authors etc.

\newcommand\myfrac[2]{
 \begin{array}{c}
 #1 \\
 \hline \hline
 #2
\end{array}}

\def\levelctx{\mathrm{lctx}}
\def\lhom{\mathrm{lhom}}
\def\psiab{\psi_{\alpha\beta}}

\newcommand*{\Scale}[2][4]{\scalebox{#1}{$#2$}}%
\newcommand*{\Resize}[2]{\resizebox{#1}{!}{$#2$}}

\newcommand{\II}{\mathbb{I}}
\newcommand{\refl}{\mathsf{r}}
\newcommand{\MB}[1]{{\color{red}{#1}}}
%\newcommand{\mkbox}[1]{\ensuremath{#1}}


%\newcommand{\Id}{\mathsf{Id}}
%\newcommand{\conv}{=}
%\newcommand{\conv}{\mathsf{conv}}
%\newcommand{\lam}[2]{{\langle}#1{\rangle}#2}
\def\NN{\mathsf{N}}
\def\Nbb{\mathbb{N}}
\def\UU{\mathsf{U}}
\def\JJ{\mathsf{J}}
%\def\Type{\hbox{\sf Type}}
\def\ZERO{\mathsf{0}}
\def\SUCC{\mathsf{S}}

\newcommand{\RawCtx}{{\tt Ctx}}
\newcommand{\RawSub}{{\tt Sub}}
\newcommand{\RawTy}{{\tt Ty}}
\newcommand{\RawTm}{{\tt Tm}}
\newcommand{\type}{\mathsf{type}}
\newcommand{\N}{\mathsf{N}}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\El}{\mathsf{El}}
%\newcommand{\U}{\mathsf{U}} clashes with def's in new packages
\newcommand{\T}{\mathsf{T}}
\newcommand{\Usuper}{\UU_{\mathrm{super}}}
\newcommand{\Tsuper}{\T_{\mathrm{super}}}
%\newcommand{\conv}{\mathrm{conv}}
\newcommand{\idtoeq}{\mathsf{idtoeq}}
\newcommand{\isEquiv}{\mathsf{isEquiv}}
\newcommand{\ua}{\mathsf{ua}}
\newcommand{\UA}{\mathsf{UA}}
\def\Constraint{\mathsf{Constraint}}
\def\Ordo{\mathcal{O}}
\def\Pihat{\Pi}

%\def\Ctx{\mathrm{ctx}}
%\def\Ty{\mathrm{ty}}
%\def\Tm{\mathrm{tm}}
\def\Obj{\mathrm{obj}}
\def\sub{\mathrm{hom}}
\def\id{\mathrm{id}}
\def\lHom{\mathrm{lhom}}
\def\lctx{\mathrm{lctx}}
\def\lty{\mathrm{level}}
\def\ltm{\mathrm{ltm}}
\def\ltmq{\mathrm{ltmq}}
\def\leq{\mathrm{leq}}
\def\lrefl{\mathrm{lr}}
\def\lp{\mathrm{lp}}
\def\lq{\mathrm{lq}}
\def\s{\mathrm{s}}
\def\lid{\mathrm{lid}}
\def\cctx{\mathrm{cctx}}
\def\cty{\mathrm{cty}}
\def\ctm{\mathrm{ctm}}
\def\cid{\mathrm{cid}}
\def\cp{\mathrm{cp}}
\def\cq{\mathrm{cq}}
\def\chom{\mathrm{chom}}

\newcommand{\ctx}{\mathrm{ctx}}
%\newcommand{\sub}{\mathrm{sub}}
\newcommand{\ty}{\mathrm{ty}}
\newcommand{\tm}{\mathrm{tm}}
%\newcommand{\sub}{\mathrm{hom}}
\newcommand{\tuple}[1]{\langle #1 \rangle}
\def\CComega{\mathrm{CC}^\omega}
\newcommand{\cext}{.}
\def\p{\mathrm{p}}
\def\q{\mathrm{q}}
\def\app{\mathsf{app}}
\def\U{\mathsf{U}}
\def\T{\mathcal{T}}
\newcommand{\Ta}{\mathrm{T}}
\newcommand{\ta}{\mathrm{t}}

\newcommand{\natrec}{\mathsf{natrec}}
%\rightfooter{}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\sct}[1]{[\![#1]\!]}
\def\R{\mathcal{R}}

\def\L{{\mathcal{L}}}
\def\F{\mathcal{C}}
\def\CwF{\mathrm{CwF}}
\def\CwFext{\mathrm{CwF^{ext}}}
\def\CwFint{\mathrm{CwF^{up}}}
\def\Fam{\mathrm{Fam}}
\def\SCwF{\mathrm{SCwF}}
\def\C{\mathcal{C}}
\def\W{\mathsf{W}}

%\def\TTUP{\mathbf{MLTT^{\UU_l}}}
\def\Sigmaext{{\Sigma^\mathrm{ext}}}
\def\Sigmaint{{\Sigma^\mathrm{up}}}
\def\TText{{\mathbf{TT}^\mathrm{ext}}}
\def\TTint{{\mathbf{TT}^\mathrm{up}}}

\begin{document}

\title{A Generalized Algebraic Theory\\ for Type Theory
with Explicit Universe Polymorphism
%\footnote{Alternative title: Categorical Models of Type Theory or Type Theory
%with Explicit Universe PolymorphismGeneralised Algebraic Theories of Type Theories with Explicit Universe Polymorphism?}
}

\author{Marc Bezem, Thierry Coquand, Peter Dybjer, Mart\'{\i}n Escard\'o}

\date{(draft)}
\maketitle

\begin{abstract}
We present generalized algebraic theories corresponding to slightly modified versions of two of the type theories in our paper
{\em Type Theory with Explicit Universe Polymorphism}. We first present a generalized algebraic theory for categories with families with extra strucure corresponding to Martin-Löf type theory with an external tower of universes. We then present a generalized algebraic theory for level-indexed categories with families with extra structure corresponding to Martin-Löf type theory with explicit universe polymorphism. This theory has universe level judgments, internally indexed universes, and level-indexed products. In this way we get abstract syntax definitions of the two theories as initial models of their respective generalized algebraic theories. We thus abstract from details of the grammar and inference rules of the type theories and highlight their high-level structure. \todo[inline]{Add something about the construction of initial models by explicit and implicit substitutions? Add something about level equality sorts?}
\end{abstract}

\section{Introduction}

In our paper {\em Type Theory with Explicit Universe Polymorphism} \cite{BezemCDE22} we proposed several extensions of Martin-Löf type theory with universe polymorphism. We followed Courant's approach \cite{Courant02} and added universe level {\em judgments}:
$$
l\ \level
\hspace{5em}
l = l'
$$
to the usual judgment forms of type theory. Moreover, all judgments may depend on universe level variables as well as ordinary variables declared in the context. We emphasized that, unlike in Agda, universe levels do {\em not} form a {\em type} in our setting, and instead we added the above judgment forms (since then, Agda has introduced, in version 2.6.4, an option for disabling universe levels forming a type~\cite{agda:leveluniv}).  Nevertheless, we added level-indexed products $[\alpha]A$ of families of types $A\ (\alpha\ \level)$ to our theory.

In this paper we provide alternative presentations of two of the theories in the above-mentioned paper: Martin-Löf type theory with an external tower of universes $\TText$ and Martin-Löf type theory with explicit universe polymorphism $\TTint$ as outlined in the previous paragraph. We present corresponding {\em generalized algebraic theories (gats)} $\Sigmaext$ and $\Sigmaint$. Gats were introduce by Cartmell \cite{cartmell:phd,cartmell:apal} as a generalization of many sorted algebraic theories where sort symbols and operator symbols may have dependent types. Our aim is to show that 
$\TText$ and $\TTint$ (suitably modified) yield initial models of $\Sigmaext$ and $\Sigmaint$ respectively. To achieve this we need to consider versions of $\TText$ and $\TTint$ where some terms (such as applications) are decorated with types.

The gat $\Sigmaext$ is the infinitary gat of categories with families (cwfs)  \cite{dybjer:torino} with extra structure for the small type formers ($\Pi, \Sigma, \N_0, \N_1, \N, \W$) of Martin-Löf type theory and for the tower of universes $\U_l$ indexed by external natural numbers $l \in \NN$. Cwfs are models of the basic rules of dependent type theory (context formation, context morphism formation, substitutions in types and terms, projection morphism, assumption).  (Note that we use $\Sigma$ both for $\Sigma$-types and to denote (presentations of) gats. It should be clear from the context which one is meant.)

The gat $\Sigmaint$ is the finitary gat of level-indexed cwfs with extra structure for the small type formers of Martin-Löf type theory and for level-indexed universes. An indexed cwf consists of a base category $\C$ and a cwf-valued presheaf
$$
P : \C^\op \to \CwF
$$
We get a suitable model for universe polymorphism by letting $\C$ be the category of contexts of a unityped cwf (ucwf) of levels, equipping $\CwF$ with extra structure for the small type formers, adding extra structure for level-indexed universes, and also for level-indexed products of types. 

A presentation of type theory by a gat of cwfs is a higher-level and more objective notion than a presentation by grammar and inference rules. This is because the gat only records the important rules and highlights categorical structure. When building initial models in terms of grammar and inference rules, we need to include various bookkeeping rules, such as general rules of equality, and there will be a multitude of options. We hope that our common high level of abstraction will allow to prove equivalence between different options and claim that there is indeed a unique abstract notion of the mathematical theory under consideration.

The present work can be viewed more broadly as a case study for categorical logic based on gats and cwfs. The aim to replace traditional logical systems by more regular mathematical. notions go back to the early days of categorical logic. We quote Lawvere \cite{lawvere:tac-adjointness}:
\begin{quotation}
\emph{
My 1963 observation (referred to by Eilenberg and Kelly in La Jolla, 1965), that cartesian closed categories serve as a common abstraction of type theory and propositional
logic, permits an invariant algebraic treatment of the essential problem of proof theory,
though most of the later work by proof theorists still relies on presentation-dependent
formulations. ... The strategy to interpret proofs themselves as structures had
been discussed by Kreisel; however, the influential “realizers” of Kleene are not yet the
usual mathematical sort of structures.
}
\end{quotation}
This view was pursued further by Voevodsky (notes from a talk in 2010 \cite{voevodsky:cmu2010}):
\begin{quotation}
\emph{
I will speak about type systems. It is diﬃcult for a mathematician since
a type system is not a mathematical notion. I will spend a little time
explaining how I see ”type systems” mathematically.
}
\end{quotation}
He continues:
\begin{quotation}
\emph{Thesis 0. Any formal deduction system can be specified in the form of a
quasi-equational theory.} ...

\emph{Fact 1. Any quasi-equational theory has an initial model.} ...

\emph{This view of formal deduction systems has many advantages. One is that it
suggests a uniform approach to the formal description of various deductive
systems. Another one is that ”interpretations” of the deductive system are
directly connected with the models of the corresponding quasi-equational
theory.}
\end{quotation}
Voevodsky considered these issues important for the mathematical development of his Univalent Foundations of Mathematics based on dependent type theory. To advance the state 
of the art he proposed the {\em Initiality Conjecture project} the goal of which is to fdefine a general class of dependent type theories and to develop generic metatheory for theories in this class. We quote from the introduction of an extended abstract where Voevodsky \cite{voevodsky:initiality} motivates his project:
\begin{quotation}
\emph{The first few steps in all approaches to the set-theoretic semantics of dependent
type theories remain insuﬃciently understood. The constructions which have been
worked out in detail in the case of a few particular type systems by dedicated authors
are being extended to the wide variety of type systems under consideration today by
analogy. This is not acceptable in mathematics. Instead we should be able to obtain
the required results for new type systems by specialization of general theorems and
constructions formulated for abstract objects the instances of which combine together
to produce a given type system.}
\end{quotation}
In particular, one would like a generic construction showing that theories in this class are initial in corresponding categories of models. We quote Voevodsky \cite{voevodsky:initiality} again:
\begin{quotation}
\emph{A crucial component of this approach is the expected result that for a particular
class of inference rules the term model is an initial object in the category of models.
This is known as the Initiality Conjecture. In the case of the pure Calculus of
Constructions with a “decorated” application operation this conjecture was proved in
1988 by Thomas Streicher \cite{streicher:thesis}. The problem of finding an appropriate formulation
of the general version of the conjecture and of proving this general version will be the
subject of future work.}
\end{quotation}
On the surface such initiality proofs may seem straightforward, but they depend on subtle details in the formulation of grammar and inference rules. This is why Voevodsky insisted on calling such theorems ``conjectures'' until proven rigorously and, ideally, implemented in a proof assistant.

An example of an implemented proof is Brunerie and de Boer's \cite{Brunerie:initiality,deBoer:lic} proof in Agda that a version of Martin-Löf type theory with an external tower of universes is an initial contextual category \cite{cartmell:phd,cartmell:apal} with appropriate extra structure. %Theversion of type theory with de Bruijn variables and implicit substitutions.

We propose an approach to Voevodsky's project based on gats and cwfs. As shown in our paper {\em On generalized algebraic theories and categories with families} \cite{bezem:hofmann}, for each finite presentation $\Sigma$ of a gat, there is a general construction of a term model $\T_\Sigma$ and this is initial in the category $\CwF_\Sigma$ of categories with families (cwfs) \cite{dybjer:torino} with a $\Sigma$-structure. The idea is to try to capture a logical theory $\T$ by a corresponding gat $\Sigma$ such that $\T$  is initial in $\CwF_\Sigma$. It follows that $\T$ is isomorphic to the generic term model $\T_\Sigma$.

Gats and cwfs are intimately connected. Cwfs can themselves be presented as a gat $\Sigma^\CwF$, and we can extend this gat with operator symbols and equations for the type formers of Martin-Löf type theory with an external tower of universe yielding the gat $\Sigmaext$. Although this gat is infinitary, it has an initial model $\T_{\Sigmaext}$  obtained by extending the general construction of an initial model for finitary gats~\cite[Section 5.7]{bezem:hofmann}.

This sums up our approach to Voevodsky's project. We characterize dependent type theories as initial models of gats of cwfs with extra structure or, as we shall see below, gats of variations of cwfs. In this way we have generic constructions of term models but can also study alternative constructions of initial models. The reason for focusing on gats of cwfs (with extra structure) is that they occupy an intermediate place between dependent type theories defined by grammar and inference rules and notions of model based on more mainstream categorical constructions. In particular, the gat of cwfs resembles Martin-Löf's substitution calculus for dependent type theory \cite{martinlof:gbg92,tasistro:lic}.

Our approach to Voevodsky's project extends beyond dependent type theory. For example, as shown by Castellan, Clairambault, and Dybjer \cite{castellan:lambek}, by considering simply typed cwfs (scwfs) and unityped cwfs (ucwfs) we can also capture various simply typed and untyped logical systems as gats and thus widening the scope of {\em uniform categorical logic} based on gats and cwfs.

%We also discuss the relationship between the gat $\Sigmaint$ and the type theories $\TTint$ presented in Bezem et al  \cite{BezemCDE22} and also between the gat $\Sigmaext$ for Martin-Löf type theory and an externally indexed tower of universes and the corresponding type theory $\TText$.

We remark that variations of indexed cwfs capture various other logical systems and can be formalized as gats. For example, untyped predicate logic can be captured by ucwf-indexed scwfs with extra structure for the logical constants. Typed predicate logic can be captured by scwf-indexed scwfs and dependently typed predicate logic (Makkai \cite{makkai:folds}, Gambino and Aczel \cite{gambino-aczel}, Belo \cite{belo}, and Palmgren \cite{Palmgren19}) by cwf-indexed scwfs, both with suitable extra structure for type formers and logical constants.

\paragraph{Universe polymorphism.} We refer to our previous paper on explicit universe polymorphism \cite{BezemCDE22} for a presentation of the inference rules of Martin-Löf type theory with explicit universe polymorphism, where the reader can also find motivation, examples, and a discussion of related work. Here we only give a brief overview.

An implicit form of universe polymorphism in dependent type theory was introduced by Huet \cite{Huet87} and is an essential feature of the proof assistant Coq (Rocq) \cite{coq:general}. Alternatively, Agda \cite{agda-wiki} and Lean \cite{moura:lean} employ versions of universe polymorphism, where universe levels are explicitly declared.

\todo[inline]{After the reorganization, we can end the introduction here, except pointing out that we haven't mentioned the calculus with constraints. And we should of course keep the dedication to Stefano. We could add references to Section 2 and 3 higher up.}
 In our paper we followed Courant's approach \cite{Courant02} to explicit universe polymorphism with universe level {\em judgments}:
$$
l\ \level
\hspace{5em}
l = l'
$$
in addition to the usual judgment forms of type theory. Moreover, all judgments may depend on universe level variables as well as ordinary variables declared in the context. We emphasized that, unlike in Agda, universe levels do {\em not} form a {\em type} in our setting, and instead we added the above judgment forms (since then, Agda has introduced, in version 2.6.4, an option for disabling universe levels forming a type~\cite{agda:leveluniv}).  Moreover, we added level-indexed products $[\alpha]A$ of a families of types $A\ (\alpha\ \level)$ to our theory.

Furthermore, we presented an extension where equational constraints between universe levels can be declared \cite{BezemCDE22}, building on a proposal by Voevodsky \cite{VV}. This extension can also be described by a gat, but we postpone this topic to a forthcoming paper.

\paragraph{Background.}
%In Section 2 we present the infinitary gat $\Sigmaext$ of cwfs with extra structure for the type formers and an externally indexed tower of universes. We consider both cumulative and non-cumulative universes. In Section 3 we present the finitary gat $\Sigmaint$ of ucwf-indexed cwfs with extra structure for the type formers and an internally indexed tower of universes. An interesting feature here is the need for an extra sort of level equality needed for expressing equational constraints.
%%(* In Section 4 we present the generalized algebraic theory of cwfs with extra structure doubly indexed by levels and level constraints *). (* In Section 5 we discuss models *).
%In Section 4 we discuss related and further research. There is also an appendix with operator symbols and equations for level-indexed type theory that were not included in Section 3.
%
%\paragraph{Important notions.}

In Bezem, Coquand, Dybjer, and Escard\'o \cite{bezem:hofmann} we defined the notion of a correct presentation $\Sigma$ of a gat and its category of models $\CwF_\Sigma$ of cwfs with a $\Sigma$-structure. (Gats are based on the basic rules for dependent types, and hence they are modelled by cwfs with extra structure.) We also constructed a term model $\T_\Sigma$ and proved that it is initial in $\CwF_\Sigma$.

In the present paper we shall discuss the following two versions of Martin-Löf type theory with universes presented by Bezem, Coquand, Dybjer, and Escard\'o \cite{BezemCDE22}:
\begin{itemize}
\item In Section 2 and 3 of that paper we presented a version with an external tower of universes closed under the standard small type formers. In order to prove initiality we shall here consider a modified version of this theory where some terms (such as applications) are decorated with type information. We refer to the modified theory as $\TText$.
\item In Section 4 of that paper we presented a version of Martin-Löf type theory with explicit universe polymorphism. This theory has universe level judgments, internally level-indexed universes, and level-indexed products of types. We again consider a version with decorated terms and refer to it as $\TTint$ for ``type theory with universe polymorphism''.
\end{itemize}

\paragraph{Plan of the paper.}
In this article we present the corresponding gats:
\begin{itemize}
\item in Section 2 we present the gat $\Sigmaext$ of cwfs with an external tower of universes closed under the standard small type formers. We also discuss the construction of initial models including the conjecture that a term model based on $\TText$ is initial in $\CwF_\Sigmaext$.
\item In Section 3 we present the gat $\Sigmaint$ of level-indexed cwfs with extra structure for the standard small type formers, level-indexed universes closed under them, and level-indexed $\Pi$-types. (Some of the operator symbols and equations are relegated to the appendix.) We also discuss the construction of initial models including the conjecture that a term model based on $\TTint$ is initial in $\CwF_\Sigmaint$.
\item
In Section 4 we discuss related and further research.
\end{itemize}

\paragraph{Dedication.} We dedicate this article to professor Stefano Berardi, the University of Torino, on the occasion of his 60th birthday. Stefano is a friend, colleague, and coauthor, who spent the winter and spring 1993/94 in the type theory group in Göteborg. He has made fundamental contributions to type theory and constructivity and in particular to understanding the constructive content of classical logic and to the constructive analysis of impredicativity.

\section{Type theory with an external tower of universes}

\subsection{The gat of cwfs} A cwf consists of a base category $\C$ of contexts and context morphisms (substitutions), a family-valued presheaf
$$
T : \C^\op \to \Fam
$$
and a notion of context comprehension. Here $\Fam$ is the category of indexed families of sets $(A,B)$, where $A$ is the index set and $B$ is a family of sets indexed by $A$. The object part of the presheaf $T$ maps a context to the family of terms indexed by a type. The arrow part represents substitution in types and terms. The reader is referred to Dybjer \cite{dybjer:torino}, Hofmann \cite{hofmann:cambridge}, and Castellan et al \cite{castellan:lambek} for a full definition and further information about cwfs.

The gat of cwfs with extra structure for $\Pi$-types, a notion of model of Martin-Löf type theory with $\Pi$-types, was presented by Dybjer \cite{dybjer:torino}. The extra operator symbols and equations needed for the natural number type and one universe can for example be found in Bezem et al \cite{bezem:hofmann}. We will use the same notation for gats as in the latter paper.

\paragraph{Sort symbols.}
The gat of cwfs has four sort symbols:
\begin{eqnarray*}
&\vdash& \ctx\\
\Delta, \Gamma : \ctx&\vdash& \sub(\Delta,\Gamma)\\
\Gamma : \ctx&\vdash& \ty(\Gamma)\\
\Gamma : \ctx, A : \ty(\Gamma)&\vdash& \tm(\Gamma,A)
\end{eqnarray*}
corresponding to the objects and morphisms of the category of contexts, and the family of terms indexed by types in a given context, respectively. The notation states that $\ctx$ is a constant sort symbol, that $\sub$ is a binary sort symbol depending on arguments $\Delta, \Gamma : \ctx$, that $\ty$ is a unary sort symbol depending on the argument $\Gamma : \ctx$, and $\tm$ is a binary sort symbol depending on arguments $\Gamma : \ctx, A : \ty(\Gamma)$.

\paragraph{Operator symbols.}
The gat of cwfs has operator symbols for the basic operations of cwfs (identity and composition of context morphisms, substitution in types and terms, empty context and context morphism, context extension and context morphism extension, projection morphism, last variable term)\todo{MB: should we separate them into four groups: structure for the base category, for the arrow part of the family valued functor, for the terminal object, and for context comprehension?}:
\begin{eqnarray*}
\Gamma : \ctx &\vdash& \id_{\Gamma} : \sub(\Gamma,\Gamma)\\
\Xi,\Delta,\Gamma : \ctx, \gamma : \sub(\Delta,\Gamma), \delta : \sub(\Xi,\Delta) &\vdash&
\gamma \circ \delta : \sub(\Xi,\Gamma)\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \sub(\Delta,\Gamma) &\vdash&
A[\gamma] : \ty(\Delta)\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \sub(\Delta,\Gamma), a:\tm(\Gamma,A) &\vdash&  a[\gamma] : \tm(\Delta,A[\gamma])\\
&\vdash& 1 : \ctx\\
\Gamma : \ctx &\vdash& \tuple{}_\Gamma : \sub(\Gamma,1)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \Gamma\cext A : \ctx\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \sub(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash& \tuple{\gamma,a} : \sub(\Delta,\Gamma\cext A)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \p_{\Gamma,A}: \sub(\Gamma\cext A,\Gamma)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \q_{\Gamma,A}: \tm(\Gamma\cext A,A[\p])
\end{eqnarray*}
The first line states that identity is a unary operator symbol with argument $\Gamma : \ctx$. The second line states that $\circ$ is a binary operator symbol with five arguments $\Xi,\Delta,\Gamma : \ctx, \gamma : \sub(\Delta,\Gamma), \delta : \sub(\Xi,\Delta)$ and result sort $\sub(\Xi,\Gamma)$. Note that only two of the five official arguments are explicit. To alleviate notation, we often suppress arguments of operator symbols. Note also that we overload notation for type and term substitution $A[\gamma]$ and $a[\gamma]$. Moreover, we sometimes drop further arguments and write $\id, \tuple{},\p,\q$ without the arguments in index position.

\paragraph{Equations.}
The gat of cwfs has 13 equations. We illustrate the notation by showing one of the laws for identity morphisms:\begin{eqnarray*}
\Delta, \Gamma : \Obj, \gamma : \sub(\Delta,\Gamma) &\vdash& \id_\Gamma \circ \gamma = \gamma : \sub(\Delta,\Gamma)
%\\
%\Delta, \Gamma : \Obj, \gamma : \sub(\Delta,\Gamma) &\vdash& \gamma \circ \id_\Delta = \gamma : \sub(\Delta,\Gamma)\\
%\Theta, \Xi,\Delta,\Gamma : \Obj, \gamma : \sub(\Delta,\Gamma), \delta : \sub(\Xi,\Delta), \xi : \sub(\Theta,\Xi) &\vdash&
%(\gamma \circ \delta) \circ \xi = \gamma \circ (\delta \circ \xi): \sub(\Theta,\Gamma)
\end{eqnarray*}
In the official notation both argument and result types are explicit. However, to alleviate notation we often drop them and only write:
\begin{eqnarray*}
\id_\Gamma \circ \gamma = \gamma
\end{eqnarray*}
However, there are specific cases where we need the official notation. Assume that we add an operator symbol for the identity type former $\Id$ in Martin-Löf type theory:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), a, a' : \tm(\Gamma, A) &\vdash \Id_{\Gamma,A}(a,a'): \ty(\Gamma)
\end{eqnarray*}
In extensional Martin-Löf type theory \cite{martinlof:hannover} we have the rule of equality reflection. This can be captured by an equation in gats:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), a, a' : \tm(\Gamma, A),p :  \tm(\Gamma,\Id_{\Gamma,A}(a,a'))&\vdash& a = a' : \tm(\Gamma,A)
\end{eqnarray*}
Note that the variable $p$ does not occur on the right hand side.
However, it is a very important variable expressing
the condition under which $a=a'$ holds and must not be omitted.
%We will meet a similar case for reflection on equality on level terms.

We refer to Bezem et al \cite{bezem:hofmann} for the remaining cwf-equations. The reader may also consult the appendix where the equations for level-indexed cwfs are displayed.


\subsection{The gat of cwfs with an external tower of universes}
In Bezem et al \cite{BezemCDE22} we began by displaying the inference rules for Martin-Löf type theory with an external tower of universes $\UU_l$, where $l \in \Nbb$ is an external natural number. Here we show the operator symbols and equations for the corresponding gat.

We assume that we already have defined the gat of cwfs with the extra structure for the standard small type formers $\Pi, \Sigma, \N_0, \N_1, \N_2, \N, \W$, and $\Id$, and we wish to define a tower of universes closed under those. To save space, we shall however only display the operator symbols and equations for closure under $\Pi$-types, since it is straightforward to add similar operator symbols for closure under the other small type formers. We shall use the same convention throughout the paper.

\paragraph{Operator symbols.}
The operator symbol for $\Pi$-types is
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), B : \ty(\Gamma.A) &\vdash& \Pi(A,B) : \ty(\Gamma)
\end{eqnarray*}
and refer to Bezem et al \cite{bezem:hofmann} for the operator symbols for abstraction and application, equations for the $\beta$ and $\eta$ rule, and equations expressing that $\Pi$, abstraction, and application commute with term substitution. We also refer to the appendix for the level-indexed version.

In the gat for externally indexed universes we have the following families of operator symbols (the universes $\UU_l$, the decoding maps $\Ta_l$, codes for $\Pi$, and codes for $\UU_l$ in $\UU_m$ for $l, l' , m \in \Nbb$ with $l < m$):
\begin{eqnarray*}
\Gamma : \ctx &\vdash& (\U_{l})_\Gamma : \ty(\Gamma)\\
\Gamma : \ctx, a : \tm(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta_{l}}(a) : \ty(\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,(\U_0)_\Gamma) \\
\Gamma : \ctx,
a : \tm(\Gamma,(\U_{l})_\Gamma),
b :  \tm(\Gamma . \Ta_{l}(a), (\U_{l'})_\Gamma)
&\vdash&
 \Pihat^{l,l'}(a,b) : \tm(\Gamma,(\U_{l \vee l'})_\Gamma)\\
 \Gamma : \ctx&\vdash&(\UU^m_l)_\Gamma: \tm(\Gamma,(\UU_{m})_\Gamma)
\end{eqnarray*}
Note that codes for $\Pi$ are doubly indexed and $l \vee l' = \max(l,l')$.
We have again left some arguments to operator symbols implicit. For example, the decoding operators $\Ta_l$ are binary operators with official notation $\Ta_l(\Gamma,a)$. However, in the notation above we omit $\Gamma$ and write $\Ta_l(a)$.

\paragraph{Equations.}
We have the following decoding equations:
\begin{eqnarray*}
%\Ta(\N^0_\Gamma) &=& \N_\Gamma\\
\Ta_{l \vee l'}(\Pi^{l,l'}(a,b)) &=& \Pi(\Ta_l(a),\Ta_{l'}(b))\\
\Ta_{m}((\UU^m_l)_\Gamma) &=& (\UU_l)_\Gamma
\end{eqnarray*}
Moreover, the operator symbols commute with term substitution:
\begin{eqnarray*}
(\U_l)_\Gamma [ \gamma ] &=& (\U_l)_\Delta\\
\Ta_l(a) [ \gamma ] &=& \Ta_l(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^{l,l'}(a,b)[ \gamma ] &=& \Pi^{l,l'}(a [ \gamma ], b[ \gamma^\dagger ])\\
(\UU^m_l)_\Gamma[ \gamma ] &=&(\UU^m_l)_\Delta
\end{eqnarray*}
where $\gamma : \sub(\Delta,\Gamma)$ and $\gamma^\dagger = \langle \gamma \circ \p_{\Delta,\Ta_l(a[\gamma])}, \q_{\Delta,\Ta_l(a[\gamma])}\rangle : \sub(\Delta.\Ta_l(a[\gamma]),\Gamma.\Ta_l(a))$.
%\paragraph{Adding cumulativity.}

If we want a cumulative tower of universes we add operator symbols that lift elements in the $l$th universe to the $m$th universe for $l < m$:
\begin{eqnarray*}
\Gamma : \ctx, a : \tm(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta^m_{l}}(a) : \tm(\Gamma,(\U_{m})_\Gamma))
\end{eqnarray*}
In the presence of cumulativity it suffices that codes for $\Pi$ have one superscript rather than two:
\begin{eqnarray*}
\Gamma : \ctx,
a : \tm(\Gamma,(\U_{l})_\Gamma),
b :  \tm(\Gamma \cdot \Ta_{l}(a), (\U_{l})_\Gamma))
&\vdash&
 \Pihat^{l}(a,b) : \tm(\Gamma,(\U_{l})_\Gamma)
 \end{eqnarray*}
 We omit the equations for the cumulative case, see instead the cumulative case for level-indexing.
 This concludes the presentation $\Sigmaext$ of a gat for cwfs with small type formers and an external tower of universes.

\subsection{Syntax and inference rules as an initial model}\label{initiality-external}

\paragraph{A generic construction based on explicit substitutions.} In our paper {\em On generalized algebraic theories and categories with families} \cite{bezem:hofmann} we define the notion of a correct {\em presentation} $\Sigma$ (a finite list of sort symbols, operator symbols, and equations) of a gat and the associated category of models $\CwF_\Sigma$ of cwfs with a $\Sigma$-structure. We then construct for each $\Sigma$ an initial object $\T_\Sigma$ in $\CwF_\Sigma$ as a type theory defined in terms of a grammar and inference rules. This type theory is a calculus of explicit substitutions based on untyped cwf-combinators and untyped versions of the operator symbols.

In the current section we have presented the {\em infinitary} gat $\Sigmaext$ of cwfs with extra structure for the small type formers and a tower of universes. However, the above construction of an initial model applies to {\em finitary} gats. Nevertheless, as explained in Section 5.7 of Bezem et al  \cite{bezem:hofmann}, we can generalize our construction to some non-finitely presented gats. If we have an increasing sequence of signatures $\Sigma_n$ we can build the initial model $\T_\Sigma$ of their union $\Sigma$ in stages. In this way we can build an initial model of $\Sigmaext$ as a union of $\Sigma_n$ -- the gats of cwfs with extra structure for the small type formers and a truncated tower of $n$ universes.

As explained in Bezem et al \cite{bezem:hofmann}, $\CwF_{\Sigmaext}$ is the category of cwfs with an {\em internal} cwf with extra structure for the small type formers and a tower of universes.
%As already mentioned, the grammar and inference rules for an initial model can be obtained by a general construction for finitary gats \cite{bezem:hofmann} and this construction can be extended to some non-finitary gats \cite{bezem:hofmann}
% The recipe is to build the judgment structure of the theory from the sort symbols of the gat, and the syntax of raw terms, types, contexts and context morphisms from untyped versions of the cwf-combinators and the operator symbols of the gat. Then one defines a system of inference rules from the typings of the cwf-combinators and the operator symbols of the gat. This yields an explicit substitution calculus for dependent type theory quite similar to Martin-Löf's \cite{martinlof:gbg92,tasistro:lic} but with named variables replaced by projections of the form $\q[\p^n]$.

\paragraph{A construction based on implicit substitutions (initiality conjecture).}
We shall outline how to construct an initial object in $\CwF_{\Sigmaext}$ based on $\TText$ -- the type theory with an external tower of universes presented in Bezem et al \cite{BezemCDE22}. However, as we explained in the introduction, we need to modify our syntax and work with decorated terms; for example, we need to decorate application with type information. We refer to this as the {\em raw syntax}, that is, expressions that are not necessary well-typed. In the raw syntax we include raw context morphisms, although such are not mentioned in loc.cit. These are lists of raw terms, where $\tuple{}$ denotes the empty list, and $\tuple{\gamma,a}$ denotes the list $\gamma$ extended by a new term $a$.

To build an internal cwf with extra structure for the small type formers and a tower of universes, we interpret the sort symbols in terms of the judgment forms of $\TText$ as follows:

\todo[inline]{The following is incomplete and under revision}

The term model should have the following properties:
\begin{itemize}
\item $\Gamma \in \Tm(1,\ctx)$) iff $\Gamma \vdash$ quotiented by the equivalence relation of context equality $\Gamma = \Gamma' \vdash$. The latter is not stated explicitly in loc.cit. but can easily be added.
\item $A \in \Tm(1,\ty[\tuple{\Gamma}]$ iff $\Gamma \vdash A$ quotiented by the equivalence relation $\Gamma \vdash A = A'$.
\item $a \in \Tm(1,\tm[\tuple{\Gamma,A}]$) iff $\Gamma \vdash a : A$ quotiented by the equivalence relation $\Gamma \vdash a = a' : A$.
\item There are no explicit judgments $\Delta \vdash \gamma : \Gamma$ and $\Delta \vdash \gamma = \gamma' : \Gamma$  in loc.cit, but these can be defined in terms of $\Delta \vdash a : A$ and $\Delta \vdash a = a' : A$. Then $\gamma \in \Tm(1,\sub[\tuple{\Delta,\Gamma}]$) iff $\Delta \vdash \gamma : \Gamma$ quotiented by the equivalence relation $\Delta \vdash  \gamma = \gamma' : \Gamma$.
\end{itemize}
However, how do we define $\Tm(\Delta,\mathbf{A})$ for a general ``gat-context''$\Delta$ and sort (``gat-type") $\mathbf{A}$?
\footnote{Before that we need to define the types of the cwf corresponding to the sorts. We should be able to conclude
\begin{itemize}
\item $\ctx \in \Ty(1)$
\item $\sub \in \Ty(1.\ctx.\ctx[\p])$
\item $\ty \in \Ty(1.\ctx)$
\item $\tm \in \Ty(1.\ctx.\ty)$
\end{itemize}
}

We then need to define the operator symbols on equivalence classes. First we consider those that give rise to constructors of raw syntax. For example:
\begin{itemize}
\item The empty context is a constructor of raw contexts. $1 \in \Tm(1,\ctx)$, where the latter "1" is the empty meta-context, is the equivalence class of the empty context.
\item Context extension is also a constructor of raw contexts. If we overload notation and use the same symbol for the the syntax and the model we have $[\Gamma].[A] = [\Gamma.A] \in \Tm(1,\ctx)$. We need to show that this operation preserves equivalence classes.
\item Similarly for the constructors of raw cwf-morphisms $\tuple{}$ and $\tuple{-,-}$.
\item The operator symbols for the type formers, such as $\Pi, \lambda, \app$ for $\Pi$-types and $\U_l, \Ta_l, \U^m_l$ and $\Ta^m_l$ are also constructors of raw syntax.
\end{itemize}
Then we consider the operator symbols that correspond to implicit operations. For example:
\begin{itemize}
\item If $A$ is a raw type and $\gamma$ is a raw substitution, we first define the result $A[\gamma]$ of substituting $\gamma$ in $A$ by induction on the structure of the latter. Then we raise this operation to equivalence classes by proving that equality of types and equality of context morphisms is preserved.
\item Similarly for substitution in raw terms.
%if $a$ is a raw term and $\gamma$ is a raw substitution, we first define the result $a[\gamma]$ of substituting $\gamma$ in $a$ by induction on the structure of the latter. Then we raise this operation to equivalence classes by proving that equality of terms is preserved.
\item Similarly for the other implicit operations $\id, \circ, \p, \q$.
\end{itemize}
To prove that we construct an object in $\CwF_\Sigmaext$, we need to check the gat-equations. Then we need to show that there is a unique morphism in $\CwF_\Sigmaext$ to any other object.

It is worthwhile looking at the differences between the initiality proof outlined above and the proof implemented in Agda by Brunerie and de Boer \cite{Brunerie:initiality,deBoer:lic}. After all, their proof is about a version of type theory with an external tower of universes similar to ours. One difference is that their universes are \`a la Russell, while we present both versions \`a la Tarski and \`a la Russell. Moreover, they just have the rule $\UU_l : \UU_{l+1}$ and only consider the non-cumulative case, while we have $\UU_l^m$ for $\UU_l$ in any larger universe $\UU_m$ and consider both the non-cumulative and cumulative cases.

On the semantic side, there is the relatively minor difference between contextual categories and cwfs, where we note that initial cwfs (with extra structure) are contextual \cite{ClairambaultD11,castellan:lambek}. However, a principal difference is that their notion of model (contextual category with extra structure) is not expressed as a gat and hence they do not need to construct a cwf with an {\em internal} cwf (or contextual category) with extra structure.
%To formalize the latter would create an implementation overhead.


%The construction of an initial cwf with extra structure for the small type formers and the tower of universes based on the theory in Bezem et al \cite{BezemCDE22} would be similar to Brunerie and de Boer's \cite{Brunerie:initiality,deBoer:lic} construction of an initial contextual category with extra structure for a slightly different version of Martin-Löf type theory with an external tower of universes. Both theories are more standard version of Martin-Löf type theory with implicit substitutions, except that terms such as applications are decorated with type information. The rules for universes are also different. Brunerie and de Boer just have the rule $\UU_l : \UU_{l+1}$ and only consider the non-cumulative case, while we have $\UU_l^m$ for $\UU_l$ in any larger universe $\UU_m$ and consider both the non-cumulative and cumulative cases.
%Moreover, their universes are \`a la Russell, while we consider both \`a la Tarski and \`a la Russell. Inevitably, there are other differences between the two systems of inference rules but it would lead too far give a complete account. On the semantic side their notion of model is that of a contextual category (with extra structure) while ours is a cwf (with extra structure). These are closely related notions, taking into account that initial cwfs are contextual in the sense that each context has a length \cite{ClairambaultD11,ClairambaultD14}. We finally remark that several equivalences and embeddings between categorical notions of models including cwfs have been implemented in UniMath by Ahrens, Lumsdaine, and Voevodsky \cite{AhrensLV18}.
%

%\paragraph{Our version of Martin-Löf type theory with an external tower of universes.} Like Brunerie and de Boer's version, ours is based on a more standard version of Martin-Löf type theory with implicit substitutions. However, while they consider Russell-style universes we show both Tarski-style and Russell-style ones. Note that the Russell versus Tarski formulations are only different options for the syntactic type theories, but gats are intrinsically Tarski-style since we have an operator $\Ta$ that converts a term to a type.
%
%(* In the middle of revising this section *)
%Let us now consider the type theory with an external tower of universes presented in Bezem et al \cite{BezemCDE22}. First note that building an initial object in $\CwF_\Sigma$ as a cwf with an internal cwf with extra structure would need a more complex construction. aCould we prove that this is an initial cwf with extra structure for the small type formers and a tower of universes? (Note that building an initial object in $\T_\Sigma$ as a cwf with an internal cwf with extra structure would need a more complex construction.)
%

%Let us now compare our construction to Brunerie and de Boer \cite{Brunerie:initiality,deBoer:lic} that Martin-Löf type theory with an external tower of universes is an initial contextual category with appropriate extra structure for the type formers.
%On the syntactic side their version of Martin-Löf type theory is more traditional with implicit substitutions, that is, substitution is not a term constructor, but an operation defined by induction on the structure of terms. Moreover, their rules for universes are not the same as ours. They just have the rule $\UU_l : \UU_{l+1}$ and only consider the non-cumulative case, while we have $\UU_l^m$ for $\UU_l$ in any larger universe $\UU_m$ and consider both the non-cumulative and cumulative cases.
%
%To adapt their construction to yield a model of our gat we would first need to replace their contextual categories by cwfs. We expect that the implementation could be adapted accordingly, since initial cwfs are contextual. (We also remark that several equivalences and embeddings between categorical notions of models including cwfs have been implemented in UniMath by Ahrens, Lumsdaine, and Voevodsky \cite{AhrensLV18}.)
%Moreover, Brunerie and de Boer's rules for universes are not the same as ours. They just have the rule $\UU_l : \UU_{l+1}$ and only consider the non-cumulative case, while we have $\UU_l^m$ for $\UU_l$ in any larger universe $\UU_m$ and consider both the non-cumulative and cumulative cases. We expect that it would be a modest amount of effort to adapt their construction to our universes.
%
%There are also some differences between Brunerie and de Boer's version of Martin-Löf type theory and ours \cite{BezemCDE22} on the syntactic side. Firstly, they work with decorated terms following Streicher \cite{streicher:thesis} and we would need to decorate ours too. Another difference is that they have a Russell-style tower while we have a Tarski-style one. Note that the Russell versus Tarski formulations are only different options for the syntactic type theories, but gats are intrinsically Tarski-style since we have an operator $\Ta$ that converts a term to a type.

%\subsection{Internalization (* Remove? *)}
%One might be tempted to internalize the externally indexed tower of universes by indexing universes by internal natural numbers:
%$$\Gamma : \ctx, l : \tm(\Gamma,\N) \vdash (\UU_l)_\Gamma : \ty(\Gamma)$$
%%However, this would mean that we could build large types such as $\Pi l : \N.\U_l$ and $\Sigma l : \N.\U_l$ which increase the proof theoretic strength of type theory.
%Note that $l$ here depends on variables in the context $\Gamma$.
%A more cautious alternative would be to only
%allow universes indexed by constant internal natural numbers:
%$$ l : \tm(1,\N), \Gamma : \ctx \vdash \UU_l : \ty(\Gamma)$$
%
%Similarly, Agda has a type $\Level$ of universe levels with a level 0 and a next level operation $(-)^+$, but also has an operation $\vee$ on levels. Moreover, levels satisfy the same equality judgments as our theory. Agda has recently included an option {\tt --level-universe} that restricts the use of universe levels in a similar way as in our theory with level judgments.
%
%What is the best argument for not indexing by natural numbers?? Parametricity??

\section{Level-indexed type theory}\label{level-indexed-tt}

\subsection{The ucwf of levels}\label{ucwf-levels}
 As already mentioned in the introduction, in Bezem et al \cite{BezemCDE22} we added special universe level {\em judgments}:
$$
l\ \level
\hspace{5em}
l = l'
$$
to the usual judgment forms of Martin-Löf type theory. Moreover, universe level variables as well as ordinary term variables can be declared in any order a context, but to simplify the correspondence with the gat formalization, we will in the sequel assume that contexts have the form $n, \Gamma$, where $n$ is the number of (de Bruijn) level variables, and $\Gamma$ is an ordinary context that depends on these $n$ level variables.
As in Agda, we have a next level operation $(-)^+$ and an operation $\vee$ for join of levels. However, as in Bezem et al \cite{BezemCDE22}, we have no level 0 for the first universe. It follows that all universes are polymorphic.
Levels form an upper semilattice with respect to $\vee$ and $(-)^+$ is an inflationary operation, see below.

%\footnote{
%We shall now show the gat corresponding to the our theory where we do not have a type of levels but level judgments \cite{BezemCDE22}.
%This gat consists of the following parts:
%\begin{itemize}
%\item the ucwf of levels
%\item the ucwf-indexed cwf with $\Pi$-types and level-indexed universes
%\begin{itemize}
%\item the object part has sort symbols for level-indexed judgments and operator symbols for ...
%\item the arrow part has operator symbols for level-substitutions in all sorts of the cwfs that preserve all the structure.
%\end{itemize}
%\end{itemize}
%}
\paragraph{Sort symbols.} Levels can be organized as a ucwf. We have the following sort symbols:
\begin{eqnarray*}
&\vdash& \lctx\\
m, n : \lctx &\vdash& \lHom(m,n)\\
m : \lctx &\vdash& \ltm(m)
\end{eqnarray*}
standing for level context, level context morphism (substitution), and level term.
Since ucwfs are cwfs with only one type, we do not need a sort symbol for level types.

\paragraph{Operator symbols.} The operator symbols for ucwfs are simplified versions of those for cwfs, where all dependence on types is removed:
%\footnote{We use  $\sigma,\tau$ for level substitutions.}
%\footnote{In other places we use $\lp$ and $\lq$. Same issue with $\cp$ and $\cq$.}
\begin{eqnarray*}
m : \lctx &\vdash& \lid_m : \lhom(m,m)\\
m, n, p : \lctx, \sigma : \lhom(n,p), \tau : \lhom(m,n) &\vdash&
\sigma \circ \tau : \lhom(m,p)\\
%&&\\
m,n: \lctx, \sigma : \lhom(n,m), l :\ltm(m) &\vdash&  l[\sigma] : \ltm(n)\\
%&&\\
&\vdash& 0 : \lctx\\
m : \lctx &\vdash& \tuple{}_m : \lhom(m,0)\\
%&&\\
m : \lctx &\vdash& \s(m) : \lctx\\
m,n : \lctx, \sigma : \lhom(n,m), l:\ltm(n) &\vdash& \tuple{\sigma,l} : \lhom(n,\s(m))\\
m : \lctx &\vdash& \lp_m: \lhom(\s(m),m)\\
m : \lctx &\vdash& \lq_m: \ltm(\s(m))
\end{eqnarray*}
Note that we no longer need an operator symbol for substitution in types but only in level terms. We also change the notation to suggest that these are operations on levels. For example, we use $\sigma$ and $\tau$ to range over level substitutions to distinguish them from term substitutions $\gamma$ and $\delta$. However, we keep the notation $\circ$ for composition of level substitutions, $l[\sigma]$ for level substitution in level terms, $\tuple{}_m$ for the empty level context morphism and $\tuple{\sigma,l}$ for level context morphism extension. The notation for level contexts suggests that we have an initial ucwf where $n : \lctx$ is a natural number that records the number of available level variables. Thus $0 : \lctx$ is the terminal object in the ucwf.

The ucwf of levels also has operator symbols for next level and join of two levels:
\begin{eqnarray*}
m : \lctx, l : \ltm(m) &\vdash& l^+ : \ltm(m)\\
m : \lctx, l,l' : \ltm(m) &\vdash& l \vee l' : \ltm(m)
\end{eqnarray*}
%\end{tiny}

%\begin{tiny}
\paragraph{Equations.}
The ucwf-equations are the cwf-equations (see Dybjer \cite{dybjer:torino} and Bezem et al \cite{BezemCDE22})
%appendix   \ref{sec:gatPiU})
for the special case that there is only one type, so that all type equations are redundant:
\begin{eqnarray*}
\lid_{n} \circ \sigma &=& \sigma \\
 \sigma \circ \lid_{n} &=& \sigma \\
(\sigma \circ \tau) \circ \upsilon &=& \sigma \circ (\tau \circ \upsilon)\\
%&\vdash&
%A[\id_{n}] &=& A \\
%a:\tm_n(\sigma,A) &\vdash&
l[\lid_{n}] &=& l \\
%n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \delta : \sub_n(\Xi,\Delta), \gamma : \sub_n(\Delta,\Gamma),
%&\vdash&
%A[\gamma\circ\delta] &=&A[\gamma][\delta]\\
%: \ty_n(\Xi)\\
%n : \lctx, \Xi,\Delta, : \ctx_n, \delta : \sub_n(\Xi,\Delta), \gamma : \sub_n(\Delta,\Gamma),
%a:\tm_n(\Gamma,A) &\vdash&
l[\sigma\circ\tau] &=& l[\sigma][\tau]\\
%: \tm_n(\Xi,A[\gamma\circ\delta])\\
%n : \lctx &\vdash&
\lid_{0} &=& \tuple{}_{0}\\
 %: \sub_n(1_n,1_n)\\
%\Gamma,\Delta : \ctx_n , \gamma : \sub_n (\Delta,\Gamma) &\vdash&
\tuple{}_{n}\circ\sigma &=& \tuple{}_{m}\\
\lp_n \circ \tuple{\sigma,l} &=& \sigma\\
\lq_n [\tuple{\sigma,l}] &=& l\\
\tuple{\sigma,l} \circ \tau &=& \tuple{\sigma \circ \tau,l[\tau]}\\
\lid_{\s(n)} &=& \tuple{\lp_n,\lq_n}
\end{eqnarray*}
The semi-lattice equations for $l \vee l'$ are:
\begin{eqnarray*}
(l \vee l') \vee l'' &=& l \vee (l' \vee l'')\\
l \vee l' &=& l'\vee l\\
l \vee l &=& l
\end{eqnarray*}
and the equations for the inflationary operator symbol $l^+$ are:
\begin{eqnarray*}
l \vee l^+ &=& l^+\\
(l\vee l')^+ &=& l^+\vee l'^+
\end{eqnarray*}
The operator symbols $\vee$ and $+$ commute with level substitution:
\begin{eqnarray*}
(l \vee l')[\sigma] &=& l[\sigma] \vee l' [\sigma]\\
 l^+[\sigma] &=&  l[\sigma]^+
\end{eqnarray*}
%\end{tiny}
\paragraph{Lawvere theories.} We remark that ucwfs are related to Lawvere theories, but ucwfs are closer to the usual syntax based on $n$-place functions. One can prove that Lawvere theories are equivalent to contextual ucwfs, that is, ucwfs where each context has a length \cite{ClairambaultD11,castellan:lambek}.

\paragraph{Level equality sorts.}
When we encode type theory in gats, the principle is to introduce one sort for each main form of judgment. For example, $l : \ltm(n)$ represents the judgment $n \vdash l\ \level$. Equality judgments are then represented by equalities: $l = l' : \ltm(n)$ represents $n \vdash l = l'$.

However, as we shall see in the next subsection, there are cases where we would like to have equalities in contexts and this is not allowed in gats. This issue can be resolved by introducing a new sort symbol for level equality:
\begin{eqnarray*}
n : \lctx, l, l'  : \ltm(n) &\vdash& \leq_n(l,l')
\end{eqnarray*}
and an operator symbol for reflexivity:
\begin{eqnarray*}
n : \lctx, l : \ltm(n) &\vdash& \refl(l) :  \leq_n(l,l)
\end{eqnarray*}
Note that if $l =  l' : \ltm(n)$ in the initial model, that is, if $l = l'$ can be derived by equational reasoning from the laws for $\vee$ and $(-)^+$, then $\refl(l) :  \leq_n(l,l')$
%\begin{eqnarray*}
%n : \lctx, l, l'  : \ltm(n) &\vdash& l = l' : \ltm(n)
%\end{eqnarray*}
%in the initial model, that is, if $l = l'$ can be derived by equational reasoning from the laws for $\vee$ and $(-)^+$ , then we can also derive
%\begin{eqnarray*}
%n : \lctx, l,l' : \ltm(n) &\vdash& \refl(l) :  \leq_n(l,l')
%\end{eqnarray*}
by preservation of equality, a principle available in all gats. In the opposite direction we have the following:
\begin{proposition*}
If $n : \lctx, l, l' : \ltm(n),$ and $p :  \leq_n(l,l')$ in the initial model,
then $p = \refl(l) : \leq(l,l')$ and $l = l' : \ltm(n)$.
\end{proposition*}

This can be proved by a normal form argument. As remarked by Bezem and Coquand \cite{bezem-coquand:lattices},
each level term has a normal form
$
\alpha_1^{+^{p_1}} \vee \cdots \vee \alpha_m^{+^{p_m}}
$
for $p_i \geq 0$ for $1 \le i \le m \le n$ and level variables (de Bruijn indices) $\alpha_1 < \ldots < \alpha_m$.
We can construct an initial ucwf with $\vee$ and $(-)^+$, where the elements of $\ltm(n)$ are normal forms and $l = l' : \ltm(n)$ iff $l$ and $l'$ are identical normal forms.  If we extend the gat with a new sort $\leq$ and a new operator symbol $\refl$ for reflexivity, we can extend the initial ucwf with sets $\leq_n(l,l')$ that contain a single element $\refl(l)$ iff $l = l' : \ltm(n)$ and is otherwise empty.

\paragraph{Remark on identity types.} The sort symbol $\leq$ for level equality resembles the identity type former $\Id$ in Martin-Löf type theory. We think of $\leq_n(l,l')$ as propositional level equality and its elements $p : \leq_n(l,l')$ as proofs of propositional level equality. However, while proofs $p : \Id_A(a,a')$ can make use of advanced logical reasoning, level equality proofs are limited and, as shown above, can only be obtained by equational reasoning from the laws for $\vee$ and $(-)^+$.

%\footnote{Can we prove the following:
%If we have derivations
%\begin{eqnarray*}
%\vdash n : \lctx, \vdash l,l' : \ltm(n), \vdash p :  \leq_n(l,l')
%\end{eqnarray*}
%then $\vdash p = \refl(l) : \leq(l,l')$ and $\vdash l = l' : \ltm(n)$?
%\MB{Canonicity? Closed level context is natural number. Closed $l:\ltm(n)$ in
%closed context is a lattice term ... $p$ is more difficult.}
%
%PD: Yes, each level term has a normal form
%$
%\alpha_1^{+^{p_1}} \vee \cdots \vee \alpha_m^{+^{p_m}}
%$
%for $p_i \geq 0$ for $1 \le i \le m \le n$ and level variables (de Bruijn indices) $\alpha_1 < \ldots < \alpha_m$. We construct an initial ucwf of levels where the elements of $\ltm(n)$ are such normal forms and $l = l' : \ltm(n)$ iff $l$ and $l'$ are identical.  If we extend the gat with a new sort $\leq$ and a new operator symbol $\refl$ for reflexivity, we can extend the initial model with sets $\leq_n(l,l')$ that contain a single element $\refl(l)$ iff $l = l' : \ltm(n)$ and is otherwise empty.
%}



\todo[inline]{Remark on finitely presented semilattices and constraints?}


\subsection{The level-indexed cwf of small types}\label{lcwf-sort}.

We now define the gat of ucwf-indexed cwfs with extra structure for the small type formers $\Pi,\Sigma,\N_0,\N_1,\N_2,\N,\W,\Id$. This is the theory of presheaves
$$
T : \L^\mathrm{op} \to \CwF^{\Pi,\Sigma,\N_0,\N_1,\N_2,\N,\W,\Id}
$$
valued in the category of cwfs with extra structure for the small type formers and cwf-morphisms preserving cwf-structure and the structure of the small type formers strictly. Thus
\begin{itemize}
\item
$T(n)$ is the cwf (with extra structure) of contexts, substitutions, types, and terms that depend on level variables in $n$.
\item
Let $\sigma : n \to m$ be a level substitution. In the initial model it is an $m$-tuple of level terms in $n$ level variables, and
$T(\sigma) : T(m) \to T(n)$ substitutes the $m$ level variables by the respective $m$ level expressions in $\sigma$ in the various components of the cwf $T(m)$ yielding a cwf depending on $n$ level variables. All structure of the cwf with small type formers is preserved.
\end{itemize}

\paragraph{Sort symbols.} The gat for the level-indexed cwf of small types has the following sort symbols in addition to those of the gat of levels:
\begin{eqnarray*}
n : \lctx &\vdash& \ctx_n\\
n : \lctx, \Delta, \Gamma : \ctx_n &\vdash& \sub_n(\Delta,\Gamma)\\
n : \lctx, \Gamma : \ctx_n &\vdash& \ty_n(\Gamma)\\
n : \lctx, \Gamma : \ctx_n, A:\ty_n(\Gamma) &\vdash& \tm_n(\Gamma,A)
\end{eqnarray*}
These are the same as the sort symbols of the gat of cwfs, except that they are all indexed by an argument $n : \lctx$.

\paragraph{Operator symbols.} Similarly, the operator symbols are the same as for cwfs (with extra structure for the small type formers), except that they are also indexed by $n : \lctx$. The equations are modified accordingly. See the appendix.

The arrow part of the level-indexed cwf of small types axiomatizes level substitution. There is one operator symbol for each component of the level-indexed cwf, but we overload notation:
\begin{eqnarray*}
n, n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'} &\vdash&
\Gamma[\sigma] : \ctx_n\\
n, n' : \lctx , \sigma : \lhom(n,n'), \Delta,\Gamma : \ctx_{n'}, \gamma : \sub_{n'}(\Delta,\Gamma)
&\vdash&
\gamma[\sigma] : \sub_{n}(\Delta[\sigma],\Gamma[\sigma]) \\
n, n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'}, A:\ty_{n'}(\Gamma)
&\vdash&
A[\sigma]: \ty_n(\Gamma[\sigma])\\
n,n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'}, A:\ty_{n'}(\Gamma), a : \tm_{n'}(A,\Gamma)
&\vdash&
a[\sigma] : \tm_{n}(A[\sigma],\Gamma[\sigma])
\end{eqnarray*}
\paragraph{Equations.}
The functor laws give us the following equations:\todo{%
We should give more information here. The $p$ below is unexplained.}
\begin{eqnarray*}
\Gamma[\lid_n] &=& \Gamma\\
\Gamma[\sigma \circ \tau] &=& \Gamma[\sigma][\tau]\\
\gamma[\lid_n] &=& \gamma\\
\gamma[\sigma \circ \tau] &=& \gamma[\sigma][\tau]\\
A[\lid_n] &=& A\\
A[\sigma \circ \tau] &=& A[\sigma][\tau]: \ty_p(\Gamma[\sigma \circ \tau])\\
a[\lid_n] &=& a\\
a[\sigma \circ \tau] &=& a[\sigma][\tau]: \tm_p(A[\sigma \circ \tau],\Gamma[\sigma \circ \tau])
\end{eqnarray*}
Level substitution commutes with small type formers. We show the case for $\Pi$-types:

Let $n, n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'}, A:\ty_{n'}(\Gamma), B:\ty_{n'}(\Gamma.A)$. Then
\begin{eqnarray*}
\Pi(A,B)[\sigma] &=& \Pi(A[\sigma],B[\sigma])
\end{eqnarray*}
Moreover, if $b : \tm_n(\Gamma.A,B), c :  \tm_n(\Gamma,\Pi(A,B))$,  and $a : \tm_n(\Gamma,A)$, we have
\begin{eqnarray*}
\lambda(b)[\sigma] &=&\lambda(b[\sigma])\\
\app(c,a)[\sigma] &=&\app(c[\sigma],a[\sigma])
\end{eqnarray*}
%This finishes the gat for level-indexed cwfs with small type formers.

\subsection{Level-indexed universes}
\paragraph{Operator symbols and a new sort symbol for level equality.}
We finally add the operator symbols and equations for level-indexed universes.
Each $T(n)$ has extra structure for level-indexed universes $\UU_l$ with decodings $\Ta_l$, where $l$ is a level term that depends on level variables in $n$. These universes are closed under the small type formers and contain smaller universes $\UU_{l'}$ for $l' < l$.

The operator symbols are obtained by internalizating the corresponding rules for the externally indexed universes. As before, we only show closure under $\Pi$. \todo{PD: Should we factor out common premises $n : \lctx, l : \ltm(n), \Gamma : \ctx_n$?}
\begin{eqnarray*}
n : \lctx, l : \ltm(n), \Gamma : \ctx_n &\vdash& (\U_{l})_\Gamma : \ty_n(\Gamma)\\
n : \lctx, l : \ltm(n), \Gamma : \ctx_n, a : \tm_n(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta_{l}}(a) : \ty_n(\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,(\U_0)_\Gamma) \\
n : \lctx, l, l' : \ltm(n), \Gamma : \ctx_n,
a : \tm_n(\Gamma,(\U_{l})_\Gamma),
b :  \tm_n(\Gamma \cdot \Ta_{l}(a), (\U_{l'})_\Gamma)
&\vdash&
 \Pihat^{l,l'}(a,b) : \tm_n(\Gamma,(\U_{l \vee l'})_\Gamma)
\end{eqnarray*}
However, when we try to internalize the operator symbols $\UU^m_l$ for universes $\UU^l$ in larger universes $\UU^m$, where $l < m$, we encounter a problem. The following attempt
\begin{eqnarray*}
n : \lctx, l, m : \ltm(n), l < m, \Gamma : \ctx_n&\vdash&(\UU^m_l)_\Gamma: \tm_n(\Gamma,(\UU_{m})_\Gamma)
\end{eqnarray*}
where $l < m$ is defined as $l^+ \vee m = m$, does not work since equations are not allowed in argument types in gats.
However, this issue can be resolved by instead using equality sorts as introduced above in Section
\ref{ucwf-levels} and redefine $l < m$ as $\leq_n(l^+ \vee m, m)$. This yields the following proper typing of the operator symbol $\UU^m_l$:
\begin{eqnarray*}
n : \lctx, l, m : \ltm(n), p : l < m, \Gamma : \ctx_n&\vdash&(\UU^m_l)_{p,\Gamma} : \tm_n(\Gamma,(\UU_{m})_\Gamma)
\end{eqnarray*}
In the sequel we will suppress the proof $p : l < m$ as an argument to this operator symbol and just write $(\UU^m_l)_{\Gamma}$.

\paragraph{Equations.}
The decoding equations for $\Ta_l$ and the equations for commutativity of operator symbols with substitution can be obtained by a straightforward internalization of the corresponding equations for the external tower. This means that the decoding equations are now relative to internal level contexts and level terms, as well as to terms. For example the decoding equation for $\Pi$
\begin{eqnarray*}
\Ta_{l \vee l'}(\Pi^{l,l'}(a,b)) = \Pi(\Ta_l(a),\Ta_{l'}(b)) :\tm_n(\Gamma,\UU_{l \vee l'})
\end{eqnarray*}
is now relative to the context
$$
n : \lctx, l, l' : \ltm(n), \Gamma : \ctx_n, a : \tm_n(\Gamma,\UU_l), b : \tm_n(\Gamma.\Ta_l(a),\UU_{l'} )
$$
and the decoding equation for the $l$th universe in the $m$th
\begin{eqnarray*}
\Ta_{m}((\UU^m_l)_\Gamma) &=& (\UU_l)_\Gamma
\end{eqnarray*}
is now relative to the context
$$
n : \lctx, l, m : \ltm(n), p : l < m
$$
where again $l < m$ is defined as $\leq_n(l^+ \vee m, m)$.

Equations for commutativity of operator symbols wrt substitution:
\begin{eqnarray*}
\Ta^m_l(a) [ \gamma ] &=& \Ta^m_l(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^{l}(a,b)[ \gamma ] &=& \Pi^{l}(a [ \gamma ], b[ \gamma^\dagger ])
\end{eqnarray*}
 where $\gamma : \sub(\Delta,\Gamma)$.

We also have equations for commutativity of lifting and $\Pi$-codes with respect to term substitution $\gamma$:
 \begin{eqnarray*}
(\U_l)_\Gamma [ \gamma ] &=& (\U_l)_\Delta\\
\Ta_l(a) [ \gamma ] &=& \Ta_l(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^{l,l'}(a,b)[ \gamma ] &=& \Pi^{l,l'}(a [ \gamma ], b[ \gamma^\dagger ])\\
(\UU^l)_\Gamma[ \gamma ] &=&(\UU^l)_\Delta
\end{eqnarray*}
Moreover, we have laws that level substitution $\sigma$ commutes with the operator symbols for a universe.
 \begin{eqnarray*}
 (\U_{l})_\Gamma[\sigma] &=& (\U_{l[\sigma]})_{\Gamma[\sigma]}\\
 \Ta_l(a) [ \sigma ] &=& \Ta_{l[\sigma]}(a[ \sigma ] )\\
\Pi^{l,l'}(a,b)[ \sigma ] &=& \Pi^{l[ \sigma ] ,l'[ \sigma ] }(a [ \sigma ], b[ \sigma])\\
(\UU^l)_\Gamma[ \sigma ] &=&(\UU^{l[ \sigma ]} )_{\Delta[ \sigma ]}
 \end{eqnarray*}


\subsection{Cumulativity}
\paragraph{Operator symbol.}
An operator symbol for cumulativity is obtained by internalizing the operator symbols for cumulativity in the external tower:
\begin{eqnarray*}
n : \lctx, l,m : \ltm(n), p : l < m, \Gamma : \ctx_n, a : \tm_n(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta^m_{l}}(a) : \tm_n(\Gamma,(\U_{m})_\Gamma))
\end{eqnarray*}
where again $l < m$ is defined as $\leq_n(l^+ \vee m, m)$. However, unlike for the external tower of universes, we need double superscripts on codes $\Pi^{l,l'}$ also in the cumulative case.
%This is because, unlike in the external case, we to the greater in general.

\paragraph{Equations.}
We have the following decoding equation for lifting of codes for $\Pi$:
\begin{eqnarray*}
\Ta^{m \vee m'}_{l \vee l'}(\Pi^{l,l'}(a,b)) = \Pi^{m,m'}(\Ta^m_l(a),\Ta^{m'}_{l'}(b)) &:& \tm_n(\Gamma,(\UU_{l \vee l'})_\Gamma)
\end{eqnarray*}
where $n: \lctx,l',m,m' : \ltm(n), p: l < m, p': l' < m', \Gamma : \ctx_n, a : \tm_n(\Gamma,(\UU_l)_\Gamma), b : \tm_n(\Gamma.\Ta_l(a),(\UU_{l'})_\Gamma)$.
The decoding equation for lifting of codes for universes is as follows:
\begin{eqnarray*}
n : \lctx, k, l, m : \ltm(n), p : k < l, q : l < m, \Gamma : \ctx(n) &\vdash& \Ta^m_l((\UU^l_k)_\Gamma) = (\UU^m_k)_\Gamma
\end{eqnarray*}
Equations for commutativity of lifting and term substitution ($\gamma : \sub(\Delta,\Gamma)$):
\begin{eqnarray*}
\Ta^m_l(a) [ \gamma ] &=& \Ta^m_l(a[ \gamma ] )
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
%\Pi^{l}(a,b)[ \gamma ] &=& \Pi^{l}(a [ \gamma ], b[ \gamma^\dagger ])
\end{eqnarray*}
and level substitution ($\sigma : \lhom(n,n')$)
\begin{eqnarray*}
\Ta^m_l(a) [ \sigma ] &=& \Ta^m_{l[\sigma]}(a[ \sigma ] )
\end{eqnarray*}
%Check that this is right. Cf comment by intern.

\subsection{Level-indexed products of types}
%We add three operator symbols in addition to the operator symbols for cwfs in Section 5.2 and 5.3:
\def\l{\mathrm{l}}
%\begin{tiny}
In Bezem et al \cite{BezemCDE22} we also introduced
universal level quantification $[\alpha]A$ with level abstraction $\tuple{\alpha}a$ and application $a\,l$ of a term to a level. The corresponding operator symbols are $\forall_\l, \lambda_\l,$ and $\app_\l$:
\begin{eqnarray*}
n : \lctx, \Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp])&\vdash& \forall_\l(B) : \ty_n(\Gamma)\\
n : \lctx, \Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp]), b : \tm_{\s(n)}(\Gamma[\lp], B) &\vdash& \lambda_\l(b) : \tm_n(\Gamma,\forall_\l(B))\\
n : \lctx, \Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp]), c :  \tm_n(\Gamma,\forall_\l(B)), l : \ltm(n) &\vdash& \app_\l(c,l) : \tm_n(\Gamma, B[\tuple{\lid,l}])
\end{eqnarray*}
Equations ($\beta$ and $\eta$ for level abstraction and application):
 \begin{eqnarray*}
 \app_\l(\lambda_\l(b),l) &=& b[\tuple{\lid,l}]\\
 \lambda_\l(\app_\l(c[\lp],\lq)) &=& c
 \end{eqnarray*}
 Equations for commutativity of operator symbols with respect to term and level substitution:
 \begin{eqnarray*}
 \forall_\l(B)[ \gamma ] &=& \forall_\l(B[ \gamma[\lp]])\\
 \lambda_\l(B)[ \gamma ] &=& \lambda_\l(B[ \gamma[\lp]])\\
 \app_\l(c,l)[ \gamma ] &=& \app_\l(c[ \gamma ] ,l[ \gamma ] )\\
 \forall_\l(B)[ \sigma ] &=& \forall_\l(B[ \sigma^{\dagger}])\\
 \lambda_\l(B)[ \sigma ] &=& \lambda_\l(B[ \sigma^{\dagger}])\\
\app_\l(c,l)[ \sigma ] &=& \app_\l(c[ \sigma ] ,l[ \sigma ] )
\end{eqnarray*}
where $\gamma : \sub_n(\Delta,\Gamma)$ is a term substitution, and $\sigma : \lhom(m,n)$ is a level substitutuion with $\sigma^\dagger = \tuple{\sigma \circ \lp, \lq}$.
To check the type of the equation
$$ \forall_\l(B)[ \sigma ] = \forall_\l(B[ \sigma^{\dagger}])$$ we assume $\Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp])$. It follows that $B[\sigma^\dagger] : \ty_{s(m)}(\Gamma[\lp][\sigma^\dagger]) = \ty_{s(m)}(\Gamma[\sigma][\lp])$. Hence
$\forall_\l(B[ \sigma^{\dagger}]) : \ty_m(\Gamma[\sigma])$.

\paragraph{Remark on universal quantification in predicate logic.}

In the introduction we mentioned that untyped predicate logic can be captured by ucwf-indexed scwfs. (This gives a proof-relevant notion of model, like Lawvere's hyperdoctrines \cite{lawvere:hyperdoctrines}.) We note that the operator symbols and equations for universal quantification in untyped predicate logic are the same as those for universal level quantification above, except the difference between scwfs and cwfs: propositions in predicate logic do not depend on proofs.

\subsection{Syntax and inference rules as an initial model}\label{initiality-internal}

\paragraph{A generic construction based on explicit substitutions.} The gat $\Sigmaint$ for cwfs with level-indexed universes and level-indexed products is finitary. Hence we can directly instantiate the construction of the term model $\T_{\Sigmaint}$ \cite{bezem:hofmann} and the proof that it is initial in $\CwF_{\Sigmaint}$.

\paragraph{A construction based on implicit substitutions (initiality conjecture).} We shall outline how to construct an initial object in $\CwF_{\Sigmaint}$ based on $\TTint$, the decorated version of our type theory with explicit universe polymorphism \cite{BezemCDE22}. In this theory level variables and ordinary term variables can appear in any order. As already mentioned we consider, without loss of generality, a version of $\TTint$ where level variables precede ordinary term variables (both using de Bruijn indices). In this theory every context has the form $n,\Gamma$, where $n$ is the number of available level variables, and $\Gamma$ is a context of term variables that may depend on those $n$ level variables. We then need to show (i) how to organize the level terms and level judgments into an internal ucwf of levels; (ii) how to construct an internal level-indexed cwf of small types by modifying the construction of an internal cwf of small types; and (iii) how to construct a model of the level-indexed universes by modifying the construction of a model of the externally indexed universes based on $\TText$.

We first explain how to construct a ucwf of levels by referring to Brilakis'  \cite{Brilakis18} construction in Agda of the equivalence between two initial ucwfs: one with explicit substitutions and one with implicit substitution and de Bruijn variables. Since the ucwf with explicit substitutions is constructed directly from the operator symbols of ucwfs, Brilakis' proof is essentially the same as proving the initiality of the ucwf with implicit substutions. To prove the initiality of the ucwf of levels, we only need to extend Brilakis' proof with the extra structure for $\vee$ and $(-)^+$.  (We then need to do the same construction internally to cwfs.)

\begin{itemize}
\item An element $n \in \Tm(1,\lctx)$ is a natural number (the number of available level variables). What is $n \in \Tm(\Delta,\lctx)$? What is it in the explicit substitution model? There you can for example assume $x : \lctx \vdash x : \lctx$ (officially we have projections instead of named variables in that model). You also have e g $x : \lctx \vdash \s(x) : \lctx$ in the inference system. Officially $1.\lctx \vdash \s : \lctx$ (This is the typing of $\s$.)
Does it suffice to extend the inference system with extra gat-meta-contexts? We can also mimick the construction of the explicit substitution model.
\item An element of $\Tm(1,\ltm(n))$ is an equivalence class of level terms generated by $\vee$ and $(-)^+$ from $n$ level variables with respect to the equivalence relation generated by the equations for $\vee$ and $(-)^+$. In our type theory with explicit substitution \cite{BezemCDE22} this corresponds to the level terms $l$ such that
$$
n \vdash l\ \level
$$
where $\Gamma$ contains $n$ level variables and two terms $l, l' : \ltm(n)$ are equivalent provided
$$
n \vdash l = l'
$$
\item An element of $\Tm(1,\lhom(m,n)$ is ...
\item We refer to Brilakis for the definition of the ucwf-operations. Note that level substitution $l[\sigma]$ is an implicit operation defined by induction on $l$. The definition of $\vee$ and $(-)^+$ on equivalence classes of levels is immediate.
% If $n = (\alpha_n, \ldots, \alpha_1)$ and $\s(n) =  (\alpha_n, \ldots, \alpha_1, \alpha_0)$ are lists of distinct level variables, then $\lp_n = (\alpha_n, \ldots, \alpha_1) : \lhom(\s(n),n)$ and $\lq_n = \alpha_0 : \ltm(\s(n))$ are the projections.
\end{itemize}

The next step is to construct the sort symbols, operator symbols, and equations for cwfs indexed by $n : \lctx$. The sort symbols are defined as follows.
\begin{itemize}
\item $\Tm(1.\ty_n(\Gamma))$ is the set of equivalence classes of raw types $A$ such that $n, \Gamma \vdash A$ is a type and $A.A'$ are equivalent provided $n, \Gamma \vdash A = A'$.
\item $\Tm(1,\tm_n(\Gamma,A))$ is the set of equivalence classes of raw terms $a$ such that $n, \Gamma \vdash a : A$ and $a.a'$ are equivalent provided $n, \Gamma \vdash A = A'$.
\item $\Tm(1,\ctx_n)$ is the set of equivalence classes of raw contexts $\Gamma$ such that $n, \Gamma \vdash$ under the equivalence relation $n, \Gamma = \Gamma' \vdash$.
%(Context equality judgments are not explicitly listed in Bezem et al \cite{BezemCDE22}.)
\item $\Tm(1,\sub_n(\Delta,\Gamma))$ is the set of equivalence classes of raw context morphisms.
\item The level equality sort $\Tm(1,\leq_n(l,l'))$ is a one element set iff $l = l' : \ltm(n)$.
\end{itemize}
We then define all the operator symbols in this structure and check the equations. We omit the details which are similar to the construction of a model based on $\TText$.

The final part of the construction is to interpret the operator symbols for level substitution and composition (in levels, level morphisms, contexts, context morphisms, types and terms) that correspond to the arrow part of the level-indexed cwf with extra structure. These are all defined implicitly by induction on the raw syntax.

This concludes the construction of an object of $\CwF_\Sigmaint$. Finally, we need to construct a morphism to any other object in $\CwF_\Sigmaint$ and prove that this is unique.

%In our old paper have the following introduction rule for cumulative universes with its decoding equation:
%$$
%\frac{l < m}
%{\UU^m_l : \UU_m\hspace{3em}\Ta_m(\UU^m_l) = \UU_l}
%$$
%where the context $\Gamma$ is implicit.

%\footnote{If  $n$ is the length of the level context, then level expressions have normal forms
%$$
%\alpha_1^{+^{p_1}} \vee \cdots \vee \alpha_m^{+^{p_m}}
%$$
%for $p_i \geq 0$ for $1 \le i \le m \le n$ . We have
%$$
%\alpha_1^{+^{p_1}} \vee \cdots \vee \alpha_m^{+^{p_m}}
%<
%\alpha_1^{+^{q_1}} \vee \cdots \vee \alpha_m^{+^{q_m}} \vee \alpha_{m+1}^{+^{q_{m+1}}} \vee \cdots \vee \alpha_{m'}  ^{+^{q_{m'}}}
%$$
%provided $p_i < q_i$ for $1 \le i \le m \le m' \le n$.}


\section{Conclusion}

We presented an infinitary gat $\Sigmaext$ for Martin-Löf type theory with an external tower of universes and a finitary gat $\Sigmaint$ for Martin-Löf type theory with internally level-indexed universes and level-indexed products. We have also explained that the models $\T_{\Sigmaext}$ and $\T_{\Sigmaint}$ are instances of general constructions of initial models of gats in
Bezem et al \cite{bezem:hofmann}.

(* Remove?
We contrast this to the construction of initial objects in categories of cwfs with extra structure for the small type formers and and an external tower of universes $\CwF^\mathrm{ext}$ and $\CwF^\mathrm{up}$ for level-indexed universes. %(This would be analogous to Brunerie's and de Boer's setting.)
The price we pay for working on top of the framework of gats, is that we need two levels of cwfs in $\CwF_{\Sigmaext}$ and  $\CwF_{\Sigmaint}$: the ``metalevel'' cwf needed for modelling the basic dependent type theory underlying gats,
and the ``object level" internal cwfs (and ucwf-indexed cwfs) needed for modelling our type theories. *)

\footnote{PD: Is it feasible to have a generic construction of initial models with implicit substitutions for some class of gats? We note that in cwfs (and scwfs, ucwfs, and indexed cwfs) substitution is modelled by the arrow part of a functor. Under certain conditions we can define the corresponding substitution combinators in the term model by induction. This relies on identifying variables (projections) as a special subclass of the terms in a cwf (and the like). It seems that in this way we get a uniform way of constructing term models for various type theories and predicate logics which are close to the standard presentations.}

%We have shown how to capture Martin-Löf type theory with explicit universe polymorphism as a gat. The list of sort symbols, operator symbols, and equations may seem long but not as long as the list of inference rules rules for the syntactic theory. (In the versions with implicit substitutions we should include the substitution lemmas.) Moreover, the gat formalizes the high-level structure of ucwf-indexed cwfs with extra structure: the $\vee$-semilattice with an inflationary operation $(-)^+$, and adjoint-like structures for $\Pi$-types and other type formers. Also context comprehension in cwfs is an adjoint-like structure. The relationship with adjoints in the sense of ordinary cartesian closed categories is worked out in the case of contextual cwfs with extensional equality types, $\Sigma$-types and $\Pi$-types by Clairambault and Dybjer \cite{ClairambaultD11,ClairambaultD14} and for some other structures in Castellan et al \cite{castellan:lambek}.
%
%A key novelty is the need for level equality sorts $\leq_n(l,l')$. The main recipe for a gat corresponding to Martin-Löf type theory is that equality judgments are formalized as judgmental equalities in gats. For example, the judgment
%$$
%\Gamma \vdash A
%$$
%expressing that $A$ is a well-formed type in the context $\Gamma$, corresponds to elements
%$$
%A : \ty(\Gamma)
%$$
%in the gat, but
%$$
%\Gamma \vdash A = A'
%$$
%corresponds to an equality
%$$
%A = A' : \ty(\Gamma)
%$$
%Hence, we do not need a new sort symbol corresponding to type equality judgments. However, this principle breaks down when formalizing the principle that any universe has a code in any larger universe. This is because $l < l'$ is defined as the level equality $l^+ \vee l' = l'$ and level equalities are not allowed in contexts in gats. To resolve this issue we add a sort $\leq_n(l,l')$ for level equality.

A key ingredient in the gat $\Sigmaint$ is the sort symbol for level equality $\leq$. In a forthcoming article we plan to show how level equality sorts can be employed for representing equational constraints. This will enable us to extend $\Sigmaint$ with new sort symbols and equations for the extension of $\TTint$ with equational constraints presented in Section 5 in Bezem et al \cite{BezemCDE22}.

%While we have a generic construction of initial gats as a term model for an explicit substitution calculi, we are still relying on ad hoc proofs for the more standard implicit substitution calculi. However, also the latter seem to arise systematically from gats of cwfs. It seems that we can define variables as projections $\q[\p^n]$ in and implicit substitutions (arising from the arrow part of the family valued functor for example) can be defined by induction on the structure of types and terms. \footnote{Related work in this direction has been done by Fiore and coworkers.}
%
%It would also be interesting to develop other examples of gats for various logical systems. We already of mentioned in the introduction that untyped predicate logic is captured by ucwf-indexed scwfs, typed predicate logic by scwf-indexed scwfs, and dependently typed predicate logic by cwf-indexed scwfs (all with extra structure). Palmgren has already analyzed dependently typed predicate logic as hyperdoctrines above cwfs \cite{Palmgren19}. In the quest for uniform categorical logic it would be interesting to recast this work in terms of cwf-indexed scwfs.
%


\paragraph{Related research.}
Other approaches to defining a general notion of dependent type theory inspired by Voevodsky's initiality conjecture project have been proposed by Bauer, Haselwarter, and Lumsdaine \cite{BauerHL20} and Uemura \cite{Uemura23}.

Another related idea is that of representing logics in a {Logical Framework}, such as Edinburgh LF \cite{harper-honsell-plotkin} or Dedukti \cite{dowek-dedukti}. These are based on dependent type theories with $\Pi$-types and one or more universes. The aim is to encode other logics by adding constants and equations to the logical framework. We contrast this to gats which are based on dependent types {\em without} $\Pi$-types and universes. Logics are then encoded by adding sort symbols, operator symbols, and equations to the basic theory of dependent types.

Related to gats are the quotient inductive-inductive types (qiits) of Kaposi, Kov{\'{a}}cs, and Altenkirch
\cite{kaposi:qiits,kovacs:phd}. Although formal details may differ, qiits are roughly initial gats considered as data types in dependent type theory. Sort symbols correspond to data type constructors; operator symbols correspond to term constructors; and equations between terms can be declared. Since a qiit is inductively generated, it has an elimination principle. It is an addition to the sequence of inductive notions in dependent type theory: inductive type, inductive family, inductive-recursive type, inductive-inductive type, quotient inductive-inductive type; and in homotopy type theory also higher inductive type.

%and $\gamma^\dagger = \tuple{\gamma \circ \p, \q}$??
%\end{tiny}
%\footnote{Discussion with Raphael Sterback:
%$$
%\forall_l (B)[\gamma] = \forall_l (B[\gamma[\lp]])
%$$}

\bibliographystyle{plain}
\bibliography{../refs}
\appendix
\section{Operator symbols and equations for level-indexed cwfs of small types}

We already listed the sort symbols in \ref{lcwf-sort}

\paragraph{Operator symbols.} \footnote{Check whether implicit arguments are systematic.}
%We have the following sort symbols:
%\begin{eqnarray*}
%n : \lctx &\vdash& \ctx_n\\
%n : \lctx, \Delta, \Gamma : \ctx_n &\vdash& \sub_n(\Delta,\Gamma)\\
%\end{eqnarray*}
\begin{eqnarray*}
n : \lctx, \Gamma : \ctx_n &\vdash& \id_{n,\Gamma} : \sub_n(\Gamma,\Gamma)\\
n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \gamma : \sub_n(\Delta,\Gamma), \delta : \sub_n(\Xi,\Delta) &\vdash&
\gamma \circ \delta : \sub_n(\Xi,\Gamma)\\
n : \lctx, \Gamma,\Delta : \ctx_n, A:\ty_n(\Gamma), \gamma : \sub_n(\Delta,\Gamma) &\vdash&
A[\gamma] : \ty_n(\Delta)\\
n : \lctx, \Gamma,\Delta : \ctx_n, A:\ty_n(\Gamma), \gamma : \sub_n(\Delta,\Gamma), a:\tm_n(\Gamma,A) &\vdash&  a[\gamma] : \tm_n(\Delta,A[\gamma])\\
n : \lctx &\vdash& 1_n : \ctx_n\\
n : \lctx, \Gamma : \ctx_n &\vdash& \tuple{}_{n,\Gamma} : \sub_n(\Gamma,1_n)\\
n : \lctx, \Gamma : \ctx_n, A:\ty_n (\Gamma) &\vdash& \Gamma \cext A : \ctx_n \\
n : \lctx, \Gamma,\Delta : \ctx_n , A:\ty_n (\Gamma), \gamma : \sub_n (\Delta,\Gamma), a:\tm_n (\Delta,A[\gamma]) &\vdash& \tuple{\gamma,a} : \sub_n (\Delta,\Gamma\cext A)\\
n : \lctx, \Gamma : \ctx_n , A:\ty_n (\Gamma) &\vdash& \p_{n,\Gamma,A}: \sub_n (\Gamma\cext A,\Gamma)\\
n : \lctx, \Gamma : \ctx_n , A:\ty_n (\Gamma) &\vdash& \q_{n,\Gamma,A}: \tm_n (\Gamma\cext A,A[\p])
\end{eqnarray*}
Operator symbols for level-indexed $\Pi$-types (should we decorate $\lambda$ and $\app$ with type information?):
\begin{eqnarray*}
n : \lctx, \Gamma : \ctx_n, A : \ty_n(\Gamma), B : \ty_n(\Gamma.A)&\vdash& \Pi(A,B) : \ty_n(\Gamma)\\
n : \lctx, \Gamma : \ctx_n, A : \ty_n(\Gamma), B : \ty_n(\Gamma.A), b : \tm_n(\Gamma.A, B) &\vdash& \lambda(b) : \tm_n(\Gamma,\Pi(A,B))\\
n : \lctx, \Gamma : \ctx_n, A : \ty_n(\Gamma), B : \ty_n(\Gamma.A), c :  \tm_n(\Gamma,\Pi(A,B)), a : \tm_n(\Gamma, A) &\vdash& \app(c,a) : \tm_n(\Gamma, B[\tuple{\id,a}])
\end{eqnarray*}

\paragraph{Equations.}
\begin{eqnarray*}
\id_{n,\Gamma} \circ \gamma &=& \gamma \\
 \gamma \circ \id_{n,\Delta} &=& \gamma \\
(\gamma \circ \delta) \circ \xi &=& \gamma \circ (\delta \circ \xi)\\
%&\vdash&
A[\id_{n,\Gamma}] &=& A
%: \ty_n(\Gamma)
\\
%a:\tm_n(\Gamma,A) &\vdash&
a[\id_{n,\Gamma}] &=& a% : \tm_n(\Gamma,A)
\\
%n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \delta : \sub_n(\Xi,\Delta), \gamma : \sub_n(\Delta,\Gamma),
%&\vdash&
A[\gamma\circ\delta] &=& A[\gamma][\delta]
%: \ty_n(\Xi)
\\
%n : \lctx, \Xi,\Delta, : \ctx_n, \delta : \sub_n(\Xi,\Delta), \gamma : \sub_n(\Delta,\Gamma),
%a:\tm_n(\Gamma,A) &\vdash&
a[\gamma\circ\delta] &=& a[\gamma][\delta]
%: \tm_n(\Xi,A[\gamma\circ\delta])
\\
%n : \lctx &\vdash&
\id_{n,1_n} &=& \tuple{}_{n,1_n}
%: \sub_n(1_n,1_n)
\\
%\Gamma,\Delta : \ctx_n , \gamma : \sub_n (\Delta,\Gamma) &\vdash&
\tuple{}_{n,\Gamma}\circ\gamma &=& \tuple{}_{n,\Delta}% : \sub_n (\Delta,1_n )
\\
%\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \sub(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash&
\p_{n,\Gamma,A}\circ\tuple{\gamma,a} &=& \gamma : \sub(\Delta,\Gamma)\\
%\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \sub(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash&
\q_{n,\Gamma,A}[\tuple{\gamma,a}] &=& a : \tm(\Delta,A[\gamma]) \\
%\Gamma,\Delta,\Xi : \ctx, A:\ty(\Gamma), \gamma : \sub(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]), \delta : \sub(\Xi,\Delta) &\vdash&
\tuple{\gamma,a} \circ \delta &=& \tuple{\gamma\circ\delta,a[\delta]} \\
%:
%\sub(\Xi,\Gamma\cext A) \\
%\Gamma : \ctx, A:\ty(\Gamma) &\vdash&
\id_{n,\Gamma\cext A} &=& \tuple{\p_{n,\Gamma,A},\q_{n,\Gamma,A}} : \sub(\Gamma\cext A,\Gamma\cext A)
\end{eqnarray*}
\todo{MB, check. Perhaps better to describe how to modify \ref{sec:gatPiU}:
prefix every rule with $n:\lctx$ and add index $n$ to every occurrence
of $\ctx,\ty,\tm$.}
Equations (omitting the context and type of the equalities):
 \begin{eqnarray*}
 \app(\lambda(b),a) &=& b[\tuple{\id,a}]\\
 \lambda(\app(c[\p],\q)) &=& c
 \end{eqnarray*}
 Equations for commutativity of operator symbols wrt substitution:
 \begin{eqnarray*}
\Pi(A,B)[ \gamma ] &=& \Pi(A [ \gamma ], B[ \gamma^\dagger ])\\
\lambda(b) [ \gamma ] &=& \lambda(b[\gamma^\dagger ])\\
\app(c,a) [ \gamma ] &=& \app(c[ \gamma ], a[ \gamma ] )
\end{eqnarray*}
where $\gamma^\dagger = \tuple{\gamma \circ \p, \q}$.

%We also need to add rules for level-indexed $\Pi$

%\begin{itemize}
%\item
%Object part of the functor $\L \to \CwF^{\Pi,\UU_l}$
%\begin{itemize}
%\item Level-indexed contexts and context-morphisms
%\item Level-indexed types and terms
%\end{itemize}
%\item
%Arrow part of the functor $\L \to \CwF^{\Pi,\UU_l}$
%\begin{itemize}
%\item Level-substitution in contexts and context-morphisms
%\item Level-substitution in types and terms
%\end{itemize}
%\end{itemize}






\end{document}
