\documentclass[11pt,a4paper]{article}
%\ifx\pdfpageheight\undefined\PassOptionsToPackage{dvips}{graphicx}\else%
%\PassOptionsToPackage{pdftex}{graphicx}
\PassOptionsToPackage{pdftex}{color}
%\fi

%\usepackage{diagrams}

%\usepackage[all]{xy}
\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage{latexsym}
\usepackage{amssymb,amstext,amsmath,amsthm}
\usepackage{epsf}
\usepackage{epsfig}
\usepackage{float}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage{proof}
\usepackage{latexsym}
%\usepackage{mytheorems}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}{Lemma}[theorem]
\newtheorem{proposition}{Proposition}[theorem]
\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{remark}{Remark}[theorem]
\newtheorem{TODO}{TODO}[theorem]
\newtheorem{remark}{Remark}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{conjecture}{Conjecture}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}


%%%%%%%%%copied from SymmetryBook by Marc

% hyperref should be the package loaded last
\usepackage[backref=page,
            colorlinks,
            citecolor=linkcolor,
            linkcolor=linkcolor,
            urlcolor=linkcolor,
            unicode,
            pdfauthor={BCDE},
            pdftitle={Universes},
            pdfsubject={Mathematics},
            pdfkeywords={type theory, universes}]{hyperref}
% - except for cleveref!
\usepackage[capitalize,noabbrev]{cleveref}
%\usepackage{xifthen}
\usepackage{xcolor}
\definecolor{linkcolor}{rgb}{0,0,0.5}

%%%%%%%%%
\def\oge{\leavevmode\raise
.3ex\hbox{$\scriptscriptstyle\langle\!\langle\,$}}
\def\feg{\leavevmode\raise
.3ex\hbox{$\scriptscriptstyle\,\rangle\!\rangle$}}

%%%%%%%%%

\newcommand{\mkbox}[1]{\ensuremath{#1}}
\newcommand{\eraser}[1]{}

\newcommand{\conv}{=}
%\newcommand{\conv}{\mathsf{conv}}

\newcommand{\Id}{\mathsf{Id}}
\newcommand{\Eq}{\mathsf{Eq}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\NN}{\mathsf{N}}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\UU}{\mathsf{U}}
\newcommand{\JJ}{\mathsf{J}}
\newcommand{\AgdaLevel}{\mathsf{Level}}
\newcommand{\Level}{\mathsf{level}}
\newcommand{\Lev}{{\mathbb{L}}}
%\newcommand{\Type{\hbox{\sf Type}}
\newcommand{\ZERO}{\mathsf{0}}
\newcommand{\SUCC}{\mathsf{S}}
\newcommand{\valid}{\mathsf{valid}}
\newcommand{\level}{\mathsf{level}}
%\newcommand{\type}{\mathsf{type}}
\newcommand{\const}{\mathsf{const}}
\newcommand{\lam}[1]{{\langle}#1{\rangle}}
\newcommand{\mylam}[3]{\lambda_{#1:#2}#3}
\newcommand{\mypi}[3]{\Pi_{#1:#2}#3}
\newcommand{\Upi}[3]{\Pi^{#1}\,#2\,#3}
\newcommand{\mysig}[3]{\Sigma_{#1:#2}#3}
\newcommand{\Usig}[3]{\Sigma^{#1}\,#2\,#3}
\newcommand{\app}[2]{{#1\,#2}} % many applications still hard-coded with ~
\newcommand{\Sapp}[1]{\sapp{\SUCC}{#1}}
\newcommand{\sapp}[2]{{#1(#2)}} % strict app for Id, refl, J, natrec, not S (!)
\newcommand{\Idapp}[3]{\sapp{\Id}{#1,#2,#3}}
\newcommand{\Idnapp}[4]{\sapp{\Id^#4}{#1,#2,#3}}
\newcommand{\NRapp}[4]{\sapp{\RR}{#1,#2,#3,#4}}
\newcommand{\Rfapp}[2]{\sapp{\refl}{#1,#2}}
\newcommand{\Japp}[6]{\sapp{\JJ}{#1,#2,#3,#4,#5,#6}}
\newcommand{\RR}{\mathsf{R}}
%\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Group}{\mathsf{Group}}
%\newcommand{\El}{\mathsf{El}}
%\newcommand{\T}{\mathsf{T}}
%\newcommand{\Usuper}{\UU_{\mathrm{super}}}
%\newcommand{\Tsuper}{\T_{\mathrm{super}}}
%\newcommand{\idtoeq}{\mathsf{idtoeq}}
%\newcommand{\isEquiv}{\mathsf{isEquiv}}
%\newcommand{\Equiv}{\mathsf{Equiv}}
\newcommand{\isContr}{\mathsf{isContr}}
%\newcommand{\ua}{\mathsf{ua}}
%\newcommand{\UA}{\mathsf{UA}}
%\newcommand{\natrec}{\mathsf{natrec}}
%\newcommand{\set}[1]{\{#1\}}
%\newcommand{\sct}[1]{[\![#1]\!]}
%\newcommand{\refl}{\mathsf{refl}}
\newcommand{\ttt}[1]{\text{\tt #1}}

\newcommand{\Constraint}{\mathsf{Constraint}}
\newcommand{\Ordo}{\mathcal{O}}
\newcommand{\AFu}{\mathcal{A}}
\newcommand{\Fu}{\mathit{Fu}}

\newcommand{\Ctx}{\mathrm{Ctx}}
\newcommand{\Ty}{\mathrm{Ty}}
\newcommand{\Tm}{\mathrm{Tm}}
\newcommand{\op}{\mathrm{op}}

\newcommand{\CComega}{\mathrm{CC}^\omega}
\setlength{\oddsidemargin}{0in} % so, left margin is 1in
\setlength{\textwidth}{6.27in} % so, right margin is 1in
\setlength{\topmargin}{0in} % so, top margin is 1in
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{9.19in} % so, foot margin is 1.5in
\setlength{\footskip}{.8in}

% Definition of \placetitle
% Want to do an alternative which takes arguments
% for the names, authors etc.

\newcommand\myfrac[2]{
 \begin{array}{c}
 #1 \\
 \hline \hline
 #2
\end{array}}

\def\levelctx{\mathrm{lctx}}
\def\lhom{\mathrm{lhom}}
\def\psiab{\psi_{\alpha\beta}}

\newcommand*{\Scale}[2][4]{\scalebox{#1}{$#2$}}%
\newcommand*{\Resize}[2]{\resizebox{#1}{!}{$#2$}}

\newcommand{\II}{\mathbb{I}}
\newcommand{\refl}{\mathsf{refl}}
%\newcommand{\mkbox}[1]{\ensuremath{#1}}


%\newcommand{\Id}{\mathsf{Id}}
%\newcommand{\conv}{=}
%\newcommand{\conv}{\mathsf{conv}}
%\newcommand{\lam}[2]{{\langle}#1{\rangle}#2}
\def\NN{\mathsf{N}}
\def\UU{\mathsf{U}}
\def\JJ{\mathsf{J}}
%\def\Type{\hbox{\sf Type}}
\def\ZERO{\mathsf{0}}
\def\SUCC{\mathsf{S}}

\newcommand{\RawCtx}{{\tt Ctx}}
\newcommand{\RawSub}{{\tt Sub}}
\newcommand{\RawTy}{{\tt Ty}}
\newcommand{\RawTm}{{\tt Tm}}
\newcommand{\type}{\mathsf{type}}
\newcommand{\N}{\mathsf{N}}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\El}{\mathsf{El}}
%\newcommand{\U}{\mathsf{U}} clashes with def's in new packages
\newcommand{\T}{\mathsf{T}}
\newcommand{\Usuper}{\UU_{\mathrm{super}}}
\newcommand{\Tsuper}{\T_{\mathrm{super}}}
%\newcommand{\conv}{\mathrm{conv}}
\newcommand{\idtoeq}{\mathsf{idtoeq}}
\newcommand{\isEquiv}{\mathsf{isEquiv}}
\newcommand{\ua}{\mathsf{ua}}
\newcommand{\UA}{\mathsf{UA}}
\def\Constraint{\mathsf{Constraint}}
\def\Ordo{\mathcal{O}}
\def\Pihat{\Pi}

\def\Ctx{\mathrm{ctx}}
\def\Ty{\mathrm{ty}}
\def\Tm{\mathrm{tm}}
\def\Obj{\mathrm{obj}}
\def\Hom{\mathrm{hom}}
\def\id{\mathrm{id}}
\def\lHom{\mathrm{lhom}}
\def\lctx{\mathrm{lctx}}
\def\lty{\mathrm{level}}
\def\ltm{\mathrm{ltm}}
\def\ltmq{\mathrm{ltmq}}
\def\leq{\mathrm{leq}}
\def\lrefl{\mathrm{lrefl}}
\def\lp{\mathrm{lp}}
\def\lq{\mathrm{lq}}
\def\s{\mathrm{s}}
\def\lid{\mathrm{lid}}
\def\cctx{\mathrm{cctx}}
\def\cty{\mathrm{cty}}
\def\ctm{\mathrm{ctm}}
\def\cid{\mathrm{cid}}
\def\cp{\mathrm{cp}}
\def\cq{\mathrm{cq}}
\def\chom{\mathrm{chom}}

\newcommand{\ctx}{\mathrm{ctx}}
\newcommand{\sub}{\mathrm{sub}}
\newcommand{\ty}{\mathrm{ty}}
\newcommand{\tm}{\mathrm{tm}}
%\newcommand{\hom}{\mathrm{hom}}
\newcommand{\tuple}[1]{\langle #1 \rangle}
\def\CComega{\mathrm{CC}^\omega}
\newcommand{\cext}{.}
\def\p{\mathrm{p}}
\def\q{\mathrm{q}}
\def\app{\mathsf{app}}
\def\U{\mathsf{U}}
\def\T{\mathcal{T}}
\newcommand{\Ta}{\mathrm{T}}
\newcommand{\ta}{\mathrm{t}}

\newcommand{\natrec}{\mathsf{natrec}}
%\rightfooter{}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\sct}[1]{[\![#1]\!]}
\def\R{\mathcal{R}}

\def\L{{\mathcal{L}}}
\def\F{\mathcal{C}}
\def\CwF{\mathrm{CwF}}
\def\Fam{\mathrm{Fam}}
\def\SCwF{\mathrm{SCwF}}
\def\C{\mathcal{C}}
\def\W{\mathsf{W}}

\begin{document}

\title{Type Theory
with Explicit Universe Polymorphism\\ as an Initial Model of a Generalized Algebraic Theory\footnote{Alternative title: Categorical Models of Type Theory or Type Theory
with Explicit Universe PolymorphismGeneralised Algebraic Theories of Type Theories with Explicit Universe Polymorphism?
}}

\author{Marc Bezem, Thierry Coquand, Peter Dybjer, Mart\'{\i}n Escard\'o}

\date{(incomplete draft)}
\maketitle

\begin{abstract}
We present generalized algebraic theories corresponding to the theories in our paper 
{\em Type Theory with Explicit Universe Polymorphism}, so that models of these theories are models of the corresponding type theories. We first consider Martin-Löf type theory with an external tower of universes. Its models are categories with families with extra structure for the type formers including the universes. We then consider type theory with explicit universe polymorphsm, where we have universe level judgments and an internally indexed tower of universes. Its models are level-indexed categories with families, again with appropriate extra structure. Finally, we extend the theory with universe level constraints. Its models are doubly indexed categories with families with extra structure. In this way we get abstract syntax definitions of our theories as initial models of certain indexed categories with families with extra structure. We thus abstract from details of the grammar and inference rules of the type theories, and also highlight their high-level structure.
\end{abstract}

\section{Introduction}

The aim of Voevodsky's {\em initiality conjecture project} \cite{voevodsky:initiality} is to provide a general definition of class of dependent type theories and to develop generic metatheory for theories in this class. For example, one would like a generic construction showing that these theories are initial in corresponding categories of models. Such proofs may seem straightforward superficially, but depend on subtle details in the formulation of grammar and inference rules. Hence, Voevodsky insisted on calling such theorems ``conjectures'' until proven rigorously and ideally implemented in a proof assistant.

An example of such an initiality proof is Brunerie and de Boer's \cite{Brunerie:initiality,deBoer:lic} proof in Agda that a version of Martin-Löf type theory with an external tower of universes is an initial contextual category \cite{cartmell:phd,cartmell:apal} with appropriate extra structure. %Theversion of type theory with de Bruijn variables and implicit substitutions. 

A possible approach to Voevodsky's project is based on Cartmell's notion of a {\em generalized algebraic theory (gat)} \cite{cartmell:phd,cartmell:apal}. The most basic rules of dependent type theory can be captured by the gat of categories with families (cwfs) \cite{dybjer:torino}. Moreover, as shown in our paper {\em On generalized algebraic theories and categories with families} \cite{bezem:hofmann} there is a generic construction of an initial model of an arbitrary gat. 
%Maybe an approach to a general notion of dependent type theory is as an initial model of an extension of the gat of cws?

Furthermore, as shown by Castellan, Clairambault, and Dybjer \cite{castellan:lambek}, by considering simply typed cwfs (scwfs) and unityped cwfs (ucwfs) we can also capture various simply typed and untyped logical systems as gats and thus widening the scope of {\em uniform categorical logic} based on gats and cwfs.

In this article we shall introduce the notion of an indexed cwf, that is, a base category $\C$ and a cwf-valued presheaf
$$
P : \C^\op \to \CwF
$$
We shall show that cwfs indexed by (the base category of) a ucwf $\L$ of universe levels (with suitable extra structure) forms a suitable notion of model of Martin-Löf type theory with explicit universe polymorphism along the lines of our paper {\em Type Theory with Explicit Universe Polymorphism} \cite{BezemCDE22}. The benefit is twofold. First, it is a case study for our approach to the initiality conjecture project. Type theory with explicit universe polymorphism is an example of a dependent type theory, and we show that it can be captured by a gat based on a variation of cwfs. Second, it provides an alternative view of our syntactic type theory with explicit universe polymorphism. One can argue that a type theory presented by a gat of cwfs is a higher-level and more ``objective'' notion than a presentation by grammar and inference rules. This is because the gat only records the ``important" rules and highlights categorical structure. When building initial models in terms of grammar and inference rules we  need to include various bookkeeping rules, such as general rules of equality reasoning, and there will be a multitude of options. 

A proof that a (modification of) the theory presented in Bezem et al forms an initial model \cite{BezemCDE22} is however beyond the scope of the paper, and we only outline the relationship. 

Moreover, further variations of indexed cwfs extend the scope of gat and cwf-based uniform categorical. For example, untyped predicate logic can be captured by ucwf-indexed scwfs with extra structure for the logical constants. Moreover, typed predicate logic can be captured by scwf-indexed scwfs, and dependently typed predicate logic by cwf-indexed scwfs, both with suitable extra structure for type formers and logical constants.

(* Something about cwfs as intermediate between mainstream categorical notions and syntactic logical systems, and this holds also applies to variations such as ucwfs, scwfs, and indexed cwfs. The important thing is that these notions can be presented as gats, and hence have generic initial model constructions. Moreover, these gats resemble syntactically presented explicit substitution calculi. *)

\paragraph{Universe polymorphism.} We refer to our previous paper on explicit universe polymorphism \cite{BezemCDE22} for a presentation of the inference rules of Martin-Löf type theory with explicit universe polymorphism. There the reader can also find motivation and examples. Here we only give a brief overview. 

An implicit form of universe polymorphism in dependent type theory was introduced by Huet \cite{Huet87} and is an essential feature of the proof assistant Coq (Rocq) \cite{coq:general}. Alternatively, Agda \cite{agda-wiki} and Lean \cite{moura:lean} employ versions of universe polymorphism, where universe levels are explicitly declared. 

In our paper we followed Courant's approach \cite{Courant02} to explicit universe polymorphism and introduced special universe level {\em judgments}:
$$
l\ \level
\hspace{5em}
l = l'
$$
in addition to the usual judgment forms of type theory. Moreover, all judgments may depend on universe level variables as well as ordinary variables declared in the context. We emphasized that, unlike in Agda, universe levels do {\em not} form a {\em type} in our setting, and instead we added the above judgment forms. 

Furthermore, we presented an extension where equational constraints between universe levels can be declared \cite{BezemCDE22}, building on a proposal by Voevodsky \cite{VV}. This extension can also be described by a gat, but we will postpone this topic to a forthcoming paper.

\paragraph{Plan of the paper.} In Section 2 we present the infinitary gat of cwfs with extra structure for the type formers and an externally indexed tower of universes. We consider both cumulative and non-cumulative universes. In Section 3 we present the {\em finitary} gat of level-indexed type theory with extra structure for the type formers and an internally indexed tower of universes. (* In Section 4 we present the generalized algebraic theory of cwfs with extra structure doubly indexed by levels and level constraints *). In Section 5 we discuss models. In Section 6 we conclude. The appendix contains generalized algebraic theories appearing in previous publications. 

\paragraph{Acknowledgement.} This paper is written in honour of professor Stefano Berardi, the University of Torino, on the occasion of his 60th birthday. Stefano is a valued friend and colleague who spent the autumn of 1994 (check?) in Göteborg with the second and third author. He has made fundamental contributions to type theory and constructivity, in particular to the understanding of the constructive content of classical logic.

\paragraph{Postpone.} Postpone details of gats of cwfs and notational convention until section 2 and 3 (when needed). Something about qiits in the related work section.

\section{Type theory with an external tower of universes}

\paragraph{The gat of cwfs.} A cwf consists of a base category $\C$ of contexts and context morphisms (substitutions), a family-valued presheaf
$$
T : \C^\op \to \Fam
$$
and a notion of context comprehension. Here $\Fam$ is the category of indexed families of sets $(A,B)$, where $A$ is the index set and $B$ is a family of sets indexed by $A$. The reader is referred to the articles by Dybjer \cite{dybjer:torino}, Hofmann \cite{hofmann:cambridge}, and Castellan et al \cite{castellan:lambek} for a full definition and further information about cwfs.

The gat of cwfs with extra structure for $\Pi$-types, a notion of model of Martin-Löf type theory with $\Pi$-types, was presented by Dybjer \cite{dybjer:torino}. The extra operator symbols and equations needed for the natural number type and one universe can be found in Bezem et al \cite{bezem:hofmann}. We will use the same notation for gats as in that paper. For example, the gat of cwfs has four sort symbols:
\begin{eqnarray*}
&\vdash& \ctx\\
\Delta, \Gamma : \ctx&\vdash& \hom(\Delta,\Gamma)\\
\Gamma : \ctx&\vdash& \ty(\Gamma)\\
\Gamma : \ctx, A : \ty(\Gamma)&\vdash& \tm(\Gamma,A)
\end{eqnarray*}
corresponding to the objects and morphisms of the category of contexts, and the family of terms indexed by types in a given context, respectively. The notation states that $\ctx$ is a constant sort symbol, that $\hom$ is a binary sort symbol depending on arguments $\Delta, \Gamma : \ctx$, that $\ty$ is a unary sort symbol depending on the argument $\Gamma : \ctx$, and $\tm$ is a binary sort symbol depending on arguments $\Gamma : \ctx, A : \ty(\Gamma)$.

Moreover, the gat of cwfs has 10 operator symbols for the basic operations of cwfs (identity and composition of context morphisms, substitution in types and terms, empty context and context morphism, context extension and context morphism extension, projection morphism, last variable term): 
\begin{eqnarray*}
\Gamma : \ctx &\vdash& \id_{\Gamma} : \Hom(\Gamma,\Gamma)\\
\Xi,\Delta,\Gamma : \ctx, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta) &\vdash&
\gamma \circ \delta : \Hom(\Xi,\Gamma)\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma) &\vdash&
A[\gamma] : \ty(\Delta)\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Gamma,A) &\vdash&  a[\gamma] : \tm(\Delta,A[\gamma])\\
&\vdash& 1 : \ctx\\
\Gamma : \ctx &\vdash& \tuple{}_\Gamma : \Hom(\Gamma,1)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \Gamma\cext A : \ctx\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash& \tuple{\gamma,a} : \Hom(\Delta,\Gamma\cext A)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \p: \Hom(\Gamma\cext A,\Gamma)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \q: \tm(\Gamma\cext A,A[\p])
\end{eqnarray*}
The first line states that identity is a unary operator symbol with argument $\Gamma : \ctx$. The second line states that $\circ$ is a binary operator symbol with five arguments $\Xi,\Delta,\Gamma : \ctx, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta)$ and result sort $\Hom(\Xi,\Gamma)$. Note that only two of the five official arguments are explicit. To alleviate notation, we we often suppress arguments of operator symbols. Note also that we overload notation for type and term substitution $A[\gamma]$ and $a[\gamma]$.

Finally, the gat of cwfs has 13 equations. We illustrate the notation by showing one of the laws for identity morphisms.  The reader is referred to Bezem et al \cite{bezem:hofmann} for the remaining cwf-equations.
\begin{eqnarray*}
\Delta, \Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma) &\vdash& \id_\Gamma \circ \gamma = \gamma : \Hom(\Delta,\Gamma)
%\\
%\Delta, \Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma) &\vdash& \gamma \circ \id_\Delta = \gamma : \Hom(\Delta,\Gamma)\\
%\Theta, \Xi,\Delta,\Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta), \xi : \Hom(\Theta,\Xi) &\vdash&
%(\gamma \circ \delta) \circ \xi = \gamma \circ (\delta \circ \xi): \Hom(\Theta,\Gamma)
\end{eqnarray*}
In the official notation both argument and result types are explicit. However, to alleviate notation we often drop them and only write:
\begin{eqnarray*}
\id_\Gamma \circ \gamma = \gamma
\end{eqnarray*}
However, there are specific cases where we need the official notation. Assume that we add an operator symbol for the identity type former $\Id$ in Martin-Löf type theory:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), a, a' : \tm(\Gamma, A) &\vdash \Id_{\Gamma,A}(a,a'): \ty(\Gamma)
\end{eqnarray*}
In extensional type theory we have the rule of equality reflection. This can be captured by an equation in gats:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), a, a' : \tm(\Gamma, A),p :  \tm(\Gamma,\Id_{\Gamma,A}(a,a'))&\vdash& a = a' : \tm(\Gamma,A)
\end{eqnarray*}
Note that the variable $p$ does not occur on the right hand side.
However, it is a very important variable expressing
the condition under which $a=a'$ holds, and will never be left out.
%We will meet a similar case for reflection on equality on level terms.

\paragraph{The gat of cwfs with an external tower of universes.}
In Bezem et al \cite{BezemCDE22} we began by displaying the inference rules for Martin-Löf type theory with an external tower of universes $\UU_l$, where $l \in \N$ is an external natural number. Here we show the operator symbols and equations for the corresponding gat.

We assume that we already have defined the generalized algebraic theory of cwfs with the extra structure for the standard small type formers $\Pi, \Sigma, \N_0, \N_1, \N_2, \N, \W$, and $\Id$, and we wish to define a tower of universes closed under those. To save space, we shall however only display the operator symbols and equations for closure under $\Pi$-types, since it is straightforward to add similar operator symbols for closure under the other small type formers. We shall use the same convention throughout the paper.

The operator symbol for $\Pi$-types is
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), B : \ty(\Gamma.A) &\vdash& \Pi_\Gamma(A,B) : \ty(\Gamma)
\end{eqnarray*}
and refer to Bezem et al \cite{bezem:hofmann} for the operator symbols for abstraction and application and their associated equation.

In the gat for externally indexed universes we the following families of operator symbols (the universes $\UU_l$, the decoding maps, codes for $\Pi$, and codes for $\UU_l$ in $\UU_m$):
\begin{eqnarray*}
\Gamma : \ctx &\vdash& (\U_{l})_\Gamma : \ty(\Gamma)\\
\Gamma : \ctx, a : \tm(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta_{l}}(a) : \ty(\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,(\U_0)_\Gamma) \\
\Gamma : \ctx,
a : \tm(\Gamma,(\U_{l})_\Gamma),
b :  \tm(\Gamma \cdot \Ta_{l}(a), (\U_{l'})_\Gamma))
&\vdash&
 \Pihat^{l,l'}(a,b) : \tm(\Gamma,(\U_{l \vee l'})_\Gamma)\\
 \Gamma : \ctx&\vdash&(\UU^m_l)_\Gamma: \tm(\Gamma,(\UU_{m})_\Gamma)
\end{eqnarray*}
where $l, l' , m \in \NN$ with $l < m$. Note that codes for $\Pi$ are doubly indexed and $l \vee l' = \max(l,l')$.
We have again left some arguments to operator symbols implicit. For example, the decoding operators $\Ta_l$ are binary operators and that in the official notation we should write $\Ta_l(\Gamma,a)$. However, in the notation above we omit $\Gamma$ and write $\Ta_l(a)$.

We have the following decoding equations:
\begin{eqnarray*}
%\Ta(\N^0_\Gamma) &=& \N_\Gamma\\
\Ta_{l \vee l'}(\Pi^{l,l'}(a,b)) &=& \Pi(\Ta_l(a),\Ta_{l'}(b))\\
\Ta_{m}((\UU^m_l)_\Gamma) &=& (\UU_l)_\Gamma
\end{eqnarray*}

Moreover, we have equations that the operator symbols with respect to term substitution with $\gamma : \Hom(\Delta,\Gamma)$: 
\begin{eqnarray*}
(\U_l)_\Gamma [ \gamma ] &=& (\U_l)_\Delta\\
\Ta_l(a) [ \gamma ] &=& \Ta_l(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^{l,l'}(a,b)[ \gamma ] &=& \Pi^{l,l'}(a [ \gamma ], b[ \gamma^+ ])\\
(\UU^m_l)_\Gamma[ \gamma ] &=&(\UU^m_l)_\Delta
\end{eqnarray*}
where $\gamma^+ = \langle \gamma \circ \p, \q \rangle$ (check!).
%\paragraph{Adding cumulativity.}
If we want a cumulative tower of universes we add operator symbols that lift elements in the $l$th universe to the $m$th universe for $l < m$:
\begin{eqnarray*}
\Gamma : \ctx, a : \tm(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta^m_{l}}(a) : \tm(\Gamma,(\U_{m})_\Gamma))
\end{eqnarray*}
In the presence of cumulativity it suffices that codes for $\Pi$ have one superscript rather than two:
\begin{eqnarray*}
\Gamma : \ctx,
a : \tm(\Gamma,(\U_{l})_\Gamma),
b :  \tm(\Gamma \cdot \Ta_{l}(a), (\U_{l})_\Gamma))
&\vdash&
 \Pihat^{l}(a,b) : \tm(\Gamma,(\U_{l})_\Gamma)
 \end{eqnarray*}
 We omit the equations for the cumulative case, see instead the cumulative case for level-indexing.

\paragraph{Syntax and inference rules as an initial model.} A proof that a version of Martin-Löf type theory with an external tower of universes  is an initial contextual category with appropriate extra structure has been implemented in Agda by de Boer and Brunerie \cite{Brunerie:initiality,deBoer:lic}. This is for a version of type theory with de Bruijn variables and implicit substitutions. The equivalence between split type-cateogries and categories with families was implemented in UniMath by Ahrens, Lumsdaine, and Voevodsky \cite{AhrensLV18}. Moreover, the syntax and inference rules in our paper \cite{BezemCDE22} are not identical to the ones implemented by de Boer and Brunerie, but we expect no difficulty in adapting their proof.

Remark on decorating application in the grammar for the theory of the old paper. (Check what de Boer does!)

\paragraph{Internalization.}
A simple way to internalize the externally indexed tower of universes is to index each universe by an {\em internal} natural number. Instead of an external sequence $\UU_l$ we would have an internal sequence 
$$l : \N, \Gamma : \ctx, l : \tm(\Gamma,\N) \vdash \UU_l : \ty(\Gamma)$$
However, this would mean that we could build large types such as $\Pi l : \N.\U_l$ and $\Sigma l : \N.\U_l$ which increase the proof theoretic strength of type theory. 

In Agda, there is a type $\Level$ which has a level 0, and is closed under the next level operation $(-)^+$ and $\vee$. Also here we can build $\Pi l : \Level.\U_l$ and $\Sigma l : \Level.\U_l$.

\section{Level-indexed type theory}

We shall now show the generalized algebraic theory corresponding to the our theory where we do not have a type of levels but level judgments \cite{BezemCDE22}.
This gat consists of the following parts:
\begin{itemize}
\item the ucwf of levels
\item the ucwf-indexed cwf with $\Pi$-types and level-indexed universes
\begin{itemize}
\item the object part has sort symbols for level-indexed judgments and operator symbols for ...
\item the arrow part has operator symbols for level-substitutions in all sorts of the cwfs that preserve all the structure.
\end{itemize}
\end{itemize}

\subsection{The ucwf of levels}
We shall now turn the externally indexed tower of universes into an internally indexed one by replacing the external natural numbers with internal level expressions. We shall organize these as a unityped cwf (ucwf) of levels  with extra structure for upper semilattices with an inflationary endomorphism. 
\begin{itemize}
\item 
An object $n \in \Ctx_\L$ represents a level context, that is, a sequence of distinct level variables (or just records the number of level variables). 
\item
A term in $\Tm_\L(n)$ represents a level expression in $n$ level variables.
\item
A morphism in $\Hom_\L(m,n)$ represents a sequence of length $n$ of level expressions depending on level variables in $m$.
\end{itemize}

Since ucwfs are cwfs with only one type, the gat of ucwfs is a simplified version of the gat of cwfs. We only need three sort symbols\footnote{%
MB Eliminate this duplication in forthcoming restructuring.} 
%\begin{tiny}
\begin{eqnarray*}
&\vdash& \lctx\\
m, n : \lctx &\vdash& \lHom(m,n)\\
%\Gamma : \lctx &\vdash& \lty(\Gamma)\\
m : \lctx &\vdash& \ltm(m)
\end{eqnarray*}
The operator symbols for ucwfs are
\footnote{Add remark about dropping of arguments}
\footnote{We use  $\sigma,\tau$ for level substitutions.}
\footnote{In other places we use $\lp$ and $\lq$. Same issue with $\cp$ and $\cq$.}
\begin{eqnarray*}
m : \lctx &\vdash& \lid_m : \lhom(m,m)\\
m, n, p : \lctx, \sigma : \lhom(n,p), \tau : \lhom(m,n) &\vdash&
\sigma \circ \tau : \lhom(m,p)\\
&&\\
m,n: \lctx, \sigma : \lhom(n,m), l :\ltm(m) &\vdash&  l[\sigma] : \ltm(n)\\
&&\\
&\vdash& 0 : \lctx\\
m : \lctx &\vdash& \tuple{}_m : \lhom(m,0)\\
&&\\
m : \lctx &\vdash& \s(m) : \lctx\\
m,n : \lctx, \sigma : \lhom(n,m), l:\ltm(n) &\vdash& \tuple{\sigma,l} : \lhom(n,\s(m))\\
m : \lctx &\vdash& \lp: \lhom(\s(m),m)\\
m : \lctx &\vdash& \lq: \ltm(\s(m))
\end{eqnarray*}
Note that since there is only one type, we can remove the operator symbol for operations in types and only keep substitution in (level) terms.

Moreover, we have the operator symbol for the successor level and for the supremum of two levels:
\begin{eqnarray*}
m : \lctx, l : \ltm(m) &\vdash& l^+ : \ltm(m)\\
m : \lctx, l,l' : \ltm(m) &\vdash& l \vee l' : \ltm(m)
\end{eqnarray*}
Note that, as in our old paper, we have no level 0 for the first universe. All universes are polymorphic! See the discussion in the old paper.
%\end{tiny}

%\begin{tiny}
We also have all the ucwf-equations, but we do not display them here. These are the cwf-equations (see Dybjer \cite{dybjer:torino} and Bezem et al \cite{BezemCDE22})
%appendix   \ref{sec:gatPiU}) 
for the special case that there is only one type, so that all type equations are redundant.

We have the semi-lattice equations for $l \vee l'$:
\begin{eqnarray*}
(l \vee l') \vee l'' &=& l \vee (l' \vee l'')\\
l \vee l' &=& l'\vee l\\
l \vee l &=& l
\end{eqnarray*}
and the equations for $l^+$:
\begin{eqnarray*}
l \vee l^+ &=& l^+\\
(l\vee l')^+ &=& l^+\vee l'^+
\end{eqnarray*}
The operator symbols $\vee$ and $+$ commute with level substitution.
\begin{eqnarray*}
(l \vee l')[\sigma] &=& l[\sigma] \vee l' [\sigma]\\
 l^+[\sigma] &=&  l[\sigma]^+
\end{eqnarray*}
%\end{tiny}
\paragraph{Remark.} Ucwfs are closely related to Lawvere theories. One can prove that the latter are equivalent to contextual ucwfs, that is, ucwfs where each context has a length \cite{CCD:lambek}.

\subsection{Ucwf-indexed cwfs  with $\Pi$-types}

We now define the generalized algebraic theory of ucwf-indexed cwfs with $\Pi$-types. These are contravariant functors $F$ from the category of contexts of $\L$ (we use $\L$ also for the base category of the ucwf $\L$)  to the category with objects cwfs with $\Pi$-types and arrows cwf-morphisms preserving $\Pi$-types:
$$
T : \L^\mathrm{op} \to \CwF^{\Pi}
$$
We have
\begin{itemize}
\item
$T(n)$ is the cwf (with $\Pi$-types) of contexts, substitutions, types, and terms that depend on level variables in $n$.
\item
Each $T(n)$ has extra structure for level-indexed universes $\UU_l$ with decodings $\Ta_l$, where $l$ is a level term that depends on level variables in $n$. These universes are closed under $\Pi$-types and contain smaller universes $\UU_{l'}$ for $l' < l$.
\item
The cwf-functor $T(\sigma) : T(n) \to T(m)$ substitutes the $n$ level variables by the level expressions in $\sigma$ in the various components of a cwf depending on $n$ level variables, yielding a cwf depending on $m$ level variables. All structure of the cwf with $\Pi$-types and level-indexed universes is preserved.
\end{itemize}

\subsection{Theory of the object part of $T$ (* relegate to appendix *) }
We have the following sort symbols:
\begin{eqnarray*}
n : \lctx &\vdash& \ctx_n\\
n : \lctx, \Delta, \Gamma : \ctx_n &\vdash& \Hom_n(\Delta,\Gamma)\\
\end{eqnarray*}
Operator symbols:
\begin{eqnarray*}
n : \lctx, \Gamma : \ctx_n &\vdash& \id_{n,\Gamma} : \Hom_n(\Gamma,\Gamma)\\
n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \gamma : \Hom_n(\Delta,\Gamma), \delta : \Hom_n(\Xi,\Delta) &\vdash&
\gamma \circ \delta : \Hom_n(\Xi,\Gamma)
\end{eqnarray*}
Note that officially $\circ$ has six arguments rather than two.
We have the following equations:
\begin{eqnarray*}
\id_{n,\Gamma} \circ \gamma &=& \gamma \\
 \gamma \circ \id_{n,\Delta} &=& \gamma \\
(\gamma \circ \delta) \circ \xi &=& \gamma \circ (\delta \circ \xi)
\end{eqnarray*}

%\end{tiny}

\paragraph{There is a family-valued functor above each level-context $n$}

\footnote{MB, check. Perhaps better to describe how to modify \ref{sec:gatPiU}:
prefix every rule with $n:\lctx$ and add index $n$ to every occurrence
of $\ctx,\ty,\tm$.}

%\begin{tiny}
Sort symbols:
\begin{eqnarray*}
n : \lctx, \Gamma : \ctx_n &\vdash& \ty_n(\Gamma)\\
n : \lctx, \Gamma : \ctx_n, A:\ty_n(\Gamma) &\vdash& \tm_n(\Gamma,A)
\end{eqnarray*}

Operator symbols:
\begin{eqnarray*}
n : \lctx, \Gamma,\Delta : \ctx_n, A:\ty_n(\Gamma), \gamma : \Hom_n(\Delta,\Gamma) &\vdash&
A[\gamma] : \ty_n(\Delta)\\
n : \lctx, \Gamma,\Delta : \ctx_n, A:\ty_n(\Gamma), \gamma : \Hom_n(\Delta,\Gamma), a:\tm_n(\Gamma,A) &\vdash&  a[\gamma] : \tm_n(\Delta,A[\gamma])
\end{eqnarray*}

Equations: (where we have factored out the common context $n : \lctx, \Gamma : \ctx_n, A:\ty_n(\Gamma)$):
\begin{eqnarray*}
&\vdash& A[\id_{n,\Gamma}] = A : \ty_n(\Gamma)\\
a:\tm_n(\Gamma,A) &\vdash& a[\id_{n,\Gamma}] = a : \tm_n(\Gamma,A)\\
n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \delta : \Hom_n(\Xi,\Delta), \gamma : \Hom_n(\Delta,\Gamma),
&\vdash& A[\gamma\circ\delta] = A[\gamma][\delta]: \ty_n(\Xi)\\
n : \lctx, \Xi,\Delta, : \ctx_n, \delta : \Hom_n(\Xi,\Delta), \gamma : \Hom_n(\Delta,\Gamma),
a:\tm_n(\Gamma,A) &\vdash&
a[\gamma\circ\delta] = a[\gamma][\delta]: \tm_n(\Xi,A[\gamma\circ\delta])
\end{eqnarray*}
%\begin{eqnarray*}
%n : \lctx, \Gamma : \ctx_n, A:\ty_n(\Gamma) &\vdash& A[\id_{n,\Gamma}] = A : \ty_n(\Gamma)\\
%n : \lctx, \Gamma : \ctx_n, A:\ty_n(\Gamma), a:\tm_n(\Gamma,A) &\vdash& a[\id_{n,\Gamma}] = a : \tm_n(\Gamma,A)\\
%n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \delta : \Hom_n(\Xi,\Delta), \gamma : \Hom_n(\Delta,\Gamma),
%A:\ty_n(\Gamma) &\vdash& A[\gamma\circ\delta] = A[\gamma][\delta]: \ty_n(\Xi)\\
%n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \delta : \Hom_n(\Xi,\Delta), \gamma : \Hom_n(\Delta,\Gamma),
%A:\ty_n(\Gamma), a:\tm_n(\Gamma,A) &\vdash&
%a[\gamma\circ\delta] = a[\gamma][\delta]: \tm_n(\Xi,A[\gamma\circ\delta])
%\end{eqnarray*}
We have dropped some of the official arguments here too, and will do so in the following as well.
%\end{tiny}
  

\paragraph{Remark.} on finitely presented semilattices and constraints.

%\begin{itemize}
%\item
%Object part of the functor $\L \to \CwF^{\Pi,\UU_l}$
%\begin{itemize}
%\item Level-indexed contexts and context-morphisms
%\item Level-indexed types and terms
%\end{itemize}
%\item
%Arrow part of the functor $\L \to \CwF^{\Pi,\UU_l}$
%\begin{itemize}
%\item Level-substitution in contexts and context-morphisms
%\item Level-substitution in types and terms
%\end{itemize}
%\end{itemize}



\subsubsection{There is a terminal object above each level-context $n$}

%\begin{tiny}
%Sort symbols: none
Operator symbols:
\begin{eqnarray*}
n : \lctx &\vdash& 1_n : \ctx_n\\
n : \lctx, \Gamma : \ctx_n &\vdash& \tuple{}_{n,\Gamma} : \Hom_n(\Gamma,1_n)
\end{eqnarray*}
Equations:
\begin{eqnarray*}
n : \lctx &\vdash& \id_{n,1_n} = \tuple{}_{1_n} : \Hom_n(1_n,1_n)\\
\Gamma,\Delta : \ctx_n , \gamma : \Hom_n (\Delta,\Gamma) &\vdash&
\tuple{}_{n,\Gamma\circ\gamma} = \tuple{}_{n,\Delta} : \Hom_n (\Delta,1_n )
\end{eqnarray*}
%\end{tiny}


\subsubsection{There is a context comprehension above each level-context $n$}

Omitted.

\subsection{Level-indexed universes}

The operator symbols for universe formation $\UU_l$, the decoding map $\Ta_l$, and the introduction rule for closure under all small type formers are obtained by a straightforward internalization of the corresponding rules for the externally indexed universes. (as before we only show closure under $\Pi$ and leave the closure under other the other standard small type formers) : (Factor out common premises?)
\begin{eqnarray*}
n : \lctx, l : \ltm(n), \Gamma : \lctx_n &\vdash& (\U_{l})_\Gamma : \ty_n(\Gamma)\\
n : \lctx, l : \ltm(n), \Gamma : \ctx_n, a : \tm_n(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta_{l}}(a) : \ty_n(\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,(\U_0)_\Gamma) \\
n : \lctx, l, l' : \ltm(n), \Gamma : \ctx_n,
a : \tm_n(\Gamma,(\U_{l})_\Gamma),
b :  \tm_n(\Gamma \cdot \Ta_{l}(a), (\U_{l'})_\Gamma)
&\vdash&
 \Pihat^{l,l'}(a,b) : \tm_n(\Gamma,(\U_{l \vee l'})_\Gamma)
\end{eqnarray*}
However, when we try to internalize the operator symbols $\UU^m_l$ for universes $\UU^l$ in larger universes $\UU^m$, where $l < m$, we encounter a problem. The following attempt
\begin{eqnarray*}
n : \lctx, l, m : \ltm(n), l < m, \Gamma : \ctx_n&\vdash&(\UU^m_l)_\Gamma: \tm_n(\Gamma,(\UU_{m})_\Gamma)
\end{eqnarray*}
where $l < m$ is defined as $l^+ \vee m = m$, does not work since equations are not allowed in argument types in gats. This issue can be resolved by introducing a new sort symbol for level equality:
\begin{eqnarray*}
n : \lctx, l, l'  : \ltm(n) &\vdash& \leq_n(l,l')
\end{eqnarray*}
and an operator symbol for reflexivity:
\begin{eqnarray*}
n : \lctx, l : \ltm(n) &\vdash& \refl(l) :  \leq_n(l,l)
\end{eqnarray*}
Note that if we can derive 
\begin{eqnarray*}
n : \lctx, l, l'  : \ltm(n) &\vdash& l = l' : \ltm(n)
\end{eqnarray*}
in the initial model, then we can also derive
\begin{eqnarray*}
n : \lctx, l,l' : \ltm(n) &\vdash& \refl(l) :  \leq_n(l,l')
\end{eqnarray*}
\footnote{Can we prove the following:
If we have derivations
\begin{eqnarray*}
\vdash n : \lctx, \vdash l,l' : \ltm(n), \vdash p :  \leq_n(l,l')
\end{eqnarray*}
then $\vdash p = \refl(l) : \leq(l,l')$ and $\vdash l = l' : \ltm(n)$.
}

We now define $l < m$ as $\leq_n(l^+ \vee m, m)$ and get a proper typing of the operator symbol $\UU^m_l$:
\begin{eqnarray*}
n : \lctx, l, m : \ltm(n), p : l < m, \Gamma : \ctx_n&\vdash&(\UU^m_l)_{p,\Gamma} : \tm_n(\Gamma,(\UU_{m})_\Gamma)
\end{eqnarray*}
In the sequel we will suppress the proof $p : l < m$ as an argument to this operator symbol and just write $(\UU^m_l)_{\Gamma}$.

The decoding equations for $\Ta_l$ and the equations for commutativity of operator symbols with substitution can be obtained by a straightforward internalization of the corresponding equations for the external tower, see ?.
\footnote{Omit:
Equations for commutativity of operator symbols wrt substitution ($\gamma : \hom(\Delta,\Gamma)$):
\begin{eqnarray*}
\Ta^m_l(a) [ \gamma ] &=& \Ta^m_l(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^{l}(a,b)[ \gamma ] &=& \Pi^{l}(a [ \gamma ], b[ \gamma^+ ])
\end{eqnarray*}
Moreover, we have equations for commutativity of lifting and $\Pi$-codes with respect to term substitution $\gamma$:
 \begin{eqnarray*}
(\U_l)_\Gamma [ \gamma ] &=& (\U_l)_\Delta\\
\Ta_l(a) [ \gamma ] &=& \Ta_l(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^{l,l'}(a,b)[ \gamma ] &=& \Pi^{l,l'}(a [ \gamma ], b[ \gamma^+ ])\\
(\UU^l)_\Gamma[ \gamma ] &=&(\UU^l)_\Delta
\end{eqnarray*}
}

\paragraph{Adding cumulativity.} Adding an operator symbol for cumulativity is also a straightforward internalization of the lifting operations in the external tower:
\begin{eqnarray*}
n : \lctx, l,m : \ltm(n), l < m, \Gamma : \ctx_n, a : \tm_n(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta^m_{l}}(a) : \tm(\Gamma,(\U_{m})_\Gamma))
\end{eqnarray*}
where again $l < m$ is defined as $\leq_n(l^+ \vee m, m)$. However, unlike for the external tower of universes, we need double superscripts on codes $\Pi^{l,l'}$ also in the cumulative case. 
%This is because, unlike in the external case, we to the greater in general.

We have the following decoding equations for lifting (common premiss is $n : \lctx$):
\begin{eqnarray*}
l,l',m,m' : \ltm(n), l < m, l' < m', , \Gamma : \ctx(n), a : \tm_n(\Gamma,(\UU_l)_\Gamma), b : ?  &\vdash& \Ta^{m \vee m'}_{l \vee l'}(\Pi^{l,l'}(a,b)) = \Pi^{m,m'}(\Ta^m_l(a),\Ta^{m'}_{l'}(b))\\
k, l, m : \ltm(n), k < l < m, \Gamma : \ctx(n) &\vdash& \Ta^m_l((\UU^l_k)_\Gamma) = (\UU^m_k)_\Gamma
\end{eqnarray*}
Equations for commutativity of lifting and substitution ($\gamma : \hom(\Delta,\Gamma)$):
\begin{eqnarray*}
\Ta^m_l(a) [ \gamma ] &=& \Ta^m_l(a[ \gamma ] )
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
%\Pi^{l}(a,b)[ \gamma ] &=& \Pi^{l}(a [ \gamma ], b[ \gamma^+ ])
\end{eqnarray*}

\paragraph{Remark.} The introduction of the sort symbol $\leq$ is analogous to the introduction of the identity type former $\Id$ in Martin-Löf type theory. We can think of $\leq_n(l,l')$ as propositional level equality and its elements $p : \leq_n(l,l')$ as proofs of propositional level equality. However, while proofs $p : \Id(A,a,a')$ can make use of advanced logical reasoning, proofs of level equality can only be constructed from reflexivity\footnote{How to say this rigorously? We can of course use general reasoning available in any initial gat, including reasoning about judgmental level equality.}


\subsection{Level substitution}

\subsubsection{Level substitution in contexts and context-morphisms}

%\begin{tiny}
Operator symbols (overloaded notation):
\begin{eqnarray*}
n, n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'} &\vdash& 
\Gamma[\sigma] : \ctx_n\\
n, n' : \lctx , \sigma : \lhom(n,n'), \Delta,\Gamma : \ctx_{n'}, \gamma : \Hom_{n'}(\Delta,\Gamma) 
&\vdash& 
\gamma[\sigma] : \Hom_{n}(\Delta[\sigma],\Gamma[\sigma]) 
\end{eqnarray*}
Equations:
\begin{eqnarray*}
\Gamma[\lid_n] &=& \Gamma\\
\Gamma[\sigma \circ \tau] &=& \Gamma[\sigma][\tau]\\
\gamma[\lid_n] &=& \gamma\\
\gamma[\sigma \circ \tau] &=& \gamma[\sigma][\tau]
\end{eqnarray*}
%\end{tiny}

\subsubsection{Level substitution in types and terms}

MB, check.

Operator symbols (overloaded notation):
\begin{eqnarray*}
n, n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'}, A:\ty_{n'}(\Gamma)
&\vdash& 
A[\sigma]: \ty_n(\Gamma[\sigma])\\
n,n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'}, A:\ty_{n'}(\Gamma), a : \tm_{n'}(A,\Gamma) 
&\vdash& 
a[\sigma] : \tm_{n}(A[\sigma],\Gamma[\sigma]) 
\end{eqnarray*}
\begin{eqnarray*}
A[\lid_n] &=& A\\
A[\sigma \circ \tau] &=& A[\sigma][\tau]: \ty_p(\Gamma[\sigma \circ \tau])\\
a[\lid_n] &=& a\\
a[\sigma \circ \tau] &=& a[\sigma][\tau]: \tm_p(A[\sigma][\tau],\Gamma[\sigma \circ \tau])
\end{eqnarray*}
%\end{tiny}

%\subsubsection{Functor laws for level-substitution}


\subsubsection{Level substitution in $\Pi$-types}

Let $n, n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'}, A:\ty_{n'}(\Gamma), B:\ty_{n'}(\Gamma.A)$. Then
\begin{eqnarray*}
\Pi(A,B)[\sigma] &=& \Pi(A[\sigma],B[\sigma])
\end{eqnarray*}
Moreover, if $b : \tm_n(\Gamma.A,B), c :  \tm_n(\Gamma,\Pi(A,B))$,  and $a : \tm_n(\Gamma,A)$, we have
\begin{eqnarray*}
\lambda(b)[\sigma] &=&\lambda(b[\sigma])\\
\app(c,a)[\sigma] &=&\app(c[\sigma],a[\sigma])
\end{eqnarray*}


Moreover, we have laws that level substitution $\sigma$ commutes with the operator symbols for a universe.
 \begin{eqnarray*}
 (\U_{l})_\Gamma[\sigma] &=& (\U_{l[\sigma]})_{\Gamma[\sigma]}\\
 \Ta_l(a) [ \sigma ] &=& \Ta_{l[\sigma]}(a[ \sigma ] )\\
\Pi^{l,l'}(a,b)[ \sigma ] &=& \Pi^{l[ \sigma ] ,l'[ \sigma ] }(a [ \sigma ], b[ \sigma^+ ])\\
(\UU^l)_\Gamma[ \sigma ] &=&(\UU^{l[ \sigma ]} )_{\Delta[ \sigma ]} 
 \end{eqnarray*}
Check that this is right. Cf comment by intern.

\paragraph{The initiality conjecture.} Ideally, we would like to prove that The the calculus in our old paper is an initial model of the gat  $\Sigma_{\mathrm{universe\ polymorphism}}$. It would then follow that it is equivalent to the variable free explicit substitution calculus $\T_{\Sigma_{\mathrm{universe\ polymorphism}}}$.
Such an initiality theorem might superficially seem straightforward, but a rigorous proof is surprisingly subtle. This is the reason why Voevodsky called his project ``the initiality conjecture''. In fact, an attempt to prove the conjecture for our system would probably uncover discrepancies.

Part of the proof of the initiality conjecture is to prove that the the level judgments of our old calculus constitutes an initial model of the ucwf of levels and constraints (this needs to be spelled out better). We sketch this syntactic cwf. In fact Brilakis has proved in Agda that two ucwfs built by an explicit cwf-calculus and implicit substitution calculus built from de Bruijn variables are equivalent. 
\begin{itemize}
\item Each level context in the sense of our old paper is an element of $\lctx$. $0 : \lctx$ is the empty context, and $\s(n)$ adds a new level variable to the level context $n : \lctx$. (Note that level contexts here are not just natural numbers (de Bruijn variables), but arbitrary sequences of level variable names.
\item An element of $\ltm(n)$ is a level term generated by $\vee$ and $(-)^+$ from level variables in $n$ taken up to the equality generated by the laws for
$\vee$ and $(-)^+$. (And for the laws in $\psi$. We should first formulate this theorem for the calculus without constraints.)
 \item An element of $\lhom(m,n)$ is a sequence of length $n$ of elements of $\ltm(m)$.
 \item The ucwf-operations are defined in the obvious way. E g level substitution $l[ls]$ is defined by induction on $l$. (Note that the calculus in our old paper uses implicit substitutions; this is the main difference between it and the level calculus in $\T_{\Sigma_{\mathrm{universe\ polymorphism}}}$. If $n = (l_n, \ldots, l_1)$ and $\s(n) =  (l_n, \ldots, l_1, l_0)$, then the projections are  $\p = (l_n, \ldots, l_1) : \lhom(\s(n),n)$ and $\q = l_0 : \ltm(\s(n))$.
\end{itemize}
In our old paper have the following introduction rule for cumulative universes with its decoding equation:
$$
\frac{l < m}
{\UU^m_l : \UU_m\hspace{3em}\Ta_m(\UU^m_l) = \UU_l}
$$
where the context $\Gamma$ is implicit.

\footnote{If  $n$ is the length of the level context, then level expressions have normal forms 
$$
\alpha_1^{+^{p_1}} \vee \cdots \vee \alpha_m^{+^{p_m}}
$$ 
for $p_i \geq 0$ for $1 \le i \le m \le n$ . We have 
$$
\alpha_1^{+^{p_1}} \vee \cdots \vee \alpha_m^{+^{p_m}} 
< 
\alpha_1^{+^{q_1}} \vee \cdots \vee \alpha_m^{+^{q_m}} \vee \alpha_{m+1}^{+^{q_{m+1}}} \vee \cdots \vee \alpha_{m'}  ^{+^{q_{m'}}}
$$ 
provided $p_i < q_i$ for $1 \le i \le m \le m' \le n$.} 

\subsection{Level-indexed products of types}
%We add three operator symbols in addition to the operator symbols for cwfs in Section 5.2 and 5.3:
\def\l{\mathrm{l}}
%\begin{tiny}
Operator symbols (universal level quantification, abstraction, and application):
\begin{eqnarray*}
n : \lctx, \Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp])&\vdash& \forall_\l(B) : \ty_n(\Gamma)\\
n : \lctx, \Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp]), b : \tm_{\s(n)}(\Gamma[\lp], B) &\vdash& \lambda_\l(b) : \tm_n(\Gamma,\forall_\l(B))\\
n : \lctx, \Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp]), c :  \tm_n(\Gamma,\forall_\l(B)), l : \ltm(n) &\vdash& \app_\l(c,l) : \tm_n(\Gamma, B[\tuple{\lid,l}])
\end{eqnarray*}
Equations ($\beta$ and $\eta$ for level abstraction and application):
 \begin{eqnarray*}
 \app_\l(\lambda_\l(b),l) &=& b[\tuple{\lid,l}]\\
 \lambda_\l(\app_\l(c[\lp],\lq)) &=& c
 \end{eqnarray*}
 Equations for commutativity of operator symbols wrt a level substitution $\sigma : \lhom(m,n)$ and a term substitution $\gamma : \hom_n(\Delta,\Gamma)$:
 \begin{eqnarray*}
 \forall_\l(B)[ \gamma ] &=& \forall_\l(B[ \gamma[\lp]])\\
 \lambda_\l(B)[ \gamma ] &=& \lambda_\l(B[ \gamma[\lp]])\\
 \app_\l(c,l)[ \gamma ] &=& \app_\l(c[ \gamma ] ,l[ \gamma ] )\\
 \forall_\l(B)[ \sigma ] &=& \forall_\l(B[ \sigma^{+}])\\
 \lambda_\l(B)[ \sigma ] &=& \lambda_\l(B[ \sigma^{+}])\\
\app_\l(c,l)[ \sigma ] &=& \app_\l(c[ \sigma ] ,l[ \sigma ] )
\end{eqnarray*}
where $\sigma^+ = \tuple{\sigma \circ \lp, \lq}$. No, this is not right. Check lifting of level substitution and term substitution.
%and $\gamma^+ = \tuple{\gamma \circ \p, \q}$??
%\end{tiny}

\section{Adding level-constraints}

\subsection{The level-indexed scwf of level constraints}

Constraints are lists of equations between level terms. We formalize the theory of constraints as level-indexed scwfs $(\cctx, \chom, \cty, \ctm)$.\footnote{Maybe we don't need the full scwf structure, but only lists of identities and projections to pull them out.} The gat of level-indexed scwf is the same as the gat of level-indexed cwfs defined above, except that in a scwf types don't depend on type contexts.\footnote{In a level-indexed scwf, types do depend on level contexts, though.} \footnote{In the published paper all constraint contexts are loop-free "The second condition is that the finite set of constraints in the extended context $\Gamma, \psi$ is loop-free." Here we prefer to allow arbitrary constraints as a first step. As a second step, suggested by Georges Gonthier, we add a rule that all types are equal to the unit type in a context that is not loop-free. Such a theory still has decidable type-checking.}

The following new sort symbols come from the structure of a level-indexed scwf:
\begin{eqnarray*}
n : \lctx &\vdash& \cctx_n\\
n : \lctx, \psi : \cctx(n), \psi' : \cctx(n) &\vdash& \chom_n(\psi,\psi')\\
n : \lctx &\vdash& \cty_n\\
n : \lctx, \psi : \cctx_n, c : \cty_n &\vdash& \ctm_n(\psi,c)
\end{eqnarray*}

The extra structure for level-indexed scwfs is given by the following operator symbol $\leq$ for {\em level equality} as types in the level-indexed scwf of constraints\footnote{equality reflection in ordinary type theory is the following equation in generalized algebraic theories:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), a, a' : \tm(\Gamma, A),p :  \tm(\Gamma,\Id_A(a,a'))&\vdash& a = a' : \tm(\Gamma,A)
\end{eqnarray*}
}
\begin{eqnarray*}
n : \lctx, l, l' : \ltm_n &\vdash& \leq(l,l') : \cty_n
\end{eqnarray*}
A constraint type $c : \cty_n$ is a level equation 
$\leq(l,l')$ in $n$ variables reflecting a level equation $l = l'$.
We note that $\leq$ is the only constructor for constraint types $\cty$. 
Consequently, by the basic structure for level-indexed scwfs,
a constraint "context" $\psi : \cctx_n$ is a list of constraint types, 
that is, a list of level equation types in $n$ variables. 
A constraint "term" $p : \ctm_n(\psi,c)$ is a proof that the equation $c$ is
in $\psi$.
% imply the equation $c$, see \cref{exa:cctx-entails-lattice-eqs}
%and \cref{lem:cctx-entails-lattice-eqs}.%
\footnote{We don't need 
any term constructors for $\leq$ beyond $\q$ from the basic
scwf set up. The reason is that all reasoning about level equations 
(except using a constraint assumption) is done using judgmental equalities.} 

Reasoning about level equality will be performed on the judgmental level. To this end we introduce a new sort for level terms with respect to constraints:
\begin{eqnarray*}
n : \lctx, \psi : \cctx_n &\vdash& \ltmq_n(\psi)
\end{eqnarray*}
This is to be understood as the quotient sort of $\ltm$ with respect to the equivalence relation generated by the constraints in $\psi$.
%and the laws for $\vee$ and $(-)^+$. 
We have a new operator symbol $[-]_{-}$ for equivalence class formation with its equation:
\begin{eqnarray*}
n : \lctx, \psi : \cctx_n,  l : \ltm_n &\vdash& [l]_\psi  : \ltmq_n(\psi)\\
n : \lctx, \psi : \cctx_n,  l, l' : \ltm_n, p : \ctm_n(\psi,\leq(l,l')) &\vdash& [l]_\psi  = [l']_\psi  : \ltmq_n(\psi)
\end{eqnarray*}
Note that the equation is a version of equality reflection: from a "propositional" level equality $\leq(l,l')$ we derive a judgmental level equality, and it is the latter that enables equational reasoning about $\vee$ and $(-)^+$ and $\psi$.
\begin{example}\label{exa:cctx-entails-lattice-eqs}
In our old paper we have a judgment form $\Gamma \vdash \psi\ \valid$ that expresses that the constraints in $\psi$
hold in $\Gamma$, that is, are implied by the constraints in $\Gamma$.
For example, if $\alpha$ and $\beta$ are level variables we can prove
$$
\alpha = \alpha\vee\beta, \beta\vee\alpha = \beta \vdash \alpha = \beta\ \valid
$$
by equational reasoning using commutativity of $\vee$ (one of the semilattice laws) in our system.

What does this correspond to in the present setting? Recall that each gat with sort symbols, operator symbols and equations in $\Sigma$ has an initial model $\T_\Sigma$. As shown in our paper on gats and cwfs, this can be defined as a variable free, explicit substitution calculus for dependent type theory built from cwf-combinators and the operator symbols in $\Sigma$\cite{bezem:hofmann}. In this calculus the above judgment corresponds to a level equation
$$
[\alpha]_{\psiab} = [\beta]_{\psiab} : \ltmq_2(\psiab)
$$
This is a judgment in the level context $2 = \s(\s(0)) : \lctx$ and the variables are defined as the projections $\alpha = \q[\p] : \ltm_2$ and $\beta = \q  : \ltm_2$ in the ucwf of levels. Moreover, 
$$
\psiab = 1.\leq(\alpha,\alpha\vee\beta).\leq(\beta\vee\alpha,\beta) : \cctx_2
$$
is a constraint context. The derivation of this in $\T_\Sigma$ uses that 
$\alpha$ and $\beta$ are level terms, and so are, 
$\alpha\vee\beta$ and $\beta\vee\alpha$, all in $\ltm_2$.
Hence we have the level equality types
$\leq(\alpha,\alpha\vee\beta)$ and $\leq(\beta\vee\alpha,\beta)$ both in $\cty_2$. Hence, we can form the constraint context $\psiab : \cctx_2$.
%$1.\leq(\alpha,\alpha\vee\beta).\leq(\beta\vee\alpha,\beta) : \cctx_2$,
%which we name $\psiab : \cctx_2$ for short.
We now instantiate the equation for equality reflection
with $n := 2$, $l :=  \beta\vee\alpha, l':= \beta, \psi:= \psiab$, and $p := \q: \ctm_2(\psiab,\leq(\beta\vee\alpha,\beta))$\footnote{check signs for instatiation and definition}
as above and get 
\[
%p : \ctm_2(\psiab,\leq(\beta\vee\alpha,\beta))
%\vdash 
[\beta\vee\alpha]_{\psiab} = [\beta]_{\psiab} : \ltmq_2(\psiab).
\]
We have used that the
level equality type $\leq(\beta\vee\alpha,\beta)$ is the last type
of the constraint context $\psiab$, so that we can use the operator $\q$ 
from the basic vocabulary of cwfs, see \ref{XYZ}.
%Thus the equation for equality reflection gives us:
%\[
%\vdash [\beta\vee\alpha]_{\psiab} = [\beta]_{\psiab} : \ltmq_2(\psiab)
%\]
that is, (MB: discuss) $\beta\vee\alpha$ and $\beta$ are equivalent
modulo $\psiab$, in the empty context.)

In much the same way, using the instantiation $l := \alpha,
l' := \alpha\vee\beta$ and $p := \q[\p]$ instead of $\q$, we get
\[
%p : \ctm_2(\psiab,\leq(\alpha,\alpha\vee\beta))
%\vdash 
[\alpha]_{\psiab}=[\alpha\vee\beta]_{\psiab} : \ltmq_2(\psiab).
\]
that $\alpha$ and $\alpha\vee\beta$ are equivalent modulo $\psiab$, 
in the empty context.

Next we explain how we can get, e.g.,
$
%\vdash 
[\alpha]_{\psiab} = [\beta]_{\psiab} : \ltmq_2(\psiab).
$
This result cannot be obtained by simply using the transitivity of $=$,
we also have to show that
$
%\vdash 
[\beta\vee\alpha]_{\psiab}=[\alpha\vee\beta]_{\psiab} : \ltmq_2(\psiab).
$
The latter follows from 
$
%\vdash 
\beta\vee\alpha=\alpha\vee\beta : \ltm_2$ and the fact that operator symbols preserve equality in gats.
\end{example}


An important observation in the above example is that
both $\leq(\alpha,\alpha\vee\beta)$ and $\leq(\beta\vee\alpha,\beta)$
are elements of $\psiab$, so that we can use the projections $\q$, $\q[\p]$. If there
are more elements in a constraint context, we can use the further projections $\q[\p][\p], \q[\p][\p][\p], \ldots$
to access the other equations in the constraint list.

%\begin{conjecture}\label{conj:cctx-entails-lattice-eqs}
\paragraph{The initiality conjecture for constraints.} We would like to extend the proof in section to 3 to constraints. Roughly, we need to show the following.
Let $n:\lctx$ be a level context, $l,l':\ltm_n$ level terms and 
$\psi:\cctx_n$ a constraint context. Then (in any initial model)
%\begin{eqnarray*}
%&\vdash& 
$$
[l]_\psi = [l']_\psi  : \ltmq_n(\psi)
$$
iff
$$
\psi^* \vdash l^* = l'^*
$$
in the system of our old paper, and $\psi^*$ (of length $n$) is the interpretation of $\psi$ in the initial gat generated by the system of our old paper. Similarly, the interpretation $l^*$ of $l : \ltm_n$ is a level term where variable names in $l^*$ have replaced the projections.
%\end{conjecture}

\subsection{The level- and constraint-indexed cwf of types}

{\bf All of this needs to be rethought!}

Let 
$$
\F : \L \to \SCwF
$$
be the level-indexed scwf of constraints described above.

We have a doubly indexed cwf of types (in our type theory)
$$
\T : (n : \L) \to (\psi : \F(n)) \to \L '(n,\psi) \to \CwF
$$
or alternatively (spell out what this means officially)
$$
\T : \sum_{n : \L}\F(n) \to \CwF
$$
So the contexts $\Ctx(n,\psi)$ in the cwf $\T(n,\psi)$ denotes the (type-theoretic) contexts in $n$ level variables satisfying the constraints in $\psi$, and similarly for the context morphisms, types, and terms.

\subsection{A level- and constraint-indexed non-cumulative tower of universes}


A finitary theory!
\\
\vspace{1ex}
Operator symbols: (We  factor out the common premises $n : \lctx, \psi : \cctx_n, l : \ltmq_n(\psi), \Gamma : \ctx_n(\psi)$. Note that $l$ now ranges over level terms quotiented by constraints in $\psi$).
%\begin{tiny}
\begin{eqnarray*}
%n : \lctx, \psi : \cctx_n, l : \ltm(n), \Gamma : \ctx_n(\psi) 
&\vdash& (\U_{l})_\Gamma : \ty_n(\psi,\Gamma)\\
%n : \lctx, \psi : \cctx_n, l : \ltm(n), \Gamma : \ctx_n(\psi), 
a : \tm_n(\psi,\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta_{l}}(a) : \ty_n(\psi,\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,(\U_0)_\Gamma) \\
%n : \lctx, \psi : \cctx_n,  l, 
l' : \ltmq_n(\psi),
a : \tm_n(\psi,\Gamma,(\U_{l})_\Gamma),
b :  \tm_n(\psi,\Gamma \cdot \Ta_{l}(a), (\U_{l'})_{\Gamma \cdot \Ta_{l}(a)})
&\vdash&
 \Pihat^{l,l'}(a,b) : \tm_n(\psi,\Gamma,(\U_{l \vee l'})_\Gamma)\\
 %n : \lctx, \psi : \cctx_n, l : \ltm(\psi,n),\Gamma : \ctx_n(\psi)
 &\vdash&\UU^l_\Gamma: \tm_n(\psi,\Gamma,(\UU_{l^+})_\Gamma)
\end{eqnarray*}
Equations:
\begin{eqnarray*}
&\vdots&
\end{eqnarray*}
%\end{tiny}
There are many equations. First for each $l$, $\U_l$ satisfies all the laws of a single universe, including laws of ordinary substitution. Then we have laws for level substitution $(\U_{l})_\Gamma[\sigma] = (\U_{l[\sigma]})_{\Gamma[\sigma]}$


\subsection{Constraint-indexed products of types}
%We add three operator symbols in addition to the operator symbols for cwfs in Section 5.2 and 5.3:
\def\l{\mathrm{l}}
%\begin{tiny}
Operator symbols (universal level quantification, abstraction, and application):
(We  factor out the common premises 
$
n : \lctx, \psi : \cctx_n, c : \cty_n, \Gamma : \ctx_n(\psi), A : \ty_n(\psi.c, \Gamma[\cp])
$.)
\begin{eqnarray*}
%n : \lctx, \psi : \cctx_n, c : \cty_n, \Gamma : \ctx_n(\psi), A : \ty_n(\psi.c, \Gamma[\cp])
&\vdash& [c]A : \ty_n(\psi,\Gamma)\\
%n : \lctx, \psi : \cctx_n, c : \cty_n, \Gamma : \ctx_n(\psi), A : \ty_n(\psi.c,\Gamma[\cp]), 
t : \tm_n(\psi.c,\Gamma[\cp], A) 
&\vdash& \langle c \rangle t : \tm_n(\psi,\Gamma,[c]A)\\
%n : \lctx, \psi : \cctx_n, c : \cty_n, \Gamma : \ctx_n(\psi), A : \ty_n(\psi.c,\Gamma[\cp]), 
f :  \tm_n(\psi,\Gamma,[c]A), pr : \ctm_n(\psi,c) &\vdash& \app_c(f,l) : \tm_n(\psi,\Gamma, A[\tuple{\cid,pr}])
\end{eqnarray*}
Equations ($\beta$ and $\eta$ for level abstraction and application):
 \begin{eqnarray*}
 \app_c(\langle c \rangle(b),pr) &=& b[\tuple{\cid,c}]\\
 \langle c \rangle(\app_c(f[\cp],\cq)) &=& f
 \end{eqnarray*}
 Equations for commutativity of operator symbols wrt constraint substitution $\sigma : \lhom(m,n)$ and a term substitution $\gamma : \hom_n(\Delta,\Gamma)$:
 \begin{eqnarray*}
 ([c]B)[ \sigma ] &=& [c](B[ \sigma^{+}])\\
 ([c]B)[ \gamma ] &=& [c](B[ \gamma^+ ])\\
&\vdots&
\end{eqnarray*}
where $\sigma^+ = \tuple{\sigma \circ \cp, \cq}$ and $\gamma^+ = \tuple{\gamma \circ \p, \q}$??
%\end{tiny}
\footnote{Check all this. It's easy to get wrong.}

\paragraph{Comparison with the rules in our old paper about explicit universe polymorphism.}
The first two operator symbols correspond $[c]A$ and $\langle c \rangle t$ to the first two rules (with implicit contexts) in our paper:
$$
\frac{\psi \vdash A\ type}{\vdash [\psi]A}
\hspace{5em}
\frac{\psi \vdash t : A}{\vdash \langle \psi \rangle t : [\psi]A}\
$$
The third operator symbol is the application of a constraint abstraction $\langle c \rangle t : [c]A$ to a proof that the constraint $c$ is valid. This suggests the following rule in the setup of our paper:
$$
\frac{\langle \psi \rangle t : [\psi]A\hspace{3em}\psi\ \valid}
{t : A}
$$
This rule is implied by the stronger rules in our paper:
$$
\frac
{\psi\ \valid}
{[\psi]A = A}
\hspace{5em}
\frac
{\psi\ \valid}
{[\psi]t  = t}
$$

\subsection{Level-indexed products of types in the presence of constraints}

{\bf I suggest to omit this although it's somewhat interesting.}
We can also do level-indexing in the theory with constraints, provided the constraints don't depend on the abstracted level variable.

\begin{tiny}
Operator symbols (universal level quantification, abstraction, and application):
\begin{eqnarray*}
n : \lctx, \psi : \cctx_{n}, \Gamma : \ctx_n(\psi), B : \ty_{\s(n)}(\psi[\lp],\Gamma[\lp])&\vdash& \forall_\l(B) : \ty_n(\psi,\Gamma)\\
n : \lctx, \psi : \cctx_{n}, \Gamma : \ctx_n(\psi), B : \ty_{\s(n)}(\psi[\lp],\Gamma[\lp]), b : \tm_{\s(n)}(\psi[\lp],\Gamma[\lp], B) &\vdash&  \lambda_\l(b) : \tm_n(\psi,\Gamma,\forall_\l(B))\\
n : \lctx, \psi : \cctx_{n}, \Gamma : \ctx_n(\psi), B : \ty_{\s(n)}(\psi[\lp],\Gamma[\lp]), f :  \tm_n(\psi,\Gamma,\forall_l(B)),  l : \ltm(n) &\vdash& \app_\l(f,l) : \tm_n(\psi,\Gamma, B[\tuple{\lid,l}])
\end{eqnarray*}
\end{tiny}

Note the similarity with with level-indexed products of types in the absence of constraints in 2.5. We only need to insert the dependence of constraints $\psi$ in $n$ level variables. Then we can abstract with respect to types and terms in $\s(n) = n+1$ variables.
\begin{tiny}
Equations ($\beta$ and $\eta$ for level abstraction and application):
 \begin{eqnarray*}
 \app_\l(\lambda_\l(b),l) &=& b[\tuple{\lid,l}]\\
 \lambda_\l(\app_\l(f[\lp],\lq)) &=& f
 \end{eqnarray*}
 Equations for commutativity of operator symbols wrt a level substitution $\sigma : \lhom(m,n)$ and a term substitution $\gamma : \hom_n(\Delta,\Gamma)$:
 \begin{eqnarray*}
 \forall_\l(B)[ \sigma ] &=& \forall_\l(B[ \sigma^{+}])\\
 \forall_\l(B)[ \gamma ] &=& \forall_\l(B[ \gamma^+ ])\\
&\vdots&
\end{eqnarray*}
where $\sigma^+ = \tuple{\sigma \circ \lp, \lq}$ and $\gamma^+ = \tuple{\gamma \circ \p, \q}$??
\end{tiny}

What about substitution with respect to constraints?

\subsection{The decision problem}

The decision problem is whether the judgments are decidable in the initial model. In the initial model the ucwf of levels is finitely presented, and so are the constraints.

There is an algorithm for deciding whether a set of constraints $\psi$ is consistent \cite{bezem-coquand:lattices}. If it is consistent then a small modification of the decision algorithm for type theory with an external hierarchy of universes can be employed for the theory with constraints on levels.

If $\psi$ is inconsistent, then the theory is undecidable. If we have a loop $l = l^+$, then $\UU_l : \UU_{l^+}$ implies $\UU_l : \UU_l$.

We can recover decidability by adding the rule that any type is equal to the unit type in an inconsistent level context $\psi$:
\begin{eqnarray*}
 \Gamma : \ctx, A  : \ty(\Gamma), c : \psi &\vdash& A = 1_\Gamma
\end{eqnarray*}

\paragraph{Appendix C.} Here we add the rules
$$
\frac{A\ type\hspace{3em}l < l}{A = \emptyset}
\hspace{5em}
\frac{t : A\hspace{3em}l < l}{t = \emptyset : A}
$$
The first rule corresponds to the following operator in generalized algebraic theories:
$$
n : \lctx, \psi : \cctx_n, \Gamma : \ctx_n(\psi), l : \ltm_n, p : \ctm_n(\psi,l < l), A : \ty_n(\psi,\Gamma)
\vdash
A = 1_\Gamma
$$
where $l < l : \cty_n$ abbreviates $\leq(l^+ \vee l,l) = \leq(l^+,l)$. If we have $A = 1$ rather than $A = \emptyset$ then we don't need an analogue of the second rule.  


\paragraph{Remark.} We need to think more about this.

\section{Set-theoretic models}

\subsection{The system with internal levels but no constraints.}
Assume we have a model in set theory with a hierarchy of universes of type theory with an external hierarchy of universes. The corresponding cwf has the components
 $$
(\Ctx, \Hom, \Ty, \Tm)
 $$
Let’s first consider the system with internal levels (as in our paper) but without constraints. We can now build a corresponding ucwf-indexed cwf (with the appropriate extra structure)
 $$
T : \L^{\op} \to \CwF
$$
where $\L$ is the ucwf with $\Ctx_\L = \N$ and $\Tm_\L(n) = \N^n \to \N$, that is, level expressions in $n$ level variables are interpreted as $n$-place set theoretic functions on $\N$. This has the appropriate sup/+ - structure with $\max$ and $\mathrm{succ}$ on $N$. Now
 $$
T(n) = (\Ctx_n, \Hom_n, \Ty_n, \Tm_n)
 $$
is a cwf modelling type theory with $n$ universe level variables. We have e g
 $$
\Ctx_n = \N^n \to \Ctx
 $$
that maps an assignment of external levels (as numbers) to the $n$ variables. $T$ can be extended to a functor.
 
\subsection{The system with constraints.}
If we then consider the system with constraints, we let the scwf $C(n)$ of constraints (in $n$ level variables) be the poset $\{0,1\}$, where 0 is the empty set and 1 is the singleton set. We interpret $\leq(l,l’) = 1$ iff $l = l’ : \Tm_\L(n)$ in the ucwf of levels.
 
If $\psi$ is a context in $C(n)$, that is, a sequence of level identities in $n$ level variables, then we can define a doubly indexed cwf $T(n, \psi)$ assigning external levels to the $n$ variables, that is, provided this assignment is valid in the sense that all the level identities in $\psi$ are satisfied.
 
Instead of starting with the ucwf of levels as natural numbers we can start with any $\sup/+$ lattice $L$.  We can still model the scwf of constraints in the same way and interpret $\leq(l,l’) = 1$ iff $ l = l’ : Tm(n)$.
 
It is part of the indexed cwf-structure that $T(L) \to T(L’)$ for any map $L’ \to L$ of ucwfs with sup+ structure.

\section{Summary}

It's important to give a high-level description. Some of the laws are simply derived from the fact that the level-substitution functor preserves all the structure of $\CwF_\Pi$. But level-substitution also commutes with all the four operator symbols for a universe ($\U_l, \Ta_l, \Pi^{l,l'},\U^{l}$ and with cumulativity $\Ta^m_l$.)

We can separate out all "background" laws, and focus on the laws that define the universe hierarchy, with and without cumulativity.

We note that in the case with cumulativity we have a ($\Pi$-closed) universe structure $\U_l, \Ta_l, \Pi^{l}$ for each term $l \in \tm_\L(n)$. Moreover, for each $l<m$ we have $\U^l_m \in \Tm(\Gamma,\U_{m})$ as in the paper. Moreover, %we should have  (or 
$\Ta^l_{m}(\U^l_m) = \U_l$)? We also need the cumulativity map $\Ta^l_m(a) \in \Tm(\Gamma,\U_l)$ for $a \in \Tm(\Gamma,\U_l)$ where $l  < m$. It satisfies the two equations found above.

In the presence of cumulativity, it may be better to have for each $l$ that $\U^l \in \Tm(\Gamma,\U_{l^+})$) and $\Ta_{l^+}(\U^l) = \U_l$. Think more about this.

Perhaps the natural thing for external tower of universe is to put $\U_l$ in $\U_{l^+}$ and also let the cumulativity map only take one step? While the level-indexed version suggests a potentially partially order hierarchy of universes, and then you want to use $l < m$. (Note that $l < m$ iff $l^+ = m$, so this is only one step.)

\appendix
\section{The generalized algebraic theory of cwfs with $\Pi$-types and a single universe closed under them}\label{sec:gatPiU}

\paragraph{The generalized algebraic theory of categories.}
\begin{tiny}
Sort symbols:
\begin{eqnarray*}
&\vdash& \Obj\\
\Delta, \Gamma : \Obj &\vdash& \Hom(\Delta,\Gamma)\\
\end{eqnarray*}

Operator symbols:
\begin{eqnarray*}
\Gamma : \Obj &\vdash& \id_\Gamma : \Hom(\Gamma,\Gamma)\\
\Xi,\Delta,\Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta) &\vdash&
\gamma \circ \delta : \Hom(\Xi,\Gamma)
\end{eqnarray*}

Equations:
\begin{eqnarray*}
\Delta, \Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma) &\vdash& \id_\Gamma \circ \gamma = \gamma : \Hom(\Delta,\Gamma)\\
\Delta, \Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma) &\vdash& \gamma \circ \id_\Delta = \gamma : \Hom(\Delta,\Gamma)\\
\Theta, \Xi,\Delta,\Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta), \xi : \Hom(\Theta,\Xi) &\vdash&
(\gamma \circ \delta) \circ \xi = \gamma \circ (\delta \circ \xi): \Hom(\Theta,\Gamma)
\end{eqnarray*}
Note: officially $\circ$ has five arguments rather than two.
\end{tiny}

\paragraph{Adding a family valued functor}

\begin{tiny}
Sort symbols ($\ctx = \Obj$):
\begin{eqnarray*}
\Gamma : \ctx &\vdash& \ty(\Gamma)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \tm(\Gamma,A)
\end{eqnarray*}

Operator symbols:
\begin{eqnarray*}
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma) &\vdash&
A[\gamma] : \ty(\Delta)\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Gamma,A) &\vdash&  a[\gamma] : \tm(\Delta,A[\gamma])
\end{eqnarray*}

Equations:
\begin{eqnarray*}
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& A[\id_\Gamma] = A : \ty(\Gamma)\\
\Gamma : \ctx, A:\ty(\Gamma), a:\tm(\Gamma,A) &\vdash& a[\id_\Gamma] = a : \tm(\Gamma,A)\\
\Xi,\Delta,\Gamma : \ctx, \delta : \Hom(\Xi,\Delta), \gamma : \Hom(\Delta,\Gamma),
A:\ty(\Gamma) &\vdash& A[\gamma\circ\delta] = A[\gamma][\delta]: \ty(\Xi)\\
\Xi,\Delta,\Gamma : \ctx, \delta : \Hom(\Xi,\Delta), \gamma : \Hom(\Delta,\Gamma),
A:\ty(\Gamma), a:\tm(\Gamma,A) &\vdash&
a[\gamma\circ\delta] = a[\gamma][\delta]: \tm(\Xi,A[\gamma\circ\delta])
\end{eqnarray*}
We have dropped some of the official arguments here too, and will do so in the following as well.
\end{tiny}


\paragraph{Adding a terminal object}

\begin{tiny}
%Sort symbols: none
Operator symbols:
\begin{eqnarray*}
&\vdash& 1 : \ctx\\
\Gamma : \ctx &\vdash& \tuple{}_\Gamma : \Hom(\Gamma,1)
\end{eqnarray*}

Equations:
\begin{eqnarray*}
 &\vdash& \id_1 = \tuple{}_1 : \Hom(1,1)\\
\Gamma,\Delta : \ctx, \gamma : \Hom(\Delta,\Gamma) &\vdash&
\tuple{}_\Gamma\circ\gamma = \tuple{}_\Delta : \Hom(\Delta,1)
\end{eqnarray*}
\end{tiny}


%(The latter two equations are better for term rewriting than the
%obvious single one expressing the uniqueness of $\tuple{}_\Gamma$.)

\paragraph{Adding context comprehension}

%No new sorts are added.
\begin{tiny}
Operator symbols:
\begin{eqnarray*}
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \Gamma\cext A : \ctx\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash& \tuple{\gamma,a} : \Hom(\Delta,\Gamma\cext A)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \p: \Hom(\Gamma\cext A,\Gamma)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \q: \tm(\Gamma\cext A,A[\p])
\end{eqnarray*}

Equations:
\begin{eqnarray*}
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash& \p\circ\tuple{\gamma,a} = \gamma : \Hom(\Delta,\Gamma)\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash& \q[\tuple{\gamma,a}] = a : \tm(\Delta,A[\gamma]) \\
\Gamma,\Delta,\Xi : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]), \delta : \Hom(\Xi,\Delta) &\vdash&
\tuple{\gamma,a} \circ \delta = \tuple{\gamma\circ\delta,a[\delta]} :
\Hom(\Xi,\Gamma\cext A) \\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash&
\id_{\Gamma\cext A} = \tuple{\p,\q} : \Hom(\Gamma\cext A,\Gamma\cext A)
\end{eqnarray*}
\end{tiny}


\paragraph{Adding $\Pi$-types}
%We add three operator symbols in addition to the operator symbols for cwfs in Section 5.2 and 5.3:
\begin{tiny}
Operator symbols:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), B : \ty(\Gamma.A)&\vdash& \Pi(A,B) : \ty(\Gamma)\\
\Gamma : \ctx, A : \ty(\Gamma), B : \ty(\Gamma.A), b : \tm(\Gamma.A, B) &\vdash& \lambda(b) : \tm(\Gamma,\Pi(A,B))\\
\Gamma : \ctx, A : \ty(\Gamma), B : \ty(\Gamma.A), c :  \tm(\Gamma,\Pi(A,B)), a : \tm(\Gamma, A) &\vdash& \app(c,a) : \tm(\Gamma, B[\tuple{\id,a}])
\end{eqnarray*}
Equations (omitting the context and type of the equalities):
 \begin{eqnarray*}
 \app(\lambda(b),a) &=& b[\tuple{\id,a}]\\
 \lambda(\app(c[\p],\q)) &=& c
 \end{eqnarray*}
 Equations for commutativity of operator symbols wrt substitution:
 \begin{eqnarray*}
\Pi(A,B)[ \gamma ] &=& \Pi(A [ \gamma ], B[ \gamma^+ ])\\
\lambda(b) [ \gamma ] &=& \lambda(b[\gamma^+ ])\\
\app(c,a) [ \gamma ] &=& \app(c[ \gamma ], a[ \gamma ] )
\end{eqnarray*}
where $\gamma^+ = \tuple{\gamma \circ \p, \q}$.
\end{tiny}


\paragraph{Adding a universe closed under $\Pi$}

\footnote{PD: for comparison only. Should we remove it?}
\begin{tiny}
Operator symbols:
\begin{eqnarray*}
\Gamma : \ctx &\vdash& \U_\Gamma : \ty(\Gamma)\\
\Gamma : \ctx, a : \tm(\Gamma,\U_\Gamma) &\vdash& {\Ta}(a) : \ty(\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,\U_\Gamma) \\
\Gamma : \ctx,
a : \tm(\Gamma,\U_\Gamma),
b :  \tm(\Gamma \cdot \Ta(a), \U_\Gamma))
&\vdash&
 \Pi^0(a,b) : \tm(\Gamma,\U_\Gamma)
\end{eqnarray*}
%$\U_\Gamma$ is the universe (a type) relative to the context $\Gamma$; $\Ta$ is the decoding operation mapping a term in the universe to the corresponding type; $\N^0$ is the code for $\N$ in the universe, and $\Pi^0$ forms codes for $\Pi$-types in the universe. (Note that we have dropped the context argument of $\Ta$ and $\Pi^0$.)

Equation:
\begin{eqnarray*}
%\Ta(\N^0_\Gamma) &=& \N_\Gamma\\
\Ta(\Pi^0(a,b)) &=& \Pi(\Ta(a),\Ta(b))
\end{eqnarray*}
 Equations for commutativity of operator symbols wrt substitution:
 \begin{eqnarray*}
{\U}_\Gamma [ \gamma ] &=& {\U}_\Delta\\
\Ta(a) [ \gamma ] &=& \Ta(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^0(a,b)[ \gamma ] &=& \Pi^0(a [ \gamma ], b[ \gamma^+ ])
\end{eqnarray*}
\end{tiny}
%where $\gamma^+ = \tuple{\gamma \circ \p, \q}$.
\bibliographystyle{plain}
\bibliography{../refs}
\end{document}
