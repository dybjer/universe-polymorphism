\documentclass[11pt,a4paper]{article}
%\ifx\pdfpageheight\undefined\PassOptionsToPackage{dvips}{graphicx}\else%
%\PassOptionsToPackage{pdftex}{graphicx}
\PassOptionsToPackage{pdftex}{color}
%\fi

%\usepackage{diagrams}

%\usepackage[all]{xy}
\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage{latexsym}
\usepackage{amssymb,amstext,amsmath,amsthm}
\usepackage{epsf}
\usepackage{epsfig}
\usepackage{float}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage{proof}
\usepackage{latexsym}
%\usepackage{mytheorems}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}{Lemma}[theorem]
\newtheorem{proposition}{Proposition}[theorem]
\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{remark}{Remark}[theorem]
\newtheorem{TODO}{TODO}[theorem]
\newtheorem{remark}{Remark}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{conjecture}{Conjecture}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}


%%%%%%%%%copied from SymmetryBook by Marc

% hyperref should be the package loaded last
\usepackage[backref=page,
            colorlinks,
            citecolor=linkcolor,
            linkcolor=linkcolor,
            urlcolor=linkcolor,
            unicode,
            pdfauthor={BCDE},
            pdftitle={Universes},
            pdfsubject={Mathematics},
            pdfkeywords={type theory, universes}]{hyperref}
% - except for cleveref!
\usepackage[capitalize,noabbrev]{cleveref}
%\usepackage{xifthen}
\usepackage{xcolor}
\definecolor{linkcolor}{rgb}{0,0,0.5}

%%%%%%%%%
\def\oge{\leavevmode\raise
.3ex\hbox{$\scriptscriptstyle\langle\!\langle\,$}}
\def\feg{\leavevmode\raise
.3ex\hbox{$\scriptscriptstyle\,\rangle\!\rangle$}}

%%%%%%%%%

\newcommand{\mkbox}[1]{\ensuremath{#1}}
\newcommand{\eraser}[1]{}

\newcommand{\conv}{=}
%\newcommand{\conv}{\mathsf{conv}}

\newcommand{\Id}{\mathsf{Id}}
\newcommand{\Eq}{\mathsf{Eq}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\NN}{\mathsf{N}}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\UU}{\mathsf{U}}
\newcommand{\JJ}{\mathsf{J}}
\newcommand{\AgdaLevel}{\mathsf{Level}}
\newcommand{\Level}{\mathsf{level}}
\newcommand{\Lev}{{\mathbb{L}}}
%\newcommand{\Type{\hbox{\sf Type}}
\newcommand{\ZERO}{\mathsf{0}}
\newcommand{\SUCC}{\mathsf{S}}
\newcommand{\valid}{\mathsf{valid}}
\newcommand{\level}{\mathsf{level}}
%\newcommand{\type}{\mathsf{type}}
\newcommand{\const}{\mathsf{const}}
\newcommand{\lam}[1]{{\langle}#1{\rangle}}
\newcommand{\mylam}[3]{\lambda_{#1:#2}#3}
\newcommand{\mypi}[3]{\Pi_{#1:#2}#3}
\newcommand{\Upi}[3]{\Pi^{#1}\,#2\,#3}
\newcommand{\mysig}[3]{\Sigma_{#1:#2}#3}
\newcommand{\Usig}[3]{\Sigma^{#1}\,#2\,#3}
\newcommand{\app}[2]{{#1\,#2}} % many applications still hard-coded with ~
\newcommand{\Sapp}[1]{\sapp{\SUCC}{#1}}
\newcommand{\sapp}[2]{{#1(#2)}} % strict app for Id, refl, J, natrec, not S (!)
\newcommand{\Idapp}[3]{\sapp{\Id}{#1,#2,#3}}
\newcommand{\Idnapp}[4]{\sapp{\Id^#4}{#1,#2,#3}}
\newcommand{\NRapp}[4]{\sapp{\RR}{#1,#2,#3,#4}}
\newcommand{\Rfapp}[2]{\sapp{\refl}{#1,#2}}
\newcommand{\Japp}[6]{\sapp{\JJ}{#1,#2,#3,#4,#5,#6}}
\newcommand{\RR}{\mathsf{R}}
%\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Group}{\mathsf{Group}}
%\newcommand{\El}{\mathsf{El}}
%\newcommand{\T}{\mathsf{T}}
%\newcommand{\Usuper}{\UU_{\mathrm{super}}}
%\newcommand{\Tsuper}{\T_{\mathrm{super}}}
%\newcommand{\idtoeq}{\mathsf{idtoeq}}
%\newcommand{\isEquiv}{\mathsf{isEquiv}}
%\newcommand{\Equiv}{\mathsf{Equiv}}
\newcommand{\isContr}{\mathsf{isContr}}
%\newcommand{\ua}{\mathsf{ua}}
%\newcommand{\UA}{\mathsf{UA}}
%\newcommand{\natrec}{\mathsf{natrec}}
%\newcommand{\set}[1]{\{#1\}}
%\newcommand{\sct}[1]{[\![#1]\!]}
%\newcommand{\refl}{\mathsf{refl}}
\newcommand{\ttt}[1]{\text{\tt #1}}

\newcommand{\Constraint}{\mathsf{Constraint}}
\newcommand{\Ordo}{\mathcal{O}}
\newcommand{\AFu}{\mathcal{A}}
\newcommand{\Fu}{\mathit{Fu}}

\newcommand{\Ctx}{\mathrm{Ctx}}
\newcommand{\Ty}{\mathrm{Ty}}
\newcommand{\Tm}{\mathrm{Tm}}
\newcommand{\op}{\mathrm{op}}

\newcommand{\CComega}{\mathrm{CC}^\omega}
\setlength{\oddsidemargin}{0in} % so, left margin is 1in
\setlength{\textwidth}{6.27in} % so, right margin is 1in
\setlength{\topmargin}{0in} % so, top margin is 1in
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{9.19in} % so, foot margin is 1.5in
\setlength{\footskip}{.8in}

% Definition of \placetitle
% Want to do an alternative which takes arguments
% for the names, authors etc.

\newcommand\myfrac[2]{
 \begin{array}{c}
 #1 \\
 \hline \hline
 #2
\end{array}}

\def\levelctx{\mathrm{lctx}}
\def\lhom{\mathrm{lhom}}
\def\psiab{\psi_{\alpha\beta}}

\newcommand*{\Scale}[2][4]{\scalebox{#1}{$#2$}}%
\newcommand*{\Resize}[2]{\resizebox{#1}{!}{$#2$}}

\newcommand{\II}{\mathbb{I}}
\newcommand{\refl}{\mathsf{r}}
\newcommand{\MB}[1]{{\color{red}{#1}}}
%\newcommand{\mkbox}[1]{\ensuremath{#1}}


%\newcommand{\Id}{\mathsf{Id}}
%\newcommand{\conv}{=}
%\newcommand{\conv}{\mathsf{conv}}
%\newcommand{\lam}[2]{{\langle}#1{\rangle}#2}
\def\NN{\mathsf{N}}
\def\UU{\mathsf{U}}
\def\JJ{\mathsf{J}}
%\def\Type{\hbox{\sf Type}}
\def\ZERO{\mathsf{0}}
\def\SUCC{\mathsf{S}}

\newcommand{\RawCtx}{{\tt Ctx}}
\newcommand{\RawSub}{{\tt Sub}}
\newcommand{\RawTy}{{\tt Ty}}
\newcommand{\RawTm}{{\tt Tm}}
\newcommand{\type}{\mathsf{type}}
\newcommand{\N}{\mathsf{N}}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\El}{\mathsf{El}}
%\newcommand{\U}{\mathsf{U}} clashes with def's in new packages
\newcommand{\T}{\mathsf{T}}
\newcommand{\Usuper}{\UU_{\mathrm{super}}}
\newcommand{\Tsuper}{\T_{\mathrm{super}}}
%\newcommand{\conv}{\mathrm{conv}}
\newcommand{\idtoeq}{\mathsf{idtoeq}}
\newcommand{\isEquiv}{\mathsf{isEquiv}}
\newcommand{\ua}{\mathsf{ua}}
\newcommand{\UA}{\mathsf{UA}}
\def\Constraint{\mathsf{Constraint}}
\def\Ordo{\mathcal{O}}
\def\Pihat{\Pi}

\def\Ctx{\mathrm{ctx}}
\def\Ty{\mathrm{ty}}
\def\Tm{\mathrm{tm}}
\def\Obj{\mathrm{obj}}
\def\Hom{\mathrm{hom}}
\def\id{\mathrm{id}}
\def\lHom{\mathrm{lhom}}
\def\lctx{\mathrm{lctx}}
\def\lty{\mathrm{level}}
\def\ltm{\mathrm{ltm}}
\def\ltmq{\mathrm{ltmq}}
\def\leq{\mathrm{leq}}
\def\lrefl{\mathrm{lr}}
\def\lp{\mathrm{lp}}
\def\lq{\mathrm{lq}}
\def\s{\mathrm{s}}
\def\lid{\mathrm{lid}}
\def\cctx{\mathrm{cctx}}
\def\cty{\mathrm{cty}}
\def\ctm{\mathrm{ctm}}
\def\cid{\mathrm{cid}}
\def\cp{\mathrm{cp}}
\def\cq{\mathrm{cq}}
\def\chom{\mathrm{chom}}

\newcommand{\ctx}{\mathrm{ctx}}
\newcommand{\sub}{\mathrm{sub}}
\newcommand{\ty}{\mathrm{ty}}
\newcommand{\tm}{\mathrm{tm}}
%\newcommand{\hom}{\mathrm{hom}}
\newcommand{\tuple}[1]{\langle #1 \rangle}
\def\CComega{\mathrm{CC}^\omega}
\newcommand{\cext}{.}
\def\p{\mathrm{p}}
\def\q{\mathrm{q}}
\def\app{\mathsf{app}}
\def\U{\mathsf{U}}
\def\T{\mathcal{T}}
\newcommand{\Ta}{\mathrm{T}}
\newcommand{\ta}{\mathrm{t}}

\newcommand{\natrec}{\mathsf{natrec}}
%\rightfooter{}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\sct}[1]{[\![#1]\!]}
\def\R{\mathcal{R}}

\def\L{{\mathcal{L}}}
\def\F{\mathcal{C}}
\def\CwF{\mathrm{CwF}}
\def\Fam{\mathrm{Fam}}
\def\SCwF{\mathrm{SCwF}}
\def\C{\mathcal{C}}
\def\W{\mathsf{W}}

%\def\TTUP{\mathbf{MLTT^{\UU_l}}}
\def\Sigmaext{\Sigma^\mathrm{ext}}
\def\Sigmaint{\Sigma^\mathrm{int}}
\def\TText{\mathbf{TT}^\mathrm{ext}}
\def\TTint{\mathbf{TT}^\mathrm{int}}

\begin{document}

\title{Type Theory
with Explicit Universe Polymorphism\\ as a Generalized Algebraic Theory
%\footnote{Alternative title: Categorical Models of Type Theory or Type Theory
%with Explicit Universe PolymorphismGeneralised Algebraic Theories of Type Theories with Explicit Universe Polymorphism?}
}

\author{Marc Bezem, Thierry Coquand, Peter Dybjer, Mart\'{\i}n Escard\'o}

\date{(draft)}
\maketitle

\begin{abstract}
We present generalized algebraic theories corresponding to slightly modified versions of some of the type theories in our paper 
{\em Type Theory with Explicit Universe Polymorphism}. We first consider Martin-Löf type theory with an external tower of universes. Its models are categories with families with extra structure for the small type formers and the tower of universes. We then consider Martin-Löf type theory with explicit universe polymorphism, where we have universe level judgments and internally indexed universes. Its models are level-indexed categories with families, again with appropriate extra structure.
% (* Finally, we extend the theory with universe level constraints. Its models are doubly indexed categories with families with extra structure. *) 
In this way we get abstract syntax definitions of our theories as initial models of certain indexed categories with families with extra structure. We thus abstract from details of the grammar and inference rules of the type theories and highlight their high-level structure.
\end{abstract}

\section{Introduction}

The aim of Voevodsky's  {\em Initiality Conjecture project} is to define a general class of dependent type theories and to develop generic metatheory for theories in this class. We quote from the introduction of an extended abstract where Voevodsky \cite{voevodsky:initiality} motivates his project:
\begin{quotation}
The first few steps in all approaches to the set-theoretic semantics of dependent
type theories remain insuﬃciently understood. The constructions which have been
worked out in detail in the case of a few particular type systems by dedicated authors
are being extended to the wide variety of type systems under consideration today by
analogy. This is not acceptable in mathematics. Instead we should be able to obtain
the required results for new type systems by specialization of general theorems and
constructions formulated for abstract objects the instances of which combine together
to produce a given type system.
\end{quotation}
In particular, one would like a generic construction showing that theories in this class are initial in corresponding categories of models. We quote Voevodsky \cite{voevodsky:initiality} again:
\begin{quotation}
A crucial component of this approach is the expected result that for a particular
class of inference rules the term model is an initial object in the category of models.
This is known as the Initiality Conjecture. In the case of the pure Calculus of
Constructions with a “decorated” application operation this conjecture was proved in
1988 by Thomas Streicher \cite{streicher:thesis}. The problem of finding an appropriate formulation
of the general version of the conjecture and of proving this general version will be the
subject of future work.
\end{quotation}
On the surface such initiality proofs may seem straightforward, but they depend on subtle details in the formulation of grammar and inference rules. This is why Voevodsky insisted on calling such theorems ``conjectures'' until proven rigorously and ideally implemented in a proof assistant.

An example of an implemented proof is Brunerie and de Boer's \cite{Brunerie:initiality,deBoer:lic} proof in Agda that a version of Martin-Löf type theory with an external tower of universes is an initial contextual category \cite{cartmell:phd,cartmell:apal} with appropriate extra structure. %Theversion of type theory with de Bruijn variables and implicit substitutions. 

A possible approach to Voevodsky's project is based on Cartmell's notion of a {\em generalized algebraic theory (gat)} \cite{cartmell:phd,cartmell:apal}. The most basic rules of dependent type theory can be captured by the gat of categories with families (cwfs) \cite{dybjer:torino}. Moreover, as shown in our paper {\em On generalized algebraic theories and categories with families} \cite{bezem:hofmann} there is a generic construction of an initial model of an arbitrary finitary gat. 
Maybe an approach to a general notion of dependent type theory is as an initial model of an extension of the gat of cwfs? The reason for focusing on the gat of cwfs is that it occupies an intermediate place between dependent type theories defined by grammar and inference rules and notions of model based on more mainstream categorical constructions. In particular, the gat of cwfs resembles Martin-Löf's substitution calculus for dependent type theory \cite{martinlof:gbg92,tasistro:lic}.

Furthermore, as shown by Castellan, Clairambault, and Dybjer \cite{castellan:lambek}, by considering simply typed cwfs (scwfs) and unityped cwfs (ucwfs) we can also capture various simply typed and untyped logical systems as gats and thus widening the scope of {\em uniform categorical logic} based on gats and cwfs. \MB{Cf. logical frameworks?}

In this article we introduce the notion of an indexed cwf, that is, a base category $\C$ and a cwf-valued presheaf
$$
P : \C^\op \to \CwF
$$
We shall show that a cwf indexed by (the base category of) a ucwf $\L$ of universe levels (with suitable extra structure) forms a suitable notion of model of Martin-Löf type theory with explicit universe polymorphism along the lines of our paper {\em Type Theory with Explicit Universe Polymorphism} \cite{BezemCDE22}. The benefit is twofold. First, it is a case study for our approach to the Initiality Conjecture project. Type theory with explicit universe polymorphism is an example of a dependent type theory, and we show that it can be captured by a gat based on a variation of cwfs. Second, it provides an alternative view of our syntactic type theory with explicit universe polymorphism. We argue that a type theory presented by a gat of cwfs is a higher-level and more ``objective'' notion than one presented by grammar and inference rules. This is because the gat only records the ``important" rules and highlights categorical structure. When building initial models in terms of grammar and inference rules we also need to include various bookkeeping rules, such as general rules of equality reasoning, and there will be a multitude of options. Without a common high level abstraction it will be hard to prove the equivalence between different options and to claim that there is a unique abstract notion. 

We also outline how modified versions of the theories presented in Bezem et al  \cite{BezemCDE22} form initial models of the gats. 
%Rigorous proofs are however beyond the scope of this paper. 

There are other important examples of gats for logical systems. For example, untyped predicate logic can be captured by ucwf-indexed scwfs with extra structure for the logical constants. Moreover, typed predicate logic can be captured by scwf-indexed scwfs, and dependently typed predicate logic by cwf-indexed scwfs, both with suitable extra structure for type formers and logical constants. Various versions of dependently typed predicate logic have been studied by Makkai \cite{makkai:folds}, Gambino and Aczel \cite{gambino-aczel}, Belo \cite{belo}, and Palmgren \cite{Palmgren19}.

\paragraph{Universe polymorphism.} We refer to our previous paper on explicit universe polymorphism \cite{BezemCDE22} for a presentation of the inference rules of Martin-Löf type theory with explicit universe polymorphism. There the reader can also find motivation and examples. Here we only give a brief overview. 

An implicit form of universe polymorphism in dependent type theory was introduced by Huet \cite{Huet87} and is an essential feature of the proof assistant Coq (Rocq) \cite{coq:general}. Alternatively, Agda \cite{agda-wiki} and Lean \cite{moura:lean} employ versions of universe polymorphism, where universe levels are explicitly declared. 

In our paper we followed Courant's approach \cite{Courant02} to explicit universe polymorphism and introduced special universe level {\em judgments}:
$$
l\ \level
\hspace{5em}
l = l'
$$
in addition to the usual judgment forms of type theory. Moreover, all judgments may depend on universe level variables as well as ordinary variables declared in the context. We emphasized that, unlike in Agda, universe levels do {\em not} form a {\em type} in our setting, and instead we added the above judgment forms. Nevertheless, we added level-indexed products $[\alpha]A$ of a families of types $A\ (\alpha\ \level)$ to our theory.

Furthermore, we presented an extension where equational constraints between universe levels can be declared \cite{BezemCDE22}, building on a proposal by Voevodsky \cite{VV}. This extension can also be described by a gat, but we postpone this topic to a forthcoming paper.

\paragraph{Plan of the paper.} In Section 2 we present the infinitary gat $\Sigmaext$ of cwfs with extra structure for the type formers and an externally indexed tower of universes. We consider both cumulative and non-cumulative universes. In Section 3 we present the finitary gat $\Sigmaint$ of ucwf-indexed cwfs with extra structure for the type formers and an internally indexed tower of universes. An interesting feature here is the need for an extra sort of level equality needed for expressing equational constraints.
%(* In Section 4 we present the generalized algebraic theory of cwfs with extra structure doubly indexed by levels and level constraints *). (* In Section 5 we discuss models *).
In Section 4 we discuss related and further research. There is also an appendix with operator symbols and equations for level-indexed type theory that were not included in Section 3.

\paragraph{Dedication.} We dedicate this article to professor Stefano Berardi, the University of Torino, on the occasion of his 60th birthday. Stefano is a valued friend, colleague, and coworker, who spent the winter and spring 1993 - 94 in the type theory group in Göteborg. He has made fundamental contributions to type theory and constructivity and in particular to the understanding of the constructive content of classical logic and the constructive analysis of impredicativity.

\section{Type theory with an external tower of universes}

\subsection{The gat of cwfs} A cwf consists of a base category $\C$ of contexts and context morphisms (substitutions), a family-valued presheaf
$$
T : \C^\op \to \Fam
$$
and a notion of context comprehension. Here $\Fam$ is the category of indexed families of sets $(A,B)$, where $A$ is the index set and $B$ is a family of sets indexed by $A$. The object part of the presheaf $T$ maps a context to the family of terms indexed by a type. The arrow part represents substitution in types and terms. The reader is referred to Dybjer \cite{dybjer:torino}, Hofmann \cite{hofmann:cambridge}, and Castellan et al \cite{castellan:lambek} for a full definition and further information about cwfs.

The gat of cwfs with extra structure for $\Pi$-types, a notion of model of Martin-Löf type theory with $\Pi$-types, was presented by Dybjer \cite{dybjer:torino}. The extra operator symbols and equations needed for the natural number type and one universe can for example be found in Bezem et al \cite{bezem:hofmann}. We will use the same notation for gats as in the latter paper. 

\paragraph{Sort symbols.}
The gat of cwfs has four sort symbols:
\begin{eqnarray*}
&\vdash& \ctx\\
\Delta, \Gamma : \ctx&\vdash& \hom(\Delta,\Gamma)\\
\Gamma : \ctx&\vdash& \ty(\Gamma)\\
\Gamma : \ctx, A : \ty(\Gamma)&\vdash& \tm(\Gamma,A)
\end{eqnarray*}
corresponding to the objects and morphisms of the category of contexts, and the family of terms indexed by types in a given context, respectively. The notation states that $\ctx$ is a constant sort symbol, that $\hom$ is a binary sort symbol depending on arguments $\Delta, \Gamma : \ctx$, that $\ty$ is a unary sort symbol depending on the argument $\Gamma : \ctx$, and $\tm$ is a binary sort symbol depending on arguments $\Gamma : \ctx, A : \ty(\Gamma)$.

\paragraph{Operator symbols.}
Moreover, the gat of cwfs has operator symbols for the basic operations of cwfs (identity and composition of context morphisms, substitution in types and terms, empty context and context morphism, context extension and context morphism extension, projection morphism, last variable term)\footnote{MB: should we separate them into four groups: structure for the base category, for the arrow part of the family valued functor, for the terminal object, and for context comprehension?}: 
\begin{eqnarray*}
\Gamma : \ctx &\vdash& \id_{\Gamma} : \Hom(\Gamma,\Gamma)\\
\Xi,\Delta,\Gamma : \ctx, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta) &\vdash&
\gamma \circ \delta : \Hom(\Xi,\Gamma)\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma) &\vdash&
A[\gamma] : \ty(\Delta)\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Gamma,A) &\vdash&  a[\gamma] : \tm(\Delta,A[\gamma])\\
&\vdash& 1 : \ctx\\
\Gamma : \ctx &\vdash& \tuple{}_\Gamma : \Hom(\Gamma,1)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \Gamma\cext A : \ctx\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash& \tuple{\gamma,a} : \Hom(\Delta,\Gamma\cext A)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \p_{\Gamma,A}: \Hom(\Gamma\cext A,\Gamma)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \q_{\Gamma,A}: \tm(\Gamma\cext A,A[\p])
\end{eqnarray*}
The first line states that identity is a unary operator symbol with argument $\Gamma : \ctx$. The second line states that $\circ$ is a binary operator symbol with five arguments $\Xi,\Delta,\Gamma : \ctx, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta)$ and result sort $\Hom(\Xi,\Gamma)$. Note that only two of the five official arguments are explicit. To alleviate notation, we often suppress arguments of operator symbols. Note also that we overload notation for type and term substitution $A[\gamma]$ and $a[\gamma]$. Moreover, we sometimes drop further arguments and write $\id, \tuple{},\p,\q$ without the arguments in index position.

\paragraph{Equations.}
The gat of cwfs has 13 equations. We illustrate the notation by showing one of the laws for identity morphisms:\begin{eqnarray*}
\Delta, \Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma) &\vdash& \id_\Gamma \circ \gamma = \gamma : \Hom(\Delta,\Gamma)
%\\
%\Delta, \Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma) &\vdash& \gamma \circ \id_\Delta = \gamma : \Hom(\Delta,\Gamma)\\
%\Theta, \Xi,\Delta,\Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta), \xi : \Hom(\Theta,\Xi) &\vdash&
%(\gamma \circ \delta) \circ \xi = \gamma \circ (\delta \circ \xi): \Hom(\Theta,\Gamma)
\end{eqnarray*}
In the official notation both argument and result types are explicit. However, to alleviate notation we often drop them and only write:
\begin{eqnarray*}
\id_\Gamma \circ \gamma = \gamma
\end{eqnarray*}
However, there are specific cases where we need the official notation. Assume that we add an operator symbol for the identity type former $\Id$ in Martin-Löf type theory:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), a, a' : \tm(\Gamma, A) &\vdash \Id_{\Gamma,A}(a,a'): \ty(\Gamma)
\end{eqnarray*}
In extensional Martin-Löf type theory \cite{martinlof:hannover} we have the rule of equality reflection. This can be captured by an equation in gats:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), a, a' : \tm(\Gamma, A),p :  \tm(\Gamma,\Id_{\Gamma,A}(a,a'))&\vdash& a = a' : \tm(\Gamma,A)
\end{eqnarray*}
Note that the variable $p$ does not occur on the right hand side.
However, it is a very important variable expressing
the condition under which $a=a'$ holds and must not be omitted.
%We will meet a similar case for reflection on equality on level terms.

We refer to Bezem et al \cite{bezem:hofmann} for the remaining cwf-equations. The reader may also consult the appendix where the equations for level-indexed cwfs are displayed. 


\subsection{The gat of cwfs with an external tower of universes}
In Bezem et al \cite{BezemCDE22} we began by displaying the inference rules for Martin-Löf type theory with an external tower of universes $\UU_l$, where $l \in \N$ is an external natural number. Here we show the operator symbols and equations for the corresponding gat.

We assume that we already have defined the gat of cwfs with the extra structure for the standard small type formers $\Pi, \Sigma, \N_0, \N_1, \N_2, \N, \W$, and $\Id$, and we wish to define a tower of universes closed under those. To save space, we shall however only display the operator symbols and equations for closure under $\Pi$-types, since it is straightforward to add similar operator symbols for closure under the other small type formers. We shall use the same convention throughout the paper.

\paragraph{Operator symbols.}
The operator symbol for $\Pi$-types is
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), B : \ty(\Gamma.A) &\vdash& \Pi(A,B) : \ty(\Gamma)
\end{eqnarray*}
and refer to Bezem et al \cite{bezem:hofmann} for the operator symbols for abstraction and application, equations for the $\beta$ and $\eta$ rule, and equations expressing that $\Pi$, abstraction, and application commute with term substitution. We also refer to the appendix for the level-indexed version.

In the gat for externally indexed universes we have the following families of operator symbols (the universes $\UU_l$, the decoding maps $\Ta_l$, codes for $\Pi$, and codes for $\UU_l$ in $\UU_m$ for $l, l' , m \in \NN$ with $l < m$):
\begin{eqnarray*}
\Gamma : \ctx &\vdash& (\U_{l})_\Gamma : \ty(\Gamma)\\
\Gamma : \ctx, a : \tm(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta_{l}}(a) : \ty(\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,(\U_0)_\Gamma) \\
\Gamma : \ctx,
a : \tm(\Gamma,(\U_{l})_\Gamma),
b :  \tm(\Gamma . \Ta_{l}(a), (\U_{l'})_\Gamma)
&\vdash&
 \Pihat^{l,l'}(a,b) : \tm(\Gamma,(\U_{l \vee l'})_\Gamma)\\
 \Gamma : \ctx&\vdash&(\UU^m_l)_\Gamma: \tm(\Gamma,(\UU_{m})_\Gamma)
\end{eqnarray*}
Note that codes for $\Pi$ are doubly indexed and $l \vee l' = \max(l,l')$.
We have again left some arguments to operator symbols implicit. For example, the decoding operators $\Ta_l$ are binary operators with official notation $\Ta_l(\Gamma,a)$. However, in the notation above we omit $\Gamma$ and write $\Ta_l(a)$.

\paragraph{Equations.}
We have the following decoding equations:
\begin{eqnarray*}
%\Ta(\N^0_\Gamma) &=& \N_\Gamma\\
\Ta_{l \vee l'}(\Pi^{l,l'}(a,b)) &=& \Pi(\Ta_l(a),\Ta_{l'}(b))\\
\Ta_{m}((\UU^m_l)_\Gamma) &=& (\UU_l)_\Gamma
\end{eqnarray*}
Moreover, the operator symbols commute with term substitution: 
\begin{eqnarray*}
(\U_l)_\Gamma [ \gamma ] &=& (\U_l)_\Delta\\
\Ta_l(a) [ \gamma ] &=& \Ta_l(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^{l,l'}(a,b)[ \gamma ] &=& \Pi^{l,l'}(a [ \gamma ], b[ \gamma^\dagger ])\\
(\UU^m_l)_\Gamma[ \gamma ] &=&(\UU^m_l)_\Delta
\end{eqnarray*}
where $\gamma : \Hom(\Delta,\Gamma)$ and $\gamma^\dagger = \langle \gamma \circ \p_{\Delta,\Ta_l(a[\gamma])}, \q_{\Delta,\Ta_l(a[\gamma])}\rangle : \Hom(\Delta.\Ta_l(a[\gamma]),\Gamma.\Ta_l(a))$.
%\paragraph{Adding cumulativity.}

If we want a cumulative tower of universes we add operator symbols that lift elements in the $l$th universe to the $m$th universe for $l < m$:
\begin{eqnarray*}
\Gamma : \ctx, a : \tm(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta^m_{l}}(a) : \tm(\Gamma,(\U_{m})_\Gamma))
\end{eqnarray*}
In the presence of cumulativity it suffices that codes for $\Pi$ have one superscript rather than two:
\begin{eqnarray*}
\Gamma : \ctx,
a : \tm(\Gamma,(\U_{l})_\Gamma),
b :  \tm(\Gamma \cdot \Ta_{l}(a), (\U_{l})_\Gamma))
&\vdash&
 \Pihat^{l}(a,b) : \tm(\Gamma,(\U_{l})_\Gamma)
 \end{eqnarray*}
 We omit the equations for the cumulative case, see instead the cumulative case for level-indexing.
 This concludes the presentation $\Sigmaext$ of a gat for cwfs with small type formers and an external tower of universes.

\subsection{Syntax and inference rules as an initial model}\label{initiality-external}

\paragraph{A generic construction based on explicit substitutions.} In our paper {\em On generalized algebraic theories and categories with families} \cite{bezem:hofmann} we define the notion of a correct {\em presentation} $\Sigma$ (a finite list of sort symbols, operator symbols, and equations) of a gat and the associated category of models $\CwF_\Sigma$ of cwfs with a $\Sigma$-structure. We then construct an initial object $\T_\Sigma$ in $\CwF_\Sigma$ as a type theory defined in terms of a grammar and inference rules. This type theory is a calculus of explicit substitutions based on untyped cwf-combinators and untyped versions of the operator symbols. 

In the current section we have presented the {\em infinitary} gat $\Sigmaext$ of cwfs with extra structure for the small type formers and a tower of universes. However, the above construction of an initial model applies only to {\em finitary} gats. Nevertheless, as explained in Section 5.7 of Bezem et al  \cite{bezem:hofmann}, we can generalize our construction to some non-finitely presented gats. If we have an increasing sequence of signatures $\Sigma_n$ we can build the initial model $\T_\Sigma$ of their union $\Sigma$ in stages. In this way we can build an initial model of $\Sigmaext$ as a union of $\Sigma_n$ -- the gats of cwfs with extra structure for the small type formers and a truncated tower of $n$ universes. 

We remark that when $\Sigma$ presents cwfs (with extra structure for $\Sigma$), $\CwF_\Sigma$ is the category of cwfs with an {\em internal} cwf (with extra structure) and $\T_\Sigma$ is a cwf with an internal cwf (with extra structure). Since any gat is built on top of a basic framework of dependent types, its models are cwfs with extra structure. In particular, when $\Sigma$ presents the gat of cwfs, the extra structure is that of an internal cwf.

%As already mentioned, the grammar and inference rules for an initial model can be obtained by a general construction for finitary gats \cite{bezem:hofmann} and this construction can be extended to some non-finitary gats \cite{bezem:hofmann}
% The recipe is to build the judgment structure of the theory from the sort symbols of the gat, and the syntax of raw terms, types, contexts and context morphisms from untyped versions of the cwf-combinators and the operator symbols of the gat. Then one defines a system of inference rules from the typings of the cwf-combinators and the operator symbols of the gat. This yields an explicit substitution calculus for dependent type theory quite similar to Martin-Löf's \cite{martinlof:gbg92,tasistro:lic} but with named variables replaced by projections of the form $\q[\p^n]$. 

\paragraph{Constructions based on implicit substitutions.} 
Can we construct an initial object in $\CwF_\Sigma$ based on the type theory with an external tower of universes presented in Bezem et al \cite{BezemCDE22}? This theory is a more standard version of Martin-Löf type theory with implicit substitutions, where substitution is an operation defined by induction on types and terms. As we state in that paper, to prove initiality we would need to modify our syntax and work with decorated terms; for example, we need to decorate application with type information. In this way we expect to be able to construct an initial cwf with extra structure for the small type formers and the tower of universes. However, it would take extra work to construct an initial object in $\CwF_\Sigma$, which requires us to construct the cwf with extra structure that is internal to cwfs, as explained above.

The construction of an initial cwf with extra structure for the small type formers and the tower of universes based on the theory in Bezem et al \cite{BezemCDE22} would be similar to Brunerie and de Boer's \cite{Brunerie:initiality,deBoer:lic} construction of an initial contextual category with extra structure for a slightly different version of Martin-Löf type theory with an external tower of universes. Both theories are more standard version of Martin-Löf type theory with implicit substitutions, except that terms such as applications are decorated with type information. The rules for universes are also different. Brunerie and de Boer just have the rule $\UU_l : \UU_{l+1}$ and only consider the non-cumulative case, while we have $\UU_l^m$ for $\UU_l$ in any larger universe $\UU_m$ and consider both the non-cumulative and cumulative cases.
Moreover, their universes are \`a la Russell, while we consider both \`a la Tarski and \`a la Russell. Inevitably, there are other differences between the two systems of inference rules but it would lead too far give a complete account. On the semantic side their notion of model is that of a contextual category (with extra structure) while ours is a cwf (with extra structure). These are closely related notions, taking into account that initial cwfs are contextual in the sense that each context has a length \cite{ClairambaultD11,ClairambaultD14}. We finally remark that several equivalences and embeddings between categorical notions of models including cwfs have been implemented in UniMath by Ahrens, Lumsdaine, and Voevodsky \cite{AhrensLV18}.


%\paragraph{Our version of Martin-Löf type theory with an external tower of universes.} Like Brunerie and de Boer's version, ours is based on a more standard version of Martin-Löf type theory with implicit substitutions. However, while they consider Russell-style universes we show both Tarski-style and Russell-style ones. Note that the Russell versus Tarski formulations are only different options for the syntactic type theories, but gats are intrinsically Tarski-style since we have an operator $\Ta$ that converts a term to a type.
%
%(* In the middle of revising this section *)
%Let us now consider the type theory with an external tower of universes presented in Bezem et al \cite{BezemCDE22}. First note that building an initial object in $\CwF_\Sigma$ as a cwf with an internal cwf with extra structure would need a more complex construction. aCould we prove that this is an initial cwf with extra structure for the small type formers and a tower of universes? (Note that building an initial object in $\T_\Sigma$ as a cwf with an internal cwf with extra structure would need a more complex construction.)
%

%Let us now compare our construction to Brunerie and de Boer \cite{Brunerie:initiality,deBoer:lic} that Martin-Löf type theory with an external tower of universes is an initial contextual category with appropriate extra structure for the type formers.
%On the syntactic side their version of Martin-Löf type theory is more traditional with implicit substitutions, that is, substitution is not a term constructor, but an operation defined by induction on the structure of terms. Moreover, their rules for universes are not the same as ours. They just have the rule $\UU_l : \UU_{l+1}$ and only consider the non-cumulative case, while we have $\UU_l^m$ for $\UU_l$ in any larger universe $\UU_m$ and consider both the non-cumulative and cumulative cases. 
%
%To adapt their construction to yield a model of our gat we would first need to replace their contextual categories by cwfs. We expect that the implementation could be adapted accordingly, since initial cwfs are contextual. (We also remark that several equivalences and embeddings between categorical notions of models including cwfs have been implemented in UniMath by Ahrens, Lumsdaine, and Voevodsky \cite{AhrensLV18}.)
%Moreover, Brunerie and de Boer's rules for universes are not the same as ours. They just have the rule $\UU_l : \UU_{l+1}$ and only consider the non-cumulative case, while we have $\UU_l^m$ for $\UU_l$ in any larger universe $\UU_m$ and consider both the non-cumulative and cumulative cases. We expect that it would be a modest amount of effort to adapt their construction to our universes.
%
%There are also some differences between Brunerie and de Boer's version of Martin-Löf type theory and ours \cite{BezemCDE22} on the syntactic side. Firstly, they work with decorated terms following Streicher \cite{streicher:thesis} and we would need to decorate ours too. Another difference is that they have a Russell-style tower while we have a Tarski-style one. Note that the Russell versus Tarski formulations are only different options for the syntactic type theories, but gats are intrinsically Tarski-style since we have an operator $\Ta$ that converts a term to a type.

\subsection{Internalization (* Remove? *)}
One might be tempted to internalize the externally indexed tower of universes by indexing universes by internal natural numbers: 
$$\Gamma : \ctx, l : \tm(\Gamma,\N) \vdash (\UU_l)_\Gamma : \ty(\Gamma)$$
%However, this would mean that we could build large types such as $\Pi l : \N.\U_l$ and $\Sigma l : \N.\U_l$ which increase the proof theoretic strength of type theory. 
Note that $l$ here depends on variables in the context $\Gamma$. 
A more cautious alternative would be to only
allow universes indexed by constant internal natural numbers:
$$ l : \tm(1,\N), \Gamma : \ctx \vdash \UU_l : \ty(\Gamma)$$

Similarly, Agda has a type $\Level$ of universe levels with a level 0 and a next level operation $(-)^+$, but also has an operation $\vee$ on levels. Moreover, levels satisfy the same equality judgments as our theory.

What is the best argument for not indexing by natural numbers?? Parametricity??

\section{Level-indexed type theory}

\subsection{The ucwf of levels} As already mentioned in the introduction, in Bezem et al \cite{BezemCDE22} we added special universe level {\em judgments}:
$$
l\ \level
\hspace{5em}
l = l'
$$
to the usual judgment forms of Martin-Löf type theory. Moreover, universe level variables as well as ordinary term variables can be declared in a context. As in Agda, we have a next level operation $(-)^+$ and an operation $\vee$ for join of levels. However, as in Bezem et al \cite{BezemCDE22}, we have no level 0 for the first universe. It follows that all universes are polymorphic.
Levels form an upper semilattice with respect to $\vee$ and $(-)^+$ is an inflationary operation, see below.

%\footnote{
%We shall now show the gat corresponding to the our theory where we do not have a type of levels but level judgments \cite{BezemCDE22}.
%This gat consists of the following parts:
%\begin{itemize}
%\item the ucwf of levels
%\item the ucwf-indexed cwf with $\Pi$-types and level-indexed universes
%\begin{itemize}
%\item the object part has sort symbols for level-indexed judgments and operator symbols for ...
%\item the arrow part has operator symbols for level-substitutions in all sorts of the cwfs that preserve all the structure.
%\end{itemize}
%\end{itemize}
%}
\paragraph{Sort symbols.} Levels can be organized as a ucwf. We have the following sort symbols:
\begin{eqnarray*}
&\vdash& \lctx\\
m, n : \lctx &\vdash& \lHom(m,n)\\
m : \lctx &\vdash& \ltm(m)
\end{eqnarray*}
standing for level context, level context morphism (substitution), and level term.
Since ucwfs are cwfs with only one type, we do not need a sort symbol for level types. 

\paragraph{Operator symbols.} The operator symbols for ucwfs are simplified versions of those for cwfs, where all dependence on types is removed:
%\footnote{We use  $\sigma,\tau$ for level substitutions.}
%\footnote{In other places we use $\lp$ and $\lq$. Same issue with $\cp$ and $\cq$.}
\begin{eqnarray*}
m : \lctx &\vdash& \lid_m : \lhom(m,m)\\
m, n, p : \lctx, \sigma : \lhom(n,p), \tau : \lhom(m,n) &\vdash&
\sigma \circ \tau : \lhom(m,p)\\
%&&\\
m,n: \lctx, \sigma : \lhom(n,m), l :\ltm(m) &\vdash&  l[\sigma] : \ltm(n)\\
%&&\\
&\vdash& 0 : \lctx\\
m : \lctx &\vdash& \tuple{}_m : \lhom(m,0)\\
%&&\\
m : \lctx &\vdash& \s(m) : \lctx\\
m,n : \lctx, \sigma : \lhom(n,m), l:\ltm(n) &\vdash& \tuple{\sigma,l} : \lhom(n,\s(m))\\
m : \lctx &\vdash& \lp_m: \lhom(\s(m),m)\\
m : \lctx &\vdash& \lq_m: \ltm(\s(m))
\end{eqnarray*}
Note that we no longer need an operator symbol for substitution in types but only in level terms. We also change the notation to suggest that these are operations on levels. For example, we use $\sigma$ and $\tau$ to range over level substitutions to distinguish them from term substitutions $\gamma$ and $\delta$. However, we keep the notation $\circ$ for composition of level substitutions, $l[\sigma]$ for level substitution in level terms, $\tuple{}_m$ for the empty level context morphism and $\tuple{\sigma,l}$ for context morphism extension. The notation for level contexts suggests that we have an initial ucwf where $n : \lctx$ is a natural number that records the number of available level variables. Thus $0 : \lctx$ is the terminal object in the ucwf.

The ucwf of levels also has operator symbols for next level and for the join of two levels:
\begin{eqnarray*}
m : \lctx, l : \ltm(m) &\vdash& l^+ : \ltm(m)\\
m : \lctx, l,l' : \ltm(m) &\vdash& l \vee l' : \ltm(m)
\end{eqnarray*}
%\end{tiny}

%\begin{tiny}
\paragraph{Equations.} 
We also have all the ucwf-equations, but we do not display them here. These are the cwf-equations (see Dybjer \cite{dybjer:torino} and Bezem et al \cite{BezemCDE22})
%appendix   \ref{sec:gatPiU}) 
for the special case that there is only one type, so that all type equations are redundant:
\begin{eqnarray*}
\lid_{n} \circ \sigma &=& \sigma \\
 \sigma \circ \lid_{n} &=& \sigma \\
(\sigma \circ \tau) \circ \upsilon &=& \sigma \circ (\tau \circ \upsilon)\\
%&\vdash& 
%A[\id_{n}] &=& A \\
%a:\tm_n(\sigma,A) &\vdash& 
l[\lid_{n}] &=& l \\
%n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \delta : \Hom_n(\Xi,\Delta), \gamma : \Hom_n(\Delta,\Gamma),
%&\vdash& 
%A[\gamma\circ\delta] &=&A[\gamma][\delta]\\
%: \ty_n(\Xi)\\
%n : \lctx, \Xi,\Delta, : \ctx_n, \delta : \Hom_n(\Xi,\Delta), \gamma : \Hom_n(\Delta,\Gamma),
%a:\tm_n(\Gamma,A) &\vdash&
l[\sigma\circ\tau] &=& l[\sigma][\tau]\\
%: \tm_n(\Xi,A[\gamma\circ\delta])\\
%n : \lctx &\vdash& 
\lid_{0} &=& \tuple{}_{0}\\
 %: \Hom_n(1_n,1_n)\\
%\Gamma,\Delta : \ctx_n , \gamma : \Hom_n (\Delta,\Gamma) &\vdash&
\tuple{}_{n}\circ\sigma &=& \tuple{}_{m}\\
\lp_n \circ \tuple{\sigma,l} &=& \sigma\\
\lq_n [\tuple{\sigma,l}] &=& l\\
\tuple{\sigma,l} \circ \tau &=& \tuple{\sigma \circ \tau,l[\tau]}\\
\lid_{\s(n)} &=& \tuple{\lp_n,\lq_n}\\
\end{eqnarray*}



The semi-lattice equations for $l \vee l'$ are:
\begin{eqnarray*}
(l \vee l') \vee l'' &=& l \vee (l' \vee l'')\\
l \vee l' &=& l'\vee l\\
l \vee l &=& l
\end{eqnarray*}
and the equations for $l^+$ are:
\begin{eqnarray*}
l \vee l^+ &=& l^+\\
(l\vee l')^+ &=& l^+\vee l'^+
\end{eqnarray*}
The operator symbols $\vee$ and $+$ commute with level substitution:
\begin{eqnarray*}
(l \vee l')[\sigma] &=& l[\sigma] \vee l' [\sigma]\\
 l^+[\sigma] &=&  l[\sigma]^+
\end{eqnarray*}
%\end{tiny}
\paragraph{Lawvere theories.} We remark that ucwfs are related to Lawvere theories, but ucwfs are closer to the usual syntax based on $n$-place functions. One can prove that Lawvere theories are equivalent to contextual ucwfs, that is, ucwfs where each context has a length \cite{castellan:lambek}.

\footnote{Move stuff about $\leq$ here, including ucwf of normal forms?}
\footnote{Remark on finitely presented semilattices and constraints?}


\subsection{The level-indexed cwf of small types}\label{lcwf-sort}.

We now define the gat of ucwf-indexed cwfs with extra structure for the small type formers $\Pi,\Sigma,\N_0,\N_1,\N_2,\N,\W,\Id$. This is the theory of presheaves
$$
T : \L^\mathrm{op} \to \CwF^{\Pi,\Sigma,\N_0,\N_1,\N_2,\N,\W,\Id}
$$
valued in the category of cwfs with extra structure for the small type formers and cwf-morphisms preserving cwf-structure and the structure of the small type formers strictly. Thus
\begin{itemize}
\item
$T(n)$ is the cwf (with extra structure) of contexts, substitutions, types, and terms that depend on level variables in $n$.
\item
Let $\sigma : n \to m$ be a level substitution. In the initial model it is an $m$-tuple of level terms in $n$ level variables, and 
$T(\sigma) : T(m) \to T(n)$ substitutes the $m$ level variables by the respective $m$ level expressions in $\sigma$ in the various components of the cwf $T(m)$ yielding a cwf depending on $n$ level variables. All structure of the cwf with small type formers is preserved.
\end{itemize}

\paragraph{Sort symbols.} The gat for the level-indexed cwf of small types has the following sort symbols in addition to those of the gat of levels:
\begin{eqnarray*}
n : \lctx &\vdash& \ctx_n\\
n : \lctx, \Delta, \Gamma : \ctx_n &\vdash& \Hom_n(\Delta,\Gamma)\\
n : \lctx, \Gamma : \ctx_n &\vdash& \ty_n(\Gamma)\\
n : \lctx, \Gamma : \ctx_n, A:\ty_n(\Gamma) &\vdash& \tm_n(\Gamma,A)
\end{eqnarray*}
These are the same as the sort symbols of the gat of cwfs, except that they are all indexed by an argument $n : \lctx$.

\paragraph{Operator symbols.} Similarly, the operator symbols are the same as for cwfs (with extra structure for the small type formers), except that they are also indexed by $n : \lctx$. The equations are modified accordingly. See the appendix.

The arrow part of the level-indexed cwf of small types axiomatizes level substitution. There is one operator symbol for each component of the level-indexed cwf, but we overload notation:
\begin{eqnarray*}
n, n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'} &\vdash& 
\Gamma[\sigma] : \ctx_n\\
n, n' : \lctx , \sigma : \lhom(n,n'), \Delta,\Gamma : \ctx_{n'}, \gamma : \Hom_{n'}(\Delta,\Gamma) 
&\vdash& 
\gamma[\sigma] : \Hom_{n}(\Delta[\sigma],\Gamma[\sigma]) \\
n, n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'}, A:\ty_{n'}(\Gamma)
&\vdash& 
A[\sigma]: \ty_n(\Gamma[\sigma])\\
n,n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'}, A:\ty_{n'}(\Gamma), a : \tm_{n'}(A,\Gamma) 
&\vdash& 
a[\sigma] : \tm_{n}(A[\sigma],\Gamma[\sigma]) 
\end{eqnarray*}
\paragraph{Equations.}
The functor laws give us the following equations:\footnote{%
We should give more information here. The $p$ below is unexplained.}
\begin{eqnarray*}
\Gamma[\lid_n] &=& \Gamma\\
\Gamma[\sigma \circ \tau] &=& \Gamma[\sigma][\tau]\\
\gamma[\lid_n] &=& \gamma\\
\gamma[\sigma \circ \tau] &=& \gamma[\sigma][\tau]\\
A[\lid_n] &=& A\\
A[\sigma \circ \tau] &=& A[\sigma][\tau]: \ty_p(\Gamma[\sigma \circ \tau])\\
a[\lid_n] &=& a\\
a[\sigma \circ \tau] &=& a[\sigma][\tau]: \tm_p(A[\sigma \circ \tau],\Gamma[\sigma \circ \tau])
\end{eqnarray*}
Level substitution commutes with small type formers. We show the case for $\Pi$-types:

Let $n, n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'}, A:\ty_{n'}(\Gamma), B:\ty_{n'}(\Gamma.A)$. Then
\begin{eqnarray*}
\Pi(A,B)[\sigma] &=& \Pi(A[\sigma],B[\sigma])
\end{eqnarray*}
Moreover, if $b : \tm_n(\Gamma.A,B), c :  \tm_n(\Gamma,\Pi(A,B))$,  and $a : \tm_n(\Gamma,A)$, we have
\begin{eqnarray*}
\lambda(b)[\sigma] &=&\lambda(b[\sigma])\\
\app(c,a)[\sigma] &=&\app(c[\sigma],a[\sigma])
\end{eqnarray*}
%This finishes the gat for level-indexed cwfs with small type formers.

\subsection{Level-indexed universes} 
\paragraph{Operator symbols and a new sort symbol for level equality.} 
We finally add the operator symbols and equations for level-indexed universes.
Each $T(n)$ has extra structure for level-indexed universes $\UU_l$ with decodings $\Ta_l$, where $l$ is a level term that depends on level variables in $n$. These universes are closed under the small type formers and contain smaller universes $\UU_{l'}$ for $l' < l$.

The operator symbols are obtained by internalizating the corresponding rules for the externally indexed universes. As before, we only show closure under $\Pi$. (Should we factor out common premises $n : \lctx, l : \ltm(n), \Gamma : \ctx_n$?)
\begin{eqnarray*}
n : \lctx, l : \ltm(n), \Gamma : \ctx_n &\vdash& (\U_{l})_\Gamma : \ty_n(\Gamma)\\
n : \lctx, l : \ltm(n), \Gamma : \ctx_n, a : \tm_n(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta_{l}}(a) : \ty_n(\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,(\U_0)_\Gamma) \\
n : \lctx, l, l' : \ltm(n), \Gamma : \ctx_n,
a : \tm_n(\Gamma,(\U_{l})_\Gamma),
b :  \tm_n(\Gamma \cdot \Ta_{l}(a), (\U_{l'})_\Gamma)
&\vdash&
 \Pihat^{l,l'}(a,b) : \tm_n(\Gamma,(\U_{l \vee l'})_\Gamma)
\end{eqnarray*}
However, when we try to internalize the operator symbols $\UU^m_l$ for universes $\UU^l$ in larger universes $\UU^m$, where $l < m$, we encounter a problem. The following attempt
\begin{eqnarray*}
n : \lctx, l, m : \ltm(n), l < m, \Gamma : \ctx_n&\vdash&(\UU^m_l)_\Gamma: \tm_n(\Gamma,(\UU_{m})_\Gamma)
\end{eqnarray*}
where $l < m$ is defined as $l^+ \vee m = m$, does not work since equations are not allowed in argument types in gats. This issue can be resolved by introducing a new sort symbol for level equality:
\begin{eqnarray*}
n : \lctx, l, l'  : \ltm(n) &\vdash& \leq_n(l,l')
\end{eqnarray*}
and an operator symbol for reflexivity:
\begin{eqnarray*}
n : \lctx, l : \ltm(n) &\vdash& \refl(l) :  \leq_n(l,l)
\end{eqnarray*}
Note that if we can derive 
\begin{eqnarray*}
n : \lctx, l, l'  : \ltm(n) &\vdash& l = l' : \ltm(n)
\end{eqnarray*}
in the initial model \MB{or: in the lattice}, then we can also derive
\begin{eqnarray*}
n : \lctx, l,l' : \ltm(n) &\vdash& \refl(l) :  \leq_n(l,l')
\end{eqnarray*}
by preservation of equality which is available in the gats.
\footnote{Can we prove the following:
If we have derivations
\begin{eqnarray*}
\vdash n : \lctx, \vdash l,l' : \ltm(n), \vdash p :  \leq_n(l,l')
\end{eqnarray*}
then $\vdash p = \refl(l) : \leq(l,l')$ and $\vdash l = l' : \ltm(n)$?
\MB{Canonicity? Closed level context is natural number. Closed $l:\ltm(n)$ in
closed context is a lattice term ... $p$ is more difficult.}

PD: Yes, each level term has a normal form 
$
\alpha_1^{+^{p_1}} \vee \cdots \vee \alpha_m^{+^{p_m}}
$ 
for $p_i \geq 0$ for $1 \le i \le m \le n$ and distinct level variables (de Bruijn indices) $\alpha_1,\ldots,\alpha_m$. Hence we have an initial ucwf of levels where the elements of $\ltm(n)$ are such normal forms and $l = l' : \ltm(n)$ iff $l$ and $l'$ are identical.  Hence, if we extend the gat with a new sort $\leq$ and a new operator symbol $\refl$ for reflexivity, we can extend the initial model with sets $\leq_n(l,l')$ that contain a single element $\refl(l)$ iff $l = l' : \ltm(n)$ and is otherwise empty.
}

We now redefine $l < m$ as $\leq_n(l^+ \vee m, m)$ and get a proper typing of the operator symbol $\UU^m_l$:
\begin{eqnarray*}
n : \lctx, l, m : \ltm(n), p : l < m, \Gamma : \ctx_n&\vdash&(\UU^m_l)_{p,\Gamma} : \tm_n(\Gamma,(\UU_{m})_\Gamma)
\end{eqnarray*}
In the sequel we will suppress the proof $p : l < m$ as an argument to this operator symbol and just write $(\UU^m_l)_{\Gamma}$.

\paragraph{Level equality.} The sort symbol $\leq$ resembles the identity type former $\Id$ in Martin-Löf type theory. We can think of $\leq_n(l,l')$ as propositional level equality and its elements $p : \leq_n(l,l')$ as proofs of propositional level equality. However, while proofs $p : \Id(A,a,a')$ can make use of advanced logical reasoning, proofs of level equality can only be constructed from reflexivity and reasoning available in the gat \MB{for the level ucwf}.%\footnote{How to say this rigorously? We can of course use general reasoning available in any initial gat, including reasoning about judgmental level equality.}

\paragraph{Equations.}
The decoding equations for $\Ta_l$ and the equations for commutativity of operator symbols with substitution can be obtained by a straightforward internalization of the corresponding equations for the external tower. This means that the decoding equations are now relative to internal level contexts and level terms, as well as to terms. For example the decoding equation for $\Pi$ 
\begin{eqnarray*}
\Ta_{l \vee l'}(\Pi^{l,l'}(a,b)) = \Pi(\Ta_l(a),\Ta_{l'}(b)) :\tm_n(\Gamma,\UU_{l \vee l'})
\end{eqnarray*}
is now relative to the context
$$
n : \lctx, l, l' : \ltm(n), \Gamma : \ctx_n, a : \tm_n(\Gamma,\UU_l), b : \tm_n(\Gamma.\Ta_l(a),\UU_{l'} )
$$
and the decoding equation for the $l$th universe in the $m$th
\begin{eqnarray*}
\Ta_{m}((\UU^m_l)_\Gamma) &=& (\UU_l)_\Gamma
\end{eqnarray*}
is now relative to the context
$$
n : \lctx, l, m : \ltm(n), p : l < m
$$
where again $l < m$ is defined as $\leq_n(l^+ \vee m, m)$.

Equations for commutativity of operator symbols wrt substitution:
\begin{eqnarray*}
\Ta^m_l(a) [ \gamma ] &=& \Ta^m_l(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^{l}(a,b)[ \gamma ] &=& \Pi^{l}(a [ \gamma ], b[ \gamma^\dagger ])
\end{eqnarray*}
 where $\gamma : \hom(\Delta,\Gamma)$.
 
We also have equations for commutativity of lifting and $\Pi$-codes with respect to term substitution $\gamma$:
 \begin{eqnarray*}
(\U_l)_\Gamma [ \gamma ] &=& (\U_l)_\Delta\\
\Ta_l(a) [ \gamma ] &=& \Ta_l(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^{l,l'}(a,b)[ \gamma ] &=& \Pi^{l,l'}(a [ \gamma ], b[ \gamma^\dagger ])\\
(\UU^l)_\Gamma[ \gamma ] &=&(\UU^l)_\Delta
\end{eqnarray*}
Moreover, we have laws that level substitution $\sigma$ commutes with the operator symbols for a universe.
 \begin{eqnarray*}
 (\U_{l})_\Gamma[\sigma] &=& (\U_{l[\sigma]})_{\Gamma[\sigma]}\\
 \Ta_l(a) [ \sigma ] &=& \Ta_{l[\sigma]}(a[ \sigma ] )\\
\Pi^{l,l'}(a,b)[ \sigma ] &=& \Pi^{l[ \sigma ] ,l'[ \sigma ] }(a [ \sigma ], b[ \sigma])\\
(\UU^l)_\Gamma[ \sigma ] &=&(\UU^{l[ \sigma ]} )_{\Delta[ \sigma ]} 
 \end{eqnarray*}


\subsection{Adding cumulativity} 
\paragraph{Operator symbol.}
An operator symbol for cumulativity is obtained by internalizing the operator symbols for cumulativity in the external tower:
\begin{eqnarray*}
n : \lctx, l,m : \ltm(n), p : l < m, \Gamma : \ctx_n, a : \tm_n(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta^m_{l}}(a) : \tm(\Gamma,(\U_{m})_\Gamma))
\end{eqnarray*}
where again $l < m$ is defined as $\leq_n(l^+ \vee m, m)$. However, unlike for the external tower of universes, we need double superscripts on codes $\Pi^{l,l'}$ also in the cumulative case. 
%This is because, unlike in the external case, we to the greater in general.

\paragraph{Equations.}
We have the following decoding equation for lifting of codes for $\Pi$:
\begin{eqnarray*}
\Ta^{m \vee m'}_{l \vee l'}(\Pi^{l,l'}(a,b)) = \Pi^{m,m'}(\Ta^m_l(a),\Ta^{m'}_{l'}(b)) &:& \tm_n(\Gamma,(\UU_{l \vee l'})_\Gamma)
\end{eqnarray*}
where $n: \lctx,l',m,m' : \ltm(n), p: l < m, p': l' < m', \Gamma : \ctx_n, a : \tm_n(\Gamma,(\UU_l)_\Gamma), b : \tm_n(\Gamma.\Ta_l(a),(\UU_{l'})_\Gamma)$.
The decoding equation for lifting of codes for universes is as follows:
\begin{eqnarray*}
n : \lctx, k, l, m : \ltm(n), p : k < l, q : l < m, \Gamma : \ctx(n) &\vdash& \Ta^m_l((\UU^l_k)_\Gamma) = (\UU^m_k)_\Gamma
\end{eqnarray*}
Equations for commutativity of lifting and term substitution ($\gamma : \hom(\Delta,\Gamma)$):
\begin{eqnarray*}
\Ta^m_l(a) [ \gamma ] &=& \Ta^m_l(a[ \gamma ] )
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
%\Pi^{l}(a,b)[ \gamma ] &=& \Pi^{l}(a [ \gamma ], b[ \gamma^\dagger ])
\end{eqnarray*}
and level substitution
\begin{eqnarray*}
\Ta^m_l(a) [ \sigma ] &=& \Ta^m_{l[\sigma]}(a[ \sigma ] )
\end{eqnarray*}
%Check that this is right. Cf comment by intern.

\subsection{Syntax and inference rules as an initial model}\label{initiality-internal}

\paragraph{A generic construction based on explicit substitutions.} Since the gat for Martin-Löf type theory with level-indexed universes is finitary, the construction of an initial model is an instance of the general construction in Bezem et al
\cite{bezem:hofmann}. This construction yields an explicit substitution calculus for Martin-Löf type theory with level-indexed universes.

\paragraph{A construction based on implicit substitutions.} Can we construct an initial model based on the type theory with level judgments and level-indexed universes presented in Bezem et al \cite{BezemCDE22}? As in Section \ref{initiality-external} we would first need to use a decorated version of the terms. To turn this construction into one for level-indexed Martin-Löf type theory we need to extend the grammar with level terms, and add inference rules for level judgments. Then we need to show (i) how to organize the level terms and level judgments into an initial ucwf of levels; (ii) how to construct a level-indexed cwf of small types by modifying the construction of a cwf of small types; and (iii) how to construct an initial model of the level-indexed universes by modifying the construction of an initial model of the externally indexed universes.

We first explain how to construct a ucwf of levels by extending Brilakis' construction in Agda of the equivalence between two initial ucwfs: one with explicit substitutions and one with implicit substitution and de Bruijn variables \cite{Brilakis18}. Since the ucwf with explicit substitutions is constructed directly from the operator symbols of ucwfs, Brilakis' proof is essentially the same as proving the initiality of the ucwf with implicit substutions. To prove the initiality of the ucwf of levels, we only need to extend Brilakis' proof with the the extra structure for $\vee$ and $(-)^+$.
\begin{itemize}
\item We use de Bruijn indices as level variables and $n : \lctx$ is the number of available ones.
\item An element of $\ltm(n)$ is an equivalence class of level terms generated by $\vee$ and $(-)^+$ from level variables with respect to the equivalence relation generated by the equations for $\vee$ and $(-)^+$. In our type theory with explicit substitution \cite{BezemCDE22} this corresponds to the level terms $l$ such that 
$$
\Gamma \vdash l\ \level
$$
where $\Gamma$ contains $n$ level variables. Two terms $l, l' : \ltm(n)$ are equivalent provided
$$
\Gamma \vdash l = l'
$$
\item An element of $\lhom(m,n)$ is a sequence of length $n$ of elements of $\ltm(m)$.
\item We refer to Brilakis for the definition of the ucwf-operations. Note that level substitution $l[\sigma]$ is an implicit operation defined by induction on $l$.
% If $n = (\alpha_n, \ldots, \alpha_1)$ and $\s(n) =  (\alpha_n, \ldots, \alpha_1, \alpha_0)$ are lists of distinct level variables, then $\lp_n = (\alpha_n, \ldots, \alpha_1) : \lhom(\s(n),n)$ and $\lq_n = \alpha_0 : \ltm(\s(n))$ are the projections.
\end{itemize}

The next step is construct the initial of the gat for level-indexed cwfs with small types. In Bezem et al \cite{BezemCDE22} level variables and term variables may appear in arbitrary order in a context. For the construction of the initial model \footnote{PD: maybe it's better to say "term model" here and in some other places?} it is convenient to separate level contexts and term contexts and thus work with contexts of the form $n,\Gamma$, where $n$ is the number of level variables, and $\Gamma$ is a context which depends on these $n$ level variables. Note that 
\begin{itemize}
\item We define $\ty_n(\Gamma)$ as the set of equivalence classes of raw types $A$ such that $n, \Gamma \vdash A$ is a type and $A.A'$ are equivalent provided $n, \Gamma \vdash A = A'$.
\item We define $\tm_n(\Gamma,A)$ as the set of equivalence classes of raw terms $a$ such that $n, \Gamma \vdash a : A$ and $a.a'$ are equivalent provided $n, \Gamma \vdash A = A'$.
\item We define $\ctx_n$ as lists of types.
\item Finally, $\hom_n(\Delta,\Gamma)$ are lists of $\tm_n(\Delta,A)$.
\item The level equality sort $p : \leq_n(l,l')$ is interpreted as a one element sort provided $l = l' : \ltm(n)$.
\end{itemize}
 
The final part of the proof is about the arrow part of the level-indexed cwf with small types and level-indexed universes. In $\TTint$ \MB{explain} \footnote{PD: Should we introduce abbreviations for the gats and the type theories? For example, 
$\Sigma^\mathrm{ext}$ for the (presentation of) the gat for an external tower of universes and $\Sigma^\mathrm{int}$ for the level-indexed versions, and $\mathbf{TT^\mathrm{ext}}$ and $\mathbf{TT^\mathrm{int}}$ for the two versions of type theory in our old paper?} the different forms of level substitution and composition (in levels, level morphisms, contexts, context morphisms, types and terms) are all defined implicitly by induction on the respective syntactic categories. It follows directly that such level substitution satisfy the appropriate gat-equations, and that they are the unique operations doing so.

%In our old paper have the following introduction rule for cumulative universes with its decoding equation:
%$$
%\frac{l < m}
%{\UU^m_l : \UU_m\hspace{3em}\Ta_m(\UU^m_l) = \UU_l}
%$$
%where the context $\Gamma$ is implicit.

%\footnote{If  $n$ is the length of the level context, then level expressions have normal forms 
%$$
%\alpha_1^{+^{p_1}} \vee \cdots \vee \alpha_m^{+^{p_m}}
%$$ 
%for $p_i \geq 0$ for $1 \le i \le m \le n$ . We have 
%$$
%\alpha_1^{+^{p_1}} \vee \cdots \vee \alpha_m^{+^{p_m}} 
%< 
%\alpha_1^{+^{q_1}} \vee \cdots \vee \alpha_m^{+^{q_m}} \vee \alpha_{m+1}^{+^{q_{m+1}}} \vee \cdots \vee \alpha_{m'}  ^{+^{q_{m'}}}
%$$ 
%provided $p_i < q_i$ for $1 \le i \le m \le m' \le n$.} 

\subsection{Level-indexed products of types}
%We add three operator symbols in addition to the operator symbols for cwfs in Section 5.2 and 5.3:
\def\l{\mathrm{l}}
%\begin{tiny}
In Bezem et al \cite{BezemCDE22} we also introduced 
universal level quantification with level abstraction and application of a term to a level. The corresponding operator symbols are
\begin{eqnarray*}
n : \lctx, \Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp])&\vdash& \forall_\l(B) : \ty_n(\Gamma)\\
n : \lctx, \Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp]), b : \tm_{\s(n)}(\Gamma[\lp], B) &\vdash& \lambda_\l(b) : \tm_n(\Gamma,\forall_\l(B))\\
n : \lctx, \Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp]), c :  \tm_n(\Gamma,\forall_\l(B)), l : \ltm(n) &\vdash& \app_\l(c,l) : \tm_n(\Gamma, B[\tuple{\lid,l}])
\end{eqnarray*}
Equations ($\beta$ and $\eta$ for level abstraction and application):
 \begin{eqnarray*}
 \app_\l(\lambda_\l(b),l) &=& b[\tuple{\lid,l}]\\
 \lambda_\l(\app_\l(c[\lp],\lq)) &=& c
 \end{eqnarray*}
 Equations for commutativity of operator symbols with respect to level substitution
 \begin{eqnarray*}
 \forall_\l(B)[ \gamma ] &=& \forall_\l(B[ \gamma[\lp]])\\
 \lambda_\l(B)[ \gamma ] &=& \lambda_\l(B[ \gamma[\lp]])\\
 \app_\l(c,l)[ \gamma ] &=& \app_\l(c[ \gamma ] ,l[ \gamma ] )\\
 \forall_\l(B)[ \sigma ] &=& \forall_\l(B[ \sigma^{\dagger}])\\
 \lambda_\l(B)[ \sigma ] &=& \lambda_\l(B[ \sigma^{\dagger}])\\
\app_\l(c,l)[ \sigma ] &=& \app_\l(c[ \sigma ] ,l[ \sigma ] )
\end{eqnarray*}
where $\gamma : \hom_n(\Delta,\Gamma)$ is a term substitution, and $\sigma : \lhom(m,n)$ is a level substitutuion with $\sigma^\dagger = \tuple{\sigma \circ \lp, \lq}$. 
To check the type of the equation
$$ \forall_\l(B)[ \sigma ] = \forall_\l(B[ \sigma^{\dagger}])$$ we assume $\Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp])$. It follows that $B[\sigma^\dagger] : \ty_{s(m)}(\Gamma[\lp][\sigma^\dagger]) = \ty_{s(m)}(\Gamma[\sigma][\lp])$. Hence 
$\forall_\l(B[ \sigma^{\dagger}]) : \ty_m(\Gamma[\sigma])$.

\paragraph{Universal quantification in predicate logic.} In the introduction we mentioned that untyped predicate logic can be captured by ucwf-indexed scwfs. (This gives a proof-relevant logic, just like Lawvere's hyperdoctrines \cite{lawvere:hyperdoctrines}.) We note that the operator symbols and equations for universal quantification in untyped predicate logic are the same as those for universal level quantification above, except the difference between scwfs and cwfs: propositions in predicate logic do not depend on proofs.

\section{Conclusion and further research}

We have shown how to present an infinitary gat $\Sigmaext$ for Martin-Löf type theory with an external tower of universes and a finitary gat $\Sigmaint$ for Martin-Löf type theory with internally level-indexed universes. We have also shown how to construct initial models $\T_{\Sigmaext}$ and $\T_{\Sigmaint}$ as instances of a general construction of initial models of gats in 
Bezem et al \cite{bezem:hofmann}. These models are initial in the categories $\CwF_{\Sigmaext}$ and $\CwF_{\Sigmaint}$ of cwfs with an internal cwf with extra structure. 
As such they are encodings of the respective syntactic theories $\TText$ and $\TTint$ rather than the syntactic theories themselves. 
The relationship between the encoded and the original theories is an important question for further research. The situation is somewhat similar to the encoding of theories in logical frameworks, where an answer for the encoding of Martin-Löf type theory was provided by Hofmann \cite{hofmann:cambridge} as a conservativity theorem. 

%We have shown how to capture Martin-Löf type theory with explicit universe polymorphism as a gat. The list of sort symbols, operator symbols, and equations may seem long but not as long as the list of inference rules rules for the syntactic theory. (In the versions with implicit substitutions we should include the substitution lemmas.) Moreover, the gat formalizes the high-level structure of ucwf-indexed cwfs with extra structure: the $\vee$-semilattice with an inflationary operation $(-)^+$, and adjoint-like structures for $\Pi$-types and other type formers. Also context comprehension in cwfs is an adjoint-like structure. The relationship with adjoints in the sense of ordinary cartesian closed categories is worked out in the case of contextual cwfs with extensional equality types, $\Sigma$-types and $\Pi$-types by Clairambault and Dybjer \cite{ClairambaultD11,ClairambaultD14} and for some other structures in Castellan et al \cite{castellan:lambek}.
%
%A key novelty is the need for level equality sorts $\leq_n(l,l')$. The main recipe for a gat corresponding to Martin-Löf type theory is that equality judgments are formalized as judgmental equalities in gats. For example, the judgment 
%$$
%\Gamma \vdash A
%$$
%expressing that $A$ is a well-formed type in the context $\Gamma$, corresponds to elements
%$$
%A : \ty(\Gamma)
%$$
%in the gat, but
%$$
%\Gamma \vdash A = A'
%$$
%corresponds to an equality
%$$
%A = A' : \ty(\Gamma)
%$$
%Hence, we do not need a new sort symbol corresponding to type equality judgments. However, this principle breaks down when formalizing the principle that any universe has a code in any larger universe. This is because $l < l'$ is defined as the level equality $l^+ \vee l' = l'$ and level equalities are not allowed in contexts in gats. To resolve this issue we add a sort $\leq_n(l,l')$ for level equality.

In Bezem et al \cite{BezemCDE22} we extend Martin-Löf type theory with level-indexed universes with equational constraints. We plan to extend our gat $\Sigmaint$ accordingly in a forthcoming article.

%While we have a generic construction of initial gats as a term model for an explicit substitution calculi, we are still relying on ad hoc proofs for the more standard implicit substitution calculi. However, also the latter seem to arise systematically from gats of cwfs. It seems that we can define variables as projections $\q[\p^n]$ in and implicit substitutions (arising from the arrow part of the family valued functor for example) can be defined by induction on the structure of types and terms. \footnote{Related work in this direction has been done by Fiore and coworkers.}
%
It would also be interesting to develop other examples of gats for various logical systems. We already of mentioned in the introduction that untyped predicate logic is captured by ucwf-indexed scwfs, typed predicate logic by scwf-indexed scwfs, and dependently typed predicate logic by cwf-indexed scwfs (all with extra structure). Palmgren has already analyzed dependently typed predicate logic as hyperdoctrines above cwfs \cite{Palmgren19}. In the quest for uniform categorical logic it would be interesting to recast this work in terms of cwf-indexed scwfs. 

(* Very rough formulation *) The idea of uniform categorical logic is akin to the idea of implementing logics on top of logical frameworks, such as Edinburgh LF, Isabelle, and Deducti. Such logical frameworks are based on dependent type theory with $\Pi$-types and one or more universes. The aim is to encode other logics by adding constants and equations to the logical framework. The approach based on gats is based on a ``logical framework'' based only on the most basic rules of dependent type theory, but without $\Pi$-types and a universe. The idea is to encode other logic by adding constants (sort and operator symbols) and equations to this basic dependent type theory.

As related work we would also like to mention the quotient inductive-inductive types (qiits) of Kaposi, Kov{\'{a}}cs, and Altenkirch
\cite{kaposi:qiits,kovacs:phd}. Although formal details may be slightly different, qiits are initial gats considered as data types in dependent type theory. Sort symbols correspond to data type constructors and operator symbols correspond to term constructors. These should be considered up to an equivalence relation generated by the equations. The notion of qiit is the latest extension in the sequence inductive type, inductive family, inductive-recursive type inductive-inductive type, quotient inductive-inductive type. Since qiits are inductively generated, they have an elimination principle. 

\footnote{In principle we should also survey other approaches to the initiality conjecture, like Uemura.}

%and $\gamma^\dagger = \tuple{\gamma \circ \p, \q}$??
%\end{tiny}
%\footnote{Discussion with Raphael Sterback:
%$$
%\forall_l (B)[\gamma] = \forall_l (B[\gamma[\lp]])
%$$}
\appendix
\section{Operator symbols and equations for level-indexed cwfs of small types}

We already listed the sort symbols in \ref{lcwf-sort}

\paragraph{Operator symbols.} \footnote{Check whether implicit arguments are systematic.}
%We have the following sort symbols:
%\begin{eqnarray*}
%n : \lctx &\vdash& \ctx_n\\
%n : \lctx, \Delta, \Gamma : \ctx_n &\vdash& \Hom_n(\Delta,\Gamma)\\
%\end{eqnarray*}
\begin{eqnarray*}
n : \lctx, \Gamma : \ctx_n &\vdash& \id_{n,\Gamma} : \Hom_n(\Gamma,\Gamma)\\
n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \gamma : \Hom_n(\Delta,\Gamma), \delta : \Hom_n(\Xi,\Delta) &\vdash&
\gamma \circ \delta : \Hom_n(\Xi,\Gamma)\\
n : \lctx, \Gamma,\Delta : \ctx_n, A:\ty_n(\Gamma), \gamma : \Hom_n(\Delta,\Gamma) &\vdash&
A[\gamma] : \ty_n(\Delta)\\
n : \lctx, \Gamma,\Delta : \ctx_n, A:\ty_n(\Gamma), \gamma : \Hom_n(\Delta,\Gamma), a:\tm_n(\Gamma,A) &\vdash&  a[\gamma] : \tm_n(\Delta,A[\gamma])\\
n : \lctx &\vdash& 1_n : \ctx_n\\
n : \lctx, \Gamma : \ctx_n &\vdash& \tuple{}_{n,\Gamma} : \Hom_n(\Gamma,1_n)\\
n : \lctx, \Gamma : \ctx_n, A:\ty_n (\Gamma) &\vdash& \Gamma \cext A : \ctx_n \\
n : \lctx, \Gamma,\Delta : \ctx_n , A:\ty_n (\Gamma), \gamma : \Hom_n (\Delta,\Gamma), a:\tm_n (\Delta,A[\gamma]) &\vdash& \tuple{\gamma,a} : \Hom_n (\Delta,\Gamma\cext A)\\
n : \lctx, \Gamma : \ctx_n , A:\ty_n (\Gamma) &\vdash& \p_{n,\Gamma,A}: \Hom_n (\Gamma\cext A,\Gamma)\\
n : \lctx, \Gamma : \ctx_n , A:\ty_n (\Gamma) &\vdash& \q_{n,\Gamma,A}: \tm_n (\Gamma\cext A,A[\p])
\end{eqnarray*}
Operator symbols for level-indexed $\Pi$-types (should we decorate $\lambda$ and $\app$ with type information?):
\begin{eqnarray*}
n : \lctx, \Gamma : \ctx_n, A : \ty_n(\Gamma), B : \ty_n(\Gamma.A)&\vdash& \Pi(A,B) : \ty_n(\Gamma)\\
n : \lctx, \Gamma : \ctx_n, A : \ty_n(\Gamma), B : \ty_n(\Gamma.A), b : \tm_n(\Gamma.A, B) &\vdash& \lambda(b) : \tm(\Gamma,\Pi(A,B))\\
n : \lctx, \Gamma : \ctx_n, A : \ty_n(\Gamma), B : \ty_n(\Gamma.A), c :  \tm_n(\Gamma,\Pi(A,B)), a : \tm_n(\Gamma, A) &\vdash& \app(c,a) : \tm(\Gamma, B[\tuple{\id,a}])
\end{eqnarray*}

\paragraph{Equations.}
\begin{eqnarray*}
\id_{n,\Gamma} \circ \gamma &=& \gamma \\
 \gamma \circ \id_{n,\Delta} &=& \gamma \\
(\gamma \circ \delta) \circ \xi &=& \gamma \circ (\delta \circ \xi)\\
%&\vdash& 
A[\id_{n,\Gamma}] &=& A 
%: \ty_n(\Gamma)
\\
%a:\tm_n(\Gamma,A) &\vdash& 
a[\id_{n,\Gamma}] &=& a% : \tm_n(\Gamma,A)
\\
%n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \delta : \Hom_n(\Xi,\Delta), \gamma : \Hom_n(\Delta,\Gamma),
%&\vdash& 
A[\gamma\circ\delta] &=& A[\gamma][\delta]
%: \ty_n(\Xi)
\\
%n : \lctx, \Xi,\Delta, : \ctx_n, \delta : \Hom_n(\Xi,\Delta), \gamma : \Hom_n(\Delta,\Gamma),
%a:\tm_n(\Gamma,A) &\vdash&
a[\gamma\circ\delta] &=& a[\gamma][\delta]
%: \tm_n(\Xi,A[\gamma\circ\delta])
\\
%n : \lctx &\vdash& 
\id_{n,1_n} &=& \tuple{}_{n,1_n} 
%: \Hom_n(1_n,1_n)
\\
%\Gamma,\Delta : \ctx_n , \gamma : \Hom_n (\Delta,\Gamma) &\vdash&
\tuple{}_{n,\Gamma}\circ\gamma &=& \tuple{}_{n,\Delta}% : \Hom_n (\Delta,1_n )
\\
%\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash& 
\p_{n,\Gamma,A}\circ\tuple{\gamma,a} &=& \gamma : \Hom(\Delta,\Gamma)\\
%\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash&  
\q_{n,\Gamma,A}[\tuple{\gamma,a}] &=& a : \tm(\Delta,A[\gamma]) \\
%\Gamma,\Delta,\Xi : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]), \delta : \Hom(\Xi,\Delta) &\vdash&
\tuple{\gamma,a} \circ \delta &=& \tuple{\gamma\circ\delta,a[\delta]} \\
%:
%\Hom(\Xi,\Gamma\cext A) \\
%\Gamma : \ctx, A:\ty(\Gamma) &\vdash&
\id_{n,\Gamma\cext A} &=& \tuple{\p_{n,\Gamma,A},\q_{n,\Gamma,A}} : \Hom(\Gamma\cext A,\Gamma\cext A)
\end{eqnarray*}
\footnote{MB, check. Perhaps better to describe how to modify \ref{sec:gatPiU}:
prefix every rule with $n:\lctx$ and add index $n$ to every occurrence
of $\ctx,\ty,\tm$.}
Equations (omitting the context and type of the equalities):
 \begin{eqnarray*}
 \app(\lambda(b),a) &=& b[\tuple{\id,a}]\\
 \lambda(\app(c[\p],\q)) &=& c
 \end{eqnarray*}
 Equations for commutativity of operator symbols wrt substitution:
 \begin{eqnarray*}
\Pi(A,B)[ \gamma ] &=& \Pi(A [ \gamma ], B[ \gamma^\dagger ])\\
\lambda(b) [ \gamma ] &=& \lambda(b[\gamma^\dagger ])\\
\app(c,a) [ \gamma ] &=& \app(c[ \gamma ], a[ \gamma ] )
\end{eqnarray*}
where $\gamma^\dagger = \tuple{\gamma \circ \p, \q}$.

%We also need to add rules for level-indexed $\Pi$

%\begin{itemize}
%\item
%Object part of the functor $\L \to \CwF^{\Pi,\UU_l}$
%\begin{itemize}
%\item Level-indexed contexts and context-morphisms
%\item Level-indexed types and terms
%\end{itemize}
%\item
%Arrow part of the functor $\L \to \CwF^{\Pi,\UU_l}$
%\begin{itemize}
%\item Level-substitution in contexts and context-morphisms
%\item Level-substitution in types and terms
%\end{itemize}
%\end{itemize}






\bibliographystyle{plain}
\bibliography{../refs}
\end{document}
