\documentclass[11pt,a4paper]{article}
%\ifx\pdfpageheight\undefined\PassOptionsToPackage{dvips}{graphicx}\else%
%\PassOptionsToPackage{pdftex}{graphicx}
\PassOptionsToPackage{pdftex}{color}
%\fi

%\usepackage{diagrams}

%\usepackage[all]{xy}
\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage{latexsym}
\usepackage{amssymb,amstext,amsmath,amsthm}
\usepackage{epsf}
\usepackage{epsfig}
\usepackage{float}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage{proof}
\usepackage{latexsym}
%\usepackage{mytheorems}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}{Lemma}[theorem]
\newtheorem{proposition}{Proposition}[theorem]
\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{remark}{Remark}[theorem]
\newtheorem{TODO}{TODO}[theorem]
\newtheorem{remark}{Remark}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{conjecture}{Conjecture}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}


%%%%%%%%%copied from SymmetryBook by Marc

% hyperref should be the package loaded last
\usepackage[backref=page,
            colorlinks,
            citecolor=linkcolor,
            linkcolor=linkcolor,
            urlcolor=linkcolor,
            unicode,
            pdfauthor={BCDE},
            pdftitle={Universes},
            pdfsubject={Mathematics},
            pdfkeywords={type theory, universes}]{hyperref}
% - except for cleveref!
\usepackage[capitalize,noabbrev]{cleveref}
%\usepackage{xifthen}
\usepackage{xcolor}
\definecolor{linkcolor}{rgb}{0,0,0.5}

%%%%%%%%%
\def\oge{\leavevmode\raise
.3ex\hbox{$\scriptscriptstyle\langle\!\langle\,$}}
\def\feg{\leavevmode\raise
.3ex\hbox{$\scriptscriptstyle\,\rangle\!\rangle$}}

%%%%%%%%%

\newcommand{\mkbox}[1]{\ensuremath{#1}}
\newcommand{\eraser}[1]{}

\newcommand{\conv}{=}
%\newcommand{\conv}{\mathsf{conv}}

\newcommand{\Id}{\mathsf{Id}}
\newcommand{\Eq}{\mathsf{Eq}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\NN}{\mathsf{N}}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\UU}{\mathsf{U}}
\newcommand{\JJ}{\mathsf{J}}
\newcommand{\AgdaLevel}{\mathsf{Level}}
\newcommand{\Level}{\mathsf{level}}
\newcommand{\Lev}{{\mathbb{L}}}
%\newcommand{\Type{\hbox{\sf Type}}
\newcommand{\ZERO}{\mathsf{0}}
\newcommand{\SUCC}{\mathsf{S}}
\newcommand{\valid}{\mathsf{valid}}
\newcommand{\level}{\mathsf{level}}
%\newcommand{\type}{\mathsf{type}}
\newcommand{\const}{\mathsf{const}}
\newcommand{\lam}[1]{{\langle}#1{\rangle}}
\newcommand{\mylam}[3]{\lambda_{#1:#2}#3}
\newcommand{\mypi}[3]{\Pi_{#1:#2}#3}
\newcommand{\Upi}[3]{\Pi^{#1}\,#2\,#3}
\newcommand{\mysig}[3]{\Sigma_{#1:#2}#3}
\newcommand{\Usig}[3]{\Sigma^{#1}\,#2\,#3}
\newcommand{\app}[2]{{#1\,#2}} % many applications still hard-coded with ~
\newcommand{\Sapp}[1]{\sapp{\SUCC}{#1}}
\newcommand{\sapp}[2]{{#1(#2)}} % strict app for Id, refl, J, natrec, not S (!)
\newcommand{\Idapp}[3]{\sapp{\Id}{#1,#2,#3}}
\newcommand{\Idnapp}[4]{\sapp{\Id^#4}{#1,#2,#3}}
\newcommand{\NRapp}[4]{\sapp{\RR}{#1,#2,#3,#4}}
\newcommand{\Rfapp}[2]{\sapp{\refl}{#1,#2}}
\newcommand{\Japp}[6]{\sapp{\JJ}{#1,#2,#3,#4,#5,#6}}
\newcommand{\RR}{\mathsf{R}}
%\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Group}{\mathsf{Group}}
%\newcommand{\El}{\mathsf{El}}
%\newcommand{\T}{\mathsf{T}}
%\newcommand{\Usuper}{\UU_{\mathrm{super}}}
%\newcommand{\Tsuper}{\T_{\mathrm{super}}}
%\newcommand{\idtoeq}{\mathsf{idtoeq}}
%\newcommand{\isEquiv}{\mathsf{isEquiv}}
%\newcommand{\Equiv}{\mathsf{Equiv}}
\newcommand{\isContr}{\mathsf{isContr}}
%\newcommand{\ua}{\mathsf{ua}}
%\newcommand{\UA}{\mathsf{UA}}
%\newcommand{\natrec}{\mathsf{natrec}}
%\newcommand{\set}[1]{\{#1\}}
%\newcommand{\sct}[1]{[\![#1]\!]}
%\newcommand{\refl}{\mathsf{refl}}
\newcommand{\ttt}[1]{\text{\tt #1}}

\newcommand{\Constraint}{\mathsf{Constraint}}
\newcommand{\Ordo}{\mathcal{O}}
\newcommand{\AFu}{\mathcal{A}}
\newcommand{\Fu}{\mathit{Fu}}

\newcommand{\Ctx}{\mathrm{Ctx}}
\newcommand{\Ty}{\mathrm{Ty}}
\newcommand{\Tm}{\mathrm{Tm}}
\newcommand{\op}{\mathrm{op}}

\newcommand{\CComega}{\mathrm{CC}^\omega}
\setlength{\oddsidemargin}{0in} % so, left margin is 1in
\setlength{\textwidth}{6.27in} % so, right margin is 1in
\setlength{\topmargin}{0in} % so, top margin is 1in
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{9.19in} % so, foot margin is 1.5in
\setlength{\footskip}{.8in}

% Definition of \placetitle
% Want to do an alternative which takes arguments
% for the names, authors etc.

\newcommand\myfrac[2]{
 \begin{array}{c}
 #1 \\
 \hline \hline
 #2
\end{array}}

\def\levelctx{\mathrm{lctx}}
\def\lhom{\mathrm{lhom}}
\def\psiab{\psi_{\alpha\beta}}

\newcommand*{\Scale}[2][4]{\scalebox{#1}{$#2$}}%
\newcommand*{\Resize}[2]{\resizebox{#1}{!}{$#2$}}

\newcommand{\II}{\mathbb{I}}
\newcommand{\refl}{\mathsf{r}}
%\newcommand{\mkbox}[1]{\ensuremath{#1}}


%\newcommand{\Id}{\mathsf{Id}}
%\newcommand{\conv}{=}
%\newcommand{\conv}{\mathsf{conv}}
%\newcommand{\lam}[2]{{\langle}#1{\rangle}#2}
\def\NN{\mathsf{N}}
\def\UU{\mathsf{U}}
\def\JJ{\mathsf{J}}
%\def\Type{\hbox{\sf Type}}
\def\ZERO{\mathsf{0}}
\def\SUCC{\mathsf{S}}

\newcommand{\RawCtx}{{\tt Ctx}}
\newcommand{\RawSub}{{\tt Sub}}
\newcommand{\RawTy}{{\tt Ty}}
\newcommand{\RawTm}{{\tt Tm}}
\newcommand{\type}{\mathsf{type}}
\newcommand{\N}{\mathsf{N}}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\El}{\mathsf{El}}
%\newcommand{\U}{\mathsf{U}} clashes with def's in new packages
\newcommand{\T}{\mathsf{T}}
\newcommand{\Usuper}{\UU_{\mathrm{super}}}
\newcommand{\Tsuper}{\T_{\mathrm{super}}}
%\newcommand{\conv}{\mathrm{conv}}
\newcommand{\idtoeq}{\mathsf{idtoeq}}
\newcommand{\isEquiv}{\mathsf{isEquiv}}
\newcommand{\ua}{\mathsf{ua}}
\newcommand{\UA}{\mathsf{UA}}
\def\Constraint{\mathsf{Constraint}}
\def\Ordo{\mathcal{O}}
\def\Pihat{\Pi}

\def\Ctx{\mathrm{ctx}}
\def\Ty{\mathrm{ty}}
\def\Tm{\mathrm{tm}}
\def\Obj{\mathrm{obj}}
\def\Hom{\mathrm{hom}}
\def\id{\mathrm{id}}
\def\lHom{\mathrm{lhom}}
\def\lctx{\mathrm{lctx}}
\def\lty{\mathrm{level}}
\def\ltm{\mathrm{ltm}}
\def\ltmq{\mathrm{ltmq}}
\def\leq{\mathrm{leq}}
\def\lrefl{\mathrm{lr}}
\def\lp{\mathrm{lp}}
\def\lq{\mathrm{lq}}
\def\s{\mathrm{s}}
\def\lid{\mathrm{lid}}
\def\cctx{\mathrm{cctx}}
\def\cty{\mathrm{cty}}
\def\ctm{\mathrm{ctm}}
\def\cid{\mathrm{cid}}
\def\cp{\mathrm{cp}}
\def\cq{\mathrm{cq}}
\def\chom{\mathrm{chom}}

\newcommand{\ctx}{\mathrm{ctx}}
\newcommand{\sub}{\mathrm{sub}}
\newcommand{\ty}{\mathrm{ty}}
\newcommand{\tm}{\mathrm{tm}}
%\newcommand{\hom}{\mathrm{hom}}
\newcommand{\tuple}[1]{\langle #1 \rangle}
\def\CComega{\mathrm{CC}^\omega}
\newcommand{\cext}{.}
\def\p{\mathrm{p}}
\def\q{\mathrm{q}}
\def\app{\mathsf{app}}
\def\U{\mathsf{U}}
\def\T{\mathcal{T}}
\newcommand{\Ta}{\mathrm{T}}
\newcommand{\ta}{\mathrm{t}}

\newcommand{\natrec}{\mathsf{natrec}}
%\rightfooter{}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\sct}[1]{[\![#1]\!]}
\def\R{\mathcal{R}}

\def\L{{\mathcal{L}}}
\def\F{\mathcal{C}}
\def\CwF{\mathrm{CwF}}
\def\Fam{\mathrm{Fam}}
\def\SCwF{\mathrm{SCwF}}
\def\C{\mathcal{C}}
\def\W{\mathsf{W}}

\def\TTUP{\mathbf{MLTT^{\UU_l}}}

\begin{document}

\title{Type Theory
with Explicit Universe Polymorphism\\ as an Initial Model of a Generalized Algebraic Theory\footnote{Alternative title: Categorical Models of Type Theory or Type Theory
with Explicit Universe PolymorphismGeneralised Algebraic Theories of Type Theories with Explicit Universe Polymorphism?
}}

\author{Marc Bezem, Thierry Coquand, Peter Dybjer, Mart\'{\i}n Escard\'o}

\date{(incomplete draft)}
\maketitle

\begin{abstract}
We present generalized algebraic theories corresponding to slightly modified versions of some of the theories in our paper 
{\em Type Theory with Explicit Universe Polymorphism}. We first consider Martin-Löf type theory with an external tower of universes. Its models are categories with families with extra structure for the small type formers and the tower of universes. We then consider Martin-Löf type theory with explicit universe polymorphism, where we have universe level judgments and internally indexed universes. Its models are level-indexed categories with families, again with appropriate extra structure. (* Finally, we extend the theory with universe level constraints. Its models are doubly indexed categories with families with extra structure. *) In this way we get abstract syntax definitions of our theories as initial models of certain indexed categories with families with extra structure. We thus abstract from details of the grammar and inference rules of the type theories and highlight their high-level structure.
\end{abstract}

\section{Introduction}

The aim of Voevodsky's  {\em Initiality Conjecture project} is to provide a definition of a general class of dependent type theories and to develop generic metatheory for theories in this class. We quote from the introduction of an extended abstract where Voevodsky \cite{voevodsky:initiality} motivates his project:
\begin{quotation}
The first few steps in all approaches to the set-theoretic semantics of dependent
type theories remain insuﬃciently understood. The constructions which have been
worked out in detail in the case of a few particular type systems by dedicated authors
are being extended to the wide variety of type systems under consideration today by
analogy. This is not acceptable in mathematics. Instead we should be able to obtain
the required results for new type systems by specialization of general theorems and
constructions formulated for abstract objects the instances of which combine together
to produce a given type system.
\end{quotation}
In particular, one would like a generic construction showing that theories in this class are initial in corresponding categories of models. We quote Voevodsky \cite{voevodsky:initiality} again:
\begin{quotation}
A crucial component of this approach is the expected result that for a particular
class of inference rules the term model is an initial object in the category of models.
This is known as the Initiality Conjecture. In the case of the pure Calculus of
Constructions with a “decorated” application operation this conjecture was proved in
1988 by Thomas Streicher \cite{streicher:thesis}. The problem of finding an appropriate formulation
of the general version of the conjecture and of proving this general version will be the
subject of future work.
\end{quotation}
Such initiality proofs may seem straightforward superficially, but depend on subtle details in the formulation of grammar and inference rules. This is why Voevodsky insisted on calling such theorems ``conjectures'' until proven rigorously and ideally implemented in a proof assistant.

An example of such an initiality proof is Brunerie and de Boer's \cite{Brunerie:initiality,deBoer:lic} proof in Agda that a version of Martin-Löf type theory with an external tower of universes is an initial contextual category \cite{cartmell:phd,cartmell:apal} with appropriate extra structure. %Theversion of type theory with de Bruijn variables and implicit substitutions. 

A possible approach to Voevodsky's project is based on Cartmell's notion of a {\em generalized algebraic theory (gat)} \cite{cartmell:phd,cartmell:apal}. The most basic rules of dependent type theory can be captured by the gat of categories with families (cwfs) \cite{dybjer:torino}. Moreover, as shown in our paper {\em On generalized algebraic theories and categories with families} \cite{bezem:hofmann} there is a generic construction of an initial model of an arbitrary finitary gat. 
Maybe an approach to a general notion of dependent type theory is as an initial model of an extension of the gat of cwfs? The reason for focusing on the gat of cwfs is that it occupies an intermediate place between dependent type theories defined by a grammar and inference rules and notions of model based on more mainstream categorical constructions. In particular, the gat of cwfs resembles Martin-Löf's substitution calculus for dependent type theory \cite{martinlof:gbg92,tasistro:lic}.

Furthermore, as shown by Castellan, Clairambault, and Dybjer \cite{castellan:lambek}, by considering simply typed cwfs (scwfs) and unityped cwfs (ucwfs) we can also capture various simply typed and untyped logical systems as gats and thus widening the scope of {\em uniform categorical logic} based on gats and cwfs. 

In this article we introduce the notion of an indexed cwf, that is, a base category $\C$ and a cwf-valued presheaf
$$
P : \C^\op \to \CwF
$$
We shall show that a cwf indexed by (the base category of) a ucwf $\L$ of universe levels (with suitable extra structure) forms a suitable notion of model of Martin-Löf type theory with explicit universe polymorphism along the lines of our paper {\em Type Theory with Explicit Universe Polymorphism} \cite{BezemCDE22}. The benefit is twofold. First, it is a case study for our approach to the Initiality Conjecture project. Type theory with explicit universe polymorphism is an example of a dependent type theory, and we show that it can be captured by a gat based on a variation of cwfs. Second, it provides an alternative view of our syntactic type theory with explicit universe polymorphism. One can argue that a type theory presented by a gat of cwfs is a higher-level and more ``objective'' notion than one presented by grammar and inference rules. This is because the gat only records the ``important" rules and highlights categorical structure. When building initial models in terms of grammar and inference rules we  need to include various bookkeeping rules, such as general rules of equality reasoning, and there will be a multitude of options. Without a common high level abstraction it will be hard to prove the equivalence between these options, and to claim that there is a unique abstract notion. 

We also outline how modified versions of the theories presented in Bezem et al  \cite{BezemCDE22} form initial models of the gats. Rigorous proofs are however beyond the scope of the paper. 

Moreover, further variations of indexed cwfs extend the scope of gat and cwf-based uniform categorical logic. For example, untyped predicate logic can be captured by ucwf-indexed scwfs with extra structure for the logical constants. Moreover, typed predicate logic can be captured by scwf-indexed scwfs, and dependently typed predicate logic by cwf-indexed scwfs, both with suitable extra structure for type formers and logical constants. Different versions of dependently typed predicate logic have been studied by Makkai \cite{makkai:folds}, Gambino and Aczel \cite{gambino-aczel}, Belo \cite{belo}, and Palmgren \cite{Palmgren19}.

\paragraph{Universe polymorphism.} We refer to our previous paper on explicit universe polymorphism \cite{BezemCDE22} for a presentation of the inference rules of Martin-Löf type theory with explicit universe polymorphism. There the reader can also find motivation and examples. Here we only give a brief overview. 

An implicit form of universe polymorphism in dependent type theory was introduced by Huet \cite{Huet87} and is an essential feature of the proof assistant Coq (Rocq) \cite{coq:general}. Alternatively, Agda \cite{agda-wiki} and Lean \cite{moura:lean} employ versions of universe polymorphism, where universe levels are explicitly declared. 

In our paper we followed Courant's approach \cite{Courant02} to explicit universe polymorphism and introduced special universe level {\em judgments}:
$$
l\ \level
\hspace{5em}
l = l'
$$
in addition to the usual judgment forms of type theory. Moreover, all judgments may depend on universe level variables as well as ordinary variables declared in the context. We emphasized that, unlike in Agda, universe levels do {\em not} form a {\em type} in our setting, and instead we added the above judgment forms. Nevertheless, we added the type $[\alpha]A$ of the level-indexed product of a family of types $A\ (\alpha\ \level)$.

Furthermore, we presented an extension where equational constraints between universe levels can be declared \cite{BezemCDE22}, building on a proposal by Voevodsky \cite{VV}. This extension can also be described by a gat, but we postpone this topic to a forthcoming paper.

\paragraph{Plan of the paper.} In Section 2 we present the infinitary gat of cwfs with extra structure for the type formers and an externally indexed tower of universes. We consider both cumulative and non-cumulative universes. In Section 3 we present the finitary gat of level-indexed type theory with extra structure for the type formers and an internally indexed tower of universes. (* In Section 4 we present the generalized algebraic theory of cwfs with extra structure doubly indexed by levels and level constraints *). (* In Section 5 we discuss models *). In Section 6 we conclude. (* The appendix presents the full definition of the gat for cws with explicit universe polymorphism. *)

\paragraph{Dedication.} We dedicate this article to professor Stefano Berardi, the University of Torino, on the occasion of his 60th birthday. Stefano is a valued friend, colleague, and coauthor, who spent the autumn of 1994 (check?) in the type theory group in Göteborg. He has made fundamental contributions to type theory and constructivity, in particular to the understanding of the constructive content of classical logic.

\section{Type theory with an external tower of universes}

\subsection{The gat of cwfs} A cwf consists of a base category $\C$ of contexts and context morphisms (substitutions), a family-valued presheaf
$$
T : \C^\op \to \Fam
$$
and a notion of context comprehension. Here $\Fam$ is the category of indexed families of sets $(A,B)$, where $A$ is the index set and $B$ is a family of sets indexed by $A$. The presheaf $T$ maps a context to the family of terms indexed by a type. The reader is referred to Dybjer \cite{dybjer:torino}, Hofmann \cite{hofmann:cambridge}, and Castellan et al \cite{castellan:lambek} for a full definition and further information about cwfs.

The gat of cwfs with extra structure for $\Pi$-types, a notion of model of Martin-Löf type theory with $\Pi$-types, was presented by Dybjer \cite{dybjer:torino}. The extra operator symbols and equations needed for the natural number type and one universe can for example be found in Bezem et al \cite{bezem:hofmann}. We will use the same notation for gats as in the latter paper. 

\paragraph{Sort symbols.}
The gat of cwfs has four sort symbols:
\begin{eqnarray*}
&\vdash& \ctx\\
\Delta, \Gamma : \ctx&\vdash& \hom(\Delta,\Gamma)\\
\Gamma : \ctx&\vdash& \ty(\Gamma)\\
\Gamma : \ctx, A : \ty(\Gamma)&\vdash& \tm(\Gamma,A)
\end{eqnarray*}
corresponding to the objects and morphisms of the category of contexts, and the family of terms indexed by types in a given context, respectively. The notation states that $\ctx$ is a constant sort symbol, that $\hom$ is a binary sort symbol depending on arguments $\Delta, \Gamma : \ctx$, that $\ty$ is a unary sort symbol depending on the argument $\Gamma : \ctx$, and $\tm$ is a binary sort symbol depending on arguments $\Gamma : \ctx, A : \ty(\Gamma)$.

\paragraph{Operator symbols.}
Moreover, the gat of cwfs has operator symbols for the basic operations of cwfs (identity and composition of context morphisms, substitution in types and terms, empty context and context morphism, context extension and context morphism extension, projection morphism, last variable term)\footnote{MB: should we separate them into four groups: structure for the base category, for the arrow part of the family valued functor, for the terminal object, and for context comprehension?}: 
\begin{eqnarray*}
\Gamma : \ctx &\vdash& \id_{\Gamma} : \Hom(\Gamma,\Gamma)\\
\Xi,\Delta,\Gamma : \ctx, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta) &\vdash&
\gamma \circ \delta : \Hom(\Xi,\Gamma)\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma) &\vdash&
A[\gamma] : \ty(\Delta)\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Gamma,A) &\vdash&  a[\gamma] : \tm(\Delta,A[\gamma])\\
&\vdash& 1 : \ctx\\
\Gamma : \ctx &\vdash& \tuple{}_\Gamma : \Hom(\Gamma,1)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \Gamma\cext A : \ctx\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash& \tuple{\gamma,a} : \Hom(\Delta,\Gamma\cext A)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \p_{\Gamma,A}: \Hom(\Gamma\cext A,\Gamma)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \q_{\Gamma,A}: \tm(\Gamma\cext A,A[\p])
\end{eqnarray*}
The first line states that identity is a unary operator symbol with argument $\Gamma : \ctx$. The second line states that $\circ$ is a binary operator symbol with five arguments $\Xi,\Delta,\Gamma : \ctx, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta)$ and result sort $\Hom(\Xi,\Gamma)$. Note that only two of the five official arguments are explicit. To alleviate notation, we often suppress arguments of operator symbols. Note also that we overload notation for type and term substitution $A[\gamma]$ and $a[\gamma]$.

\paragraph{Equations.}
Finally, the gat of cwfs has 13 equations. We illustrate the notation by showing one of the laws for identity morphisms.  The reader is referred to Bezem et al \cite{bezem:hofmann} for the remaining cwf-equations (maybe put them in the appendix).
\begin{eqnarray*}
\Delta, \Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma) &\vdash& \id_\Gamma \circ \gamma = \gamma : \Hom(\Delta,\Gamma)
%\\
%\Delta, \Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma) &\vdash& \gamma \circ \id_\Delta = \gamma : \Hom(\Delta,\Gamma)\\
%\Theta, \Xi,\Delta,\Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta), \xi : \Hom(\Theta,\Xi) &\vdash&
%(\gamma \circ \delta) \circ \xi = \gamma \circ (\delta \circ \xi): \Hom(\Theta,\Gamma)
\end{eqnarray*}
In the official notation both argument and result types are explicit. However, to alleviate notation we often drop them and only write:
\begin{eqnarray*}
\id_\Gamma \circ \gamma = \gamma
\end{eqnarray*}
However, there are specific cases where we need the official notation. Assume that we add an operator symbol for the identity type former $\Id$ in Martin-Löf type theory:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), a, a' : \tm(\Gamma, A) &\vdash \Id_{\Gamma,A}(a,a'): \ty(\Gamma)
\end{eqnarray*}
In extensional Martin-Löf type theory \cite{martinlof:hannover} we have the rule of equality reflection. This can be captured by an equation in gats:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), a, a' : \tm(\Gamma, A),p :  \tm(\Gamma,\Id_{\Gamma,A}(a,a'))&\vdash& a = a' : \tm(\Gamma,A)
\end{eqnarray*}
Note that the variable $p$ does not occur on the right hand side.
However, it is a very important variable expressing
the condition under which $a=a'$ holds and must not be omitted.
%We will meet a similar case for reflection on equality on level terms.

\subsection{The gat of cwfs with an external tower of universes}
In Bezem et al \cite{BezemCDE22} we began by displaying the inference rules for Martin-Löf type theory with an external tower of universes $\UU_l$, where $l \in \N$ is an external natural number. Here we show the operator symbols and equations for the corresponding gat.

We assume that we already have defined the gat of cwfs with the extra structure for the standard small type formers $\Pi, \Sigma, \N_0, \N_1, \N_2, \N, \W$, and $\Id$, and we wish to define a tower of universes closed under those. To save space, we shall however only display the operator symbols and equations for closure under $\Pi$-types, since it is straightforward to add similar operator symbols for closure under the other small type formers. We shall use the same convention throughout the paper.

\paragraph{Operator symbols.}
The operator symbol for $\Pi$-types is
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), B : \ty(\Gamma.A) &\vdash& \Pi_\Gamma(A,B) : \ty(\Gamma)
\end{eqnarray*}
and refer to Bezem et al \cite{bezem:hofmann} for the operator symbols for abstraction and application, equations for the $\beta$ and $\eta$ rule, and equations expressing that $\Pi$, abstraction, and application commute with term substitution.

In the gat for externally indexed universes we have the following families of operator symbols (the universes $\UU_l$, the decoding maps $\Ta_l$, codes for $\Pi$, and codes for $\UU_l$ in $\UU_m$):
\begin{eqnarray*}
\Gamma : \ctx &\vdash& (\U_{l})_\Gamma : \ty(\Gamma)\\
\Gamma : \ctx, a : \tm(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta_{l}}(a) : \ty(\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,(\U_0)_\Gamma) \\
\Gamma : \ctx,
a : \tm(\Gamma,(\U_{l})_\Gamma),
b :  \tm(\Gamma . \Ta_{l}(a), (\U_{l'})_\Gamma)
&\vdash&
 \Pihat^{l,l'}(a,b) : \tm(\Gamma,(\U_{l \vee l'})_\Gamma)\\
 \Gamma : \ctx&\vdash&(\UU^m_l)_\Gamma: \tm(\Gamma,(\UU_{m})_\Gamma)
\end{eqnarray*}
where $l, l' , m \in \NN$ with $l < m$. Note that codes for $\Pi$ are doubly indexed and $l \vee l' = \max(l,l')$.
We have again left some arguments to operator symbols implicit. For example, the decoding operators $\Ta_l$ are binary operators with official notation $\Ta_l(\Gamma,a)$. However, in the notation above we omit $\Gamma$ and write $\Ta_l(a)$.

\paragraph{Equations.}
We have the following decoding equations:
\begin{eqnarray*}
%\Ta(\N^0_\Gamma) &=& \N_\Gamma\\
\Ta_{l \vee l'}(\Pi^{l,l'}(a,b)) &=& \Pi(\Ta_l(a),\Ta_{l'}(b))\\
\Ta_{m}((\UU^m_l)_\Gamma) &=& (\UU_l)_\Gamma
\end{eqnarray*}

Moreover, the operator symbols commute with term substitution: 
\begin{eqnarray*}
(\U_l)_\Gamma [ \gamma ] &=& (\U_l)_\Delta\\
\Ta_l(a) [ \gamma ] &=& \Ta_l(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^{l,l'}(a,b)[ \gamma ] &=& \Pi^{l,l'}(a [ \gamma ], b[ \gamma^\dagger ])\\
(\UU^m_l)_\Gamma[ \gamma ] &=&(\UU^m_l)_\Delta
\end{eqnarray*}
where $\gamma : \Hom(\Delta,\Gamma)$ and $\gamma^\dagger = \langle \gamma \circ \p_{\Delta,\Ta_l(a[\gamma])}, \q_{\Delta,\Ta_l(a[\gamma])}\rangle : \Hom(\Delta.\Ta_l(a[\gamma]),\Gamma.\Ta_l(a))$.
%\paragraph{Adding cumulativity.}

If we want a cumulative tower of universes we add operator symbols that lift elements in the $l$th universe to the $m$th universe for $l < m$:
\begin{eqnarray*}
\Gamma : \ctx, a : \tm(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta^m_{l}}(a) : \tm(\Gamma,(\U_{m})_\Gamma))
\end{eqnarray*}
In the presence of cumulativity it suffices that codes for $\Pi$ have one superscript rather than two:
\begin{eqnarray*}
\Gamma : \ctx,
a : \tm(\Gamma,(\U_{l})_\Gamma),
b :  \tm(\Gamma \cdot \Ta_{l}(a), (\U_{l})_\Gamma))
&\vdash&
 \Pihat^{l}(a,b) : \tm(\Gamma,(\U_{l})_\Gamma)
 \end{eqnarray*}
 We omit the equations for the cumulative case, see instead the cumulative case for level-indexing.

\subsection{Syntax and inference rules as an initial model.}\label{initiality-external}
As already mentioned, the grammar and inference rules for an initial model can be obtained by a general construction for finitary gats \cite{bezem:hofmann} and this construction can be extended to infinitary gats. The recipe is to build the judgment structure of the theory from the sort symbols of the gat, and the syntax of raw terms, types, contexts and context morphisms from untyped versions of the cwf-combinators and the operator symbols of the gat. Then one defines a system of inference rules from the typings of the cwf-combinators and the operator symbols of the gat. This yields an explicit substitution calculus for dependent type theory quite similar to Martin-Löf's \cite{martinlof:gbg92,tasistro:lic} but with named variables replaced by projections of the form $\q[\p^n]$. 

We could also build an initial model by adapting the proof by Brunerie and de Boer \cite{Brunerie:initiality,deBoer:lic} that Martin-Löf type theory with an external tower of universes is an initial contextual category with appropriate extra structure for the type formers. Their version of Martin-Löf type theory is more traditional with implicit substitutions, that is, substitution is not a term constructor, but an operation defined by induction on the structure of terms. 

To adapt their construction to yield a model of our gat we would first need to replace their contextual categories by cwfs. Contextual categories are closely related to contextual cwfs, that is, cwfs where each context has a finite length \cite{castellan:lambek}. We expect that the implementation could be adapted accordingly, since initial cwfs are contextual. (We also remark that several equivalences and embeddings between categorical notions of models including cwfs have been implemented in UniMath by Ahrens, Lumsdaine, and Voevodsky \cite{AhrensLV18}.)
Moreover, Brunerie and de Boer's rules for universes are not the same as ours. They just have the rule $\UU_l : \UU_{l+1}$ and only consider the non-cumulative case, while we have $\UU_l^m$ for $\UU_l$ in any larger universe $\UU_m$ and consider both the non-cumulative and cumulative cases. We expect that it would be a modest amount of effort to adapt their construction to our universes.

There are also differences Brunerie and de Boer's version of Martin-Löf type theory and ours \cite{BezemCDE22} on the syntactic side. Firstly, they work with decorated terms following Streicher \cite{streicher:thesis} and we would need to do the same. Another difference is that they have a Russell-style tower while we have a Tarski-style. Note that the Russell versus Tarski distinction is not reflected in the gat. They are different only different options for the syntactic type theories.

\subsection{Internalization (* Remove? *)}
One might be tempted to internalize the externally indexed tower of universes by indexing universes by internal natural numbers: 
$$\Gamma : \ctx, l : \tm(\Gamma,\N) \vdash (\UU_l) : \ty(\Gamma)$$
%However, this would mean that we could build large types such as $\Pi l : \N.\U_l$ and $\Sigma l : \N.\U_l$ which increase the proof theoretic strength of type theory. 
Note that $l$ here depends on variables in the context $\Gamma$. 
A more cautious alternative would be to only
allow universes indexed by constant internal natural numbers:
$$ l : \tm(1,\N), \Gamma : \ctx \vdash (\UU_l) : \ty(\Gamma)$$

Similarly, Agda has a type $\Level$ of universe levels with a level 0 and a next level operation $(-)^+$, but also has an operation $\vee$ on levels. Moreover, levels satisfy the same equality judgments as our theory.

What is the best argument for not indexing by natural numbers?? Parametricity??

\section{Level-indexed type theory}

\subsection{The ucwf of levels} As already mentioned in the introduction, in Bezem et al \cite{BezemCDE22} we added special universe level {\em judgments}:
$$
l\ \level
\hspace{5em}
l = l'
$$
to the usual judgment forms of Martin-Löf type theory. Moreover, universe level variables as well as ordinary term variables can be declared in a context. As in Agda, we have a next level operation $(-)^+$ and an operation $\vee$ for join of levels. However, as in Bezem et al \cite{BezemCDE22}, we have no level 0 for the first universe. It follows that all universes are polymorphic.
Levels form an upper semilattice with respect to $\vee$ and $(-)^+$ is an inflationary operation, see below.

%\footnote{
%We shall now show the gat corresponding to the our theory where we do not have a type of levels but level judgments \cite{BezemCDE22}.
%This gat consists of the following parts:
%\begin{itemize}
%\item the ucwf of levels
%\item the ucwf-indexed cwf with $\Pi$-types and level-indexed universes
%\begin{itemize}
%\item the object part has sort symbols for level-indexed judgments and operator symbols for ...
%\item the arrow part has operator symbols for level-substitutions in all sorts of the cwfs that preserve all the structure.
%\end{itemize}
%\end{itemize}
%}
\paragraph{Sort symbols.} Levels can be organized as a ucwf. We have the following sort symbols:
\begin{eqnarray*}
&\vdash& \lctx\\
m, n : \lctx &\vdash& \lHom(m,n)\\
m : \lctx &\vdash& \ltm(m)
\end{eqnarray*}
standing for level context, level context morphism (substitution), and level term.
Since ucwfs are cwfs with only one type, we do not need a sort symbol for level types. 

\paragraph{Operator symbols.} The operator symbols for ucwfs are simplified versions of those for cwfs, where all dependence on types is removed:
%\footnote{We use  $\sigma,\tau$ for level substitutions.}
%\footnote{In other places we use $\lp$ and $\lq$. Same issue with $\cp$ and $\cq$.}
\begin{eqnarray*}
m : \lctx &\vdash& \lid_m : \lhom(m,m)\\
m, n, p : \lctx, \sigma : \lhom(n,p), \tau : \lhom(m,n) &\vdash&
\sigma \circ \tau : \lhom(m,p)\\
%&&\\
m,n: \lctx, \sigma : \lhom(n,m), l :\ltm(m) &\vdash&  l[\sigma] : \ltm(n)\\
%&&\\
&\vdash& 0 : \lctx\\
m : \lctx &\vdash& \tuple{}_m : \lhom(m,0)\\
%&&\\
m : \lctx &\vdash& \s(m) : \lctx\\
m,n : \lctx, \sigma : \lhom(n,m), l:\ltm(n) &\vdash& \tuple{\sigma,l} : \lhom(n,\s(m))\\
m : \lctx &\vdash& \lp_m: \lhom(\s(m),m)\\
m : \lctx &\vdash& \lq_m: \ltm(\s(m))
\end{eqnarray*}
Note that we no longer need an operator symbol for substitution in types but only for level terms. We also change the notation to suggest that these are operations on levels. For example, we use $\sigma$ and $\tau$ to range over level substitutions to distinguish them from term substitutions $\gamma$ and $\delta$. However, we keep the notation $\circ$ for composition of level substitutions, for level substitution in level terms $l[\sigma]$, for the empty level context morphism $\tuple{}_m$ and for context morphism extension $\tuple{\sigma,l}$. The notation for level contexts suggests that we have an initial ucwf where $n : \lctx$ is a natural number that records the number of available level variables. Thus $0 : \lctx$ is the terminal object in the ucwf.

The ucwf of levels also has operator symbols for next level and for the join of two levels:
\begin{eqnarray*}
m : \lctx, l : \ltm(m) &\vdash& l^+ : \ltm(m)\\
m : \lctx, l,l' : \ltm(m) &\vdash& l \vee l' : \ltm(m)
\end{eqnarray*}
%\end{tiny}

%\begin{tiny}
\paragraph{Equations.} 
We also have all the ucwf-equations, but we do not display them here. These are the cwf-equations (see Dybjer \cite{dybjer:torino} and Bezem et al \cite{BezemCDE22})
%appendix   \ref{sec:gatPiU}) 
for the special case that there is only one type, so that all type equations are redundant.

The semi-lattice equations for $l \vee l'$ are:
\begin{eqnarray*}
(l \vee l') \vee l'' &=& l \vee (l' \vee l'')\\
l \vee l' &=& l'\vee l\\
l \vee l &=& l
\end{eqnarray*}
and the equations for $l^+$ are:
\begin{eqnarray*}
l \vee l^+ &=& l^+\\
(l\vee l')^+ &=& l^+\vee l'^+
\end{eqnarray*}
The operator symbols $\vee$ and $+$ commute with level substitution:
\begin{eqnarray*}
(l \vee l')[\sigma] &=& l[\sigma] \vee l' [\sigma]\\
 l^+[\sigma] &=&  l[\sigma]^+
\end{eqnarray*}
%\end{tiny}
\paragraph{Lawvere theories.} We remark that uwfs are closely related to Lawvere theories, but closer to the usual syntax based on $n$-place functions. One can prove that the latter are equivalent to contextual ucwfs, that is, ucwfs where each context has a length \cite{castellan:lambek}.

\paragraph{Remark} on finitely presented semilattices and constraints?


\subsection{The level-indexed cwf of small types}

We now define the gat of ucwf-indexed cwfs with extra structure for the small type formers $\Pi,\Sigma,\N_0,\N_1,\N_2,\N,\W,\Id$. This is the theory of presheaves
$$
T : \L^\mathrm{op} \to \CwF^{\Pi,\Sigma,\N_0,\N_1,\N_2,\N,\W,\Id}
$$
valued in the category of cwfs with extra structure for the small type formers and cwf-morphisms preserving cwf-structure and the structure of the small type formers strictly. Thus
\begin{itemize}
\item
$T(n)$ is the cwf (with extra structure) of contexts, substitutions, types, and terms that depend on level variables in $n$.
\item
Let $\sigma : n \to m$ be a level substitution. In the initial model it is an $m$-tuple of level terms in $n$ level variables, and 
$T(\sigma) : T(m) \to T(n)$ substitutes the $m$ level variables by the respective $m$ level expressions in $\sigma$ in the various components of the cwf $T(m)$ yielding a cwf depending on $n$ level variables. All structure of the cwf with small type formers is preserved.
\end{itemize}

\paragraph{Sort symbols.} The gat for the level-indexed cwf of small types has the following sort symbols in addition to those of the gat of levels:
\begin{eqnarray*}
n : \lctx &\vdash& \ctx_n\\
n : \lctx, \Delta, \Gamma : \ctx_n &\vdash& \Hom_n(\Delta,\Gamma)\\
n : \lctx, \Gamma : \ctx_n &\vdash& \ty_n(\Gamma)\\
n : \lctx, \Gamma : \ctx_n, A:\ty_n(\Gamma) &\vdash& \tm_n(\Gamma,A)
\end{eqnarray*}
These are the same as the sort symbols of the gats of cwfs, except that they are all indexed by an argument $n : \lctx$.

\paragraph{Operator symbols.} Similarly, the operator symbols are the same as the operator symbols for cwfs (with extra structure for the small type formers), except that they are also indexed by $n : \lctx$. The equations are modified accordingly. See the appendix for the list of operator symbols and equations.

The arrow part of the level-indexed cwf of small types axiomatizes level substitution. There is one operator symbol for each component of the level-indexed cwf, but we overload notation:
\begin{eqnarray*}
n, n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'} &\vdash& 
\Gamma[\sigma] : \ctx_n\\
n, n' : \lctx , \sigma : \lhom(n,n'), \Delta,\Gamma : \ctx_{n'}, \gamma : \Hom_{n'}(\Delta,\Gamma) 
&\vdash& 
\gamma[\sigma] : \Hom_{n}(\Delta[\sigma],\Gamma[\sigma]) \\
n, n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'}, A:\ty_{n'}(\Gamma)
&\vdash& 
A[\sigma]: \ty_n(\Gamma[\sigma])\\
n,n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'}, A:\ty_{n'}(\Gamma), a : \tm_{n'}(A,\Gamma) 
&\vdash& 
a[\sigma] : \tm_{n}(A[\sigma],\Gamma[\sigma]) 
\end{eqnarray*}
\footnote{MB, check.}
\paragraph{Equations.}
The functor laws give us the following equations:
\begin{eqnarray*}
\Gamma[\lid_n] &=& \Gamma\\
\Gamma[\sigma \circ \tau] &=& \Gamma[\sigma][\tau]\\
\gamma[\lid_n] &=& \gamma\\
\gamma[\sigma \circ \tau] &=& \gamma[\sigma][\tau]\\
A[\lid_n] &=& A\\
A[\sigma \circ \tau] &=& A[\sigma][\tau]: \ty_p(\Gamma[\sigma \circ \tau])\footnote{We should give more information here.}\\
a[\lid_n] &=& a\\
a[\sigma \circ \tau] &=& a[\sigma][\tau]: \tm_p(A[\sigma \circ \tau],\Gamma[\sigma \circ \tau])
\end{eqnarray*}
Level substitution commutes with small type formers. We show the case for $\Pi$-types:

Let $n, n' : \lctx , \sigma : \lhom(n,n'), \Gamma : \ctx_{n'}, A:\ty_{n'}(\Gamma), B:\ty_{n'}(\Gamma.A)$. Then
\begin{eqnarray*}
\Pi(A,B)[\sigma] &=& \Pi(A[\sigma],B[\sigma])
\end{eqnarray*}
Moreover, if $b : \tm_n(\Gamma.A,B), c :  \tm_n(\Gamma,\Pi(A,B))$,  and $a : \tm_n(\Gamma,A)$, we have
\begin{eqnarray*}
\lambda(b)[\sigma] &=&\lambda(b[\sigma])\\
\app(c,a)[\sigma] &=&\app(c[\sigma],a[\sigma])
\end{eqnarray*}
This finishes the gat for level-indexed cwfs with small type formers.

\subsection{Level-indexed universes} 
\paragraph{Operator symbols and a new sort symbol for level equality.} 
We finally add the operator symbols and equations for level-indexed universes.
Each $T(n)$ has extra structure for level-indexed universes $\UU_l$ with decodings $\Ta_l$, where $l$ is a level term that depends on level variables in $n$. These universes are closed under the small type formers and contain smaller universes $\UU_{l'}$ for $l' < l$.

The operator symbols are obtained by internalizating the corresponding rules for the externally indexed universes. As before, we only show closure under $\Pi$. (Should we factor out common premises $n : \lctx, l : \ltm(n), \Gamma : \ctx_n$?)
\begin{eqnarray*}
n : \lctx, l : \ltm(n), \Gamma : \ctx_n &\vdash& (\U_{l})_\Gamma : \ty_n(\Gamma)\\
n : \lctx, l : \ltm(n), \Gamma : \ctx_n, a : \tm_n(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta_{l}}(a) : \ty_n(\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,(\U_0)_\Gamma) \\
n : \lctx, l, l' : \ltm(n), \Gamma : \ctx_n,
a : \tm_n(\Gamma,(\U_{l})_\Gamma),
b :  \tm_n(\Gamma \cdot \Ta_{l}(a), (\U_{l'})_\Gamma)
&\vdash&
 \Pihat^{l,l'}(a,b) : \tm_n(\Gamma,(\U_{l \vee l'})_\Gamma)
\end{eqnarray*}
However, when we try to internalize the operator symbols $\UU^m_l$ for universes $\UU^l$ in larger universes $\UU^m$, where $l < m$, we encounter a problem. The following attempt
\begin{eqnarray*}
n : \lctx, l, m : \ltm(n), l < m, \Gamma : \ctx_n&\vdash&(\UU^m_l)_\Gamma: \tm_n(\Gamma,(\UU_{m})_\Gamma)
\end{eqnarray*}
where $l < m$ is defined as $l^+ \vee m = m$, does not work since equations are not allowed in argument types in gats. This issue can be resolved by introducing a new sort symbol for level equality:
\begin{eqnarray*}
n : \lctx, l, l'  : \ltm(n) &\vdash& \leq_n(l,l')
\end{eqnarray*}
and an operator symbol for reflexivity:
\begin{eqnarray*}
n : \lctx, l : \ltm(n) &\vdash& \refl(l) :  \leq_n(l,l)
\end{eqnarray*}
Note that if we can derive 
\begin{eqnarray*}
n : \lctx, l, l'  : \ltm(n) &\vdash& l = l' : \ltm(n)
\end{eqnarray*}
in the initial model, then we can also derive
\begin{eqnarray*}
n : \lctx, l,l' : \ltm(n) &\vdash& \refl(l) :  \leq_n(l,l')
\end{eqnarray*}
by preservation of equality which is available in all gats.
\footnote{Can we prove the following:
If we have derivations
\begin{eqnarray*}
\vdash n : \lctx, \vdash l,l' : \ltm(n), \vdash p :  \leq_n(l,l')
\end{eqnarray*}
then $\vdash p = \refl(l) : \leq(l,l')$ and $\vdash l = l' : \ltm(n)$.
}

We now redefine $l < m$ as $\leq_n(l^+ \vee m, m)$ and get a proper typing of the operator symbol $\UU^m_l$:
\begin{eqnarray*}
n : \lctx, l, m : \ltm(n), p : l < m, \Gamma : \ctx_n&\vdash&(\UU^m_l)_{p,\Gamma} : \tm_n(\Gamma,(\UU_{m})_\Gamma)
\end{eqnarray*}
In the sequel we will suppress the proof $p : l < m$ as an argument to this operator symbol and just write $(\UU^m_l)_{\Gamma}$.

\paragraph{Level equality.} The sort symbol $\leq$ is analogous to the identity type former $\Id$ in Martin-Löf type theory. We can think of $\leq_n(l,l')$ as propositional level equality and its elements $p : \leq_n(l,l')$ as proofs of propositional level equality. However, while proofs $p : \Id(A,a,a')$ can make use of advanced logical reasoning, proofs of level equality can only be constructed from reflexivity and general reasoning available in all gats.%\footnote{How to say this rigorously? We can of course use general reasoning available in any initial gat, including reasoning about judgmental level equality.}

\paragraph{Equations.}
The decoding equations for $\Ta_l$ and the equations for commutativity of operator symbols with substitution can be obtained by a straightforward internalization of the corresponding equations for the external tower. This means that the decoding equations are now relative to internal level contexts and level terms, as well as to terms. For example the decoding equation for $\Pi$ 
\begin{eqnarray*}
\Ta_{l \vee l'}(\Pi^{l,l'}(a,b)) = \Pi(\Ta_l(a),\Ta_{l'}(b)) :\tm_n(\Gamma,\UU_{l \vee l'})
\end{eqnarray*}
is now relative to the context
$$
n : \lctx, l, l' : \ltm(n), \Gamma : \ctx_n, a : \tm_n(\Gamma,\UU_l), b : \tm_n(\Gamma.\Ta_l(a),\UU_{l'} )
$$
and the decoding equation for the $l$th universe in the $m$th
\begin{eqnarray*}
\Ta_{m}((\UU^m_l)_\Gamma) &=& (\UU_l)_\Gamma
\end{eqnarray*}
is now relative to the context
$$
n : \lctx, l, m : \ltm(n), p : l < m
$$
where again $l < m$ is defined as $\leq_n(l^+ \vee m, m)$.

Equations for commutativity of operator symbols wrt substitution:
\begin{eqnarray*}
\Ta^m_l(a) [ \gamma ] &=& \Ta^m_l(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^{l}(a,b)[ \gamma ] &=& \Pi^{l}(a [ \gamma ], b[ \gamma^\dagger ])
\end{eqnarray*}
 where $\gamma : \hom(\Delta,\Gamma)$.
 
We also have equations for commutativity of lifting and $\Pi$-codes with respect to term substitution $\gamma$:
 \begin{eqnarray*}
(\U_l)_\Gamma [ \gamma ] &=& (\U_l)_\Delta\\
\Ta_l(a) [ \gamma ] &=& \Ta_l(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^{l,l'}(a,b)[ \gamma ] &=& \Pi^{l,l'}(a [ \gamma ], b[ \gamma^\dagger ])\\
(\UU^l)_\Gamma[ \gamma ] &=&(\UU^l)_\Delta
\end{eqnarray*}


\subsection{Adding cumulativity} 
\paragraph{Operator symbol.}
Adding an operator symbol for cumulativity is obtained by internalizing the lifting operations in the external tower:
\begin{eqnarray*}
n : \lctx, l,m : \ltm(n), l < m, \Gamma : \ctx_n, a : \tm_n(\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta^m_{l}}(a) : \tm(\Gamma,(\U_{m})_\Gamma))
\end{eqnarray*}
where again $l < m$ is defined as $\leq_n(l^+ \vee m, m)$. However, unlike for the external tower of universes, we need double superscripts on codes $\Pi^{l,l'}$ also in the cumulative case. 
%This is because, unlike in the external case, we to the greater in general.

\paragraph{Equations.}
We have the following decoding equation for lifting of codes for $\Pi$:
\begin{eqnarray*}
\Ta^{m \vee m'}_{l \vee l'}(\Pi^{l,l'}(a,b)) = \Pi^{m,m'}(\Ta^m_l(a),\Ta^{m'}_{l'}(b)) &:& \tm_n(\Gamma,(\UU_{l \vee l'})_\Gamma)
\end{eqnarray*}
where $n, \lctx,l',m,m' : \ltm(n), l < m, l' < m', \Gamma : \ctx_n, a : \tm_n(\Gamma,(\UU_l)_\Gamma), b : \tm_n(\Gamma.\Ta_l(a),(\UU_{l'})_\Gamma)$.
The decoding equation for lifting of codes for universes is as follows:
\begin{eqnarray*}
n : \lctx, k, l, m : \ltm(n), k < l < m, \Gamma : \ctx(n) &\vdash& \Ta^m_l((\UU^l_k)_\Gamma) = (\UU^m_k)_\Gamma
\end{eqnarray*}
Equations for commutativity of lifting and substitution ($\gamma : \hom(\Delta,\Gamma)$):
\begin{eqnarray*}
\Ta^m_l(a) [ \gamma ] &=& \Ta^m_l(a[ \gamma ] )
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
%\Pi^{l}(a,b)[ \gamma ] &=& \Pi^{l}(a [ \gamma ], b[ \gamma^\dagger ])
\end{eqnarray*}

Moreover, we have laws that level substitution $\sigma$ commutes with the operator symbols for a universe.
 \begin{eqnarray*}
 (\U_{l})_\Gamma[\sigma] &=& (\U_{l[\sigma]})_{\Gamma[\sigma]}\\
 \Ta_l(a) [ \sigma ] &=& \Ta_{l[\sigma]}(a[ \sigma ] )\\
\Pi^{l,l'}(a,b)[ \sigma ] &=& \Pi^{l[ \sigma ] ,l'[ \sigma ] }(a [ \sigma ], b[ \sigma])\\
(\UU^l)_\Gamma[ \sigma ] &=&(\UU^{l[ \sigma ]} )_{\Delta[ \sigma ]} 
 \end{eqnarray*}
%Check that this is right. Cf comment by intern.

\subsection{Syntax and inference rules as an initial model} 
Here we can directly use the general construction of an initial model for finitary gats \cite{bezem:hofmann} yielding an explicit substitution calculus for dependent type theory with level judgments.

An alternative is again to use Brunerie and de Boer's construction of an initial model of Martin-Löf type theory with an external tower of universes \cite{Brunerie:initiality,deBoer:lic} as a starting point. In Section \ref{initiality-external} we discussed how to modify their construction to yield an initial model of our gat for Martin-Löf type theory with an external tower of universes. To turn this construction into one for level-indexed Martin-Löf type theory we need to extend the grammar with level terms, and add inference rules for level judgments. Then we need to show (i) how to organize the level terms and level judgments into an initial ucwf of levels; (ii) how to construct a level-indexed cwf of small types \ref{level-indexed-cwf} by modifying the construction of a cwf of small types; and (iii) how to construct an initial model of the level-indexed universes by modifying the construction of an initial model of the externally indexed universes.

We first explain how to construct a ucwf of levels by extending Brilakis' construction in Agda of the equivalence between two initial ucwfs: one with explicit substitutions and one with implicit substitution and de Bruijn variables \cite{Brilakis18}. Since the ucwf with explicit substitutions is constructed directly from the operator symbols of ucwfs, Brilakis' proof is essentially the same as proving the initiality of the ucwf with implicit substutions. To prove the initiality of the ucwf of levels, we only need to extend Brilakis' proof with the the extra structure for $\vee$ and $(-)^+$.
\begin{itemize}
\item We use de Bruijn indices as level variables and $n : \lctx$ is the number of available ones.
\item An element of $\ltm(n)$ is an equivalence class of level terms generated by $\vee$ and $(-)^+$ from level variables with respect to the equivalence relation generated by the equations for $\vee$ and $(-)^+$. In our type theory with explicit substitution \cite{BezemCDE22} this corresponds to the level terms $l$ such that 
$$
\Gamma \vdash l\ \level
$$
and $\Gamma$ contains $n$ level variables. Two terms $l, l' : \ltm(n)$ are equivalent provided
$$
\Gamma \vdash l = l'
$$
\item An element of $\lhom(m,n)$ is a sequence of length $n$ of elements of $\ltm(m)$.
\item We refer to Brilakis for the definition of the ucwf-operations. Note that level substitution $l[\sigma]$ is an implicit operation defined by induction on $l$.
% If $n = (\alpha_n, \ldots, \alpha_1)$ and $\s(n) =  (\alpha_n, \ldots, \alpha_1, \alpha_0)$ are lists of distinct level variables, then $\lp_n = (\alpha_n, \ldots, \alpha_1) : \lhom(\s(n),n)$ and $\lq_n = \alpha_0 : \ltm(\s(n))$ are the projections.
\end{itemize}

The next step is construct the initial of the gat for level-indexed cwfs with small types. For the initiality construction it is convenient to work with contexts of the form $n,\Gamma$, where $n$ is the number of level variables, and $\Gamma$ is a context which depends on these $n$ level variables. Note that in Bezem et al both level variables and term variables are named and may appear in an arbitrary order in a context. (We could actually follow Brunerie and de Boer rather closely, and then it is a little different.)
\begin{itemize}
\item We define $\ty_n(\Gamma)$ as the set of equivalence classes of raw types $A$ such that $n, \Gamma \vdash A$ is a type and $A.A'$ are equivalent provided $n, \Gamma \vdash A = A'$.
\item We define $\tm_n(\Gamma,A)$ as the set of equivalence classes of raw terms $a$ such that $n, \Gamma \vdash a : A$ and $a.a'$ are equivalent provided $n, \Gamma \vdash A = A'$.
\item We define $\ctx_n$ as lists of types.
\item Finally, $\hom_n(\Delta,\Gamma)$ are lists of $\tm_n(\Delta,A)$.
\item The level equality sort $p : \leq_n(l,l')$ is interpreted as a one element sort provided $l = l' : \ltm(n)$.
\end{itemize}
 
The final part of the proof is about the arrow part of the level-indexed cwf with small types and level-indexed universes. In $\TTUP$ the different forms of level substitution and composition (in levels, level morphisms, contexts, context morphisms, types and terms) are all defined implicitly by induction on the respective syntactic categories. It follows directly that such level substitution satisfy the appropriate gat-equations, and that they are the unique operations doing so.

%In our old paper have the following introduction rule for cumulative universes with its decoding equation:
%$$
%\frac{l < m}
%{\UU^m_l : \UU_m\hspace{3em}\Ta_m(\UU^m_l) = \UU_l}
%$$
%where the context $\Gamma$ is implicit.

%\footnote{If  $n$ is the length of the level context, then level expressions have normal forms 
%$$
%\alpha_1^{+^{p_1}} \vee \cdots \vee \alpha_m^{+^{p_m}}
%$$ 
%for $p_i \geq 0$ for $1 \le i \le m \le n$ . We have 
%$$
%\alpha_1^{+^{p_1}} \vee \cdots \vee \alpha_m^{+^{p_m}} 
%< 
%\alpha_1^{+^{q_1}} \vee \cdots \vee \alpha_m^{+^{q_m}} \vee \alpha_{m+1}^{+^{q_{m+1}}} \vee \cdots \vee \alpha_{m'}  ^{+^{q_{m'}}}
%$$ 
%provided $p_i < q_i$ for $1 \le i \le m \le m' \le n$.} 

\subsection{Level-indexed products of types}
%We add three operator symbols in addition to the operator symbols for cwfs in Section 5.2 and 5.3:
\def\l{\mathrm{l}}
%\begin{tiny}
In $\TTUP$ we also introduced operations of 
universal level quantification with level abstraction and application of a term to a level. The corresponding operator symbols are
\begin{eqnarray*}
n : \lctx, \Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp])&\vdash& \forall_\l(B) : \ty_n(\Gamma)\\
n : \lctx, \Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp]), b : \tm_{\s(n)}(\Gamma[\lp], B) &\vdash& \lambda_\l(b) : \tm_n(\Gamma,\forall_\l(B))\\
n : \lctx, \Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp]), c :  \tm_n(\Gamma,\forall_\l(B)), l : \ltm(n) &\vdash& \app_\l(c,l) : \tm_n(\Gamma, B[\tuple{\lid,l}])
\end{eqnarray*}
Equations ($\beta$ and $\eta$ for level abstraction and application):
 \begin{eqnarray*}
 \app_\l(\lambda_\l(b),l) &=& b[\tuple{\lid,l}]\\
 \lambda_\l(\app_\l(c[\lp],\lq)) &=& c
 \end{eqnarray*}
 Equations for commutativity of operator symbols with respect to level substitution
 \begin{eqnarray*}
 \forall_\l(B)[ \gamma ] &=& \forall_\l(B[ \gamma[\lp]])\\
 \lambda_\l(B)[ \gamma ] &=& \lambda_\l(B[ \gamma[\lp]])\\
 \app_\l(c,l)[ \gamma ] &=& \app_\l(c[ \gamma ] ,l[ \gamma ] )\\
 \forall_\l(B)[ \sigma ] &=& \forall_\l(B[ \sigma^{+}])\\
 \lambda_\l(B)[ \sigma ] &=& \lambda_\l(B[ \sigma^{+}])\\
\app_\l(c,l)[ \sigma ] &=& \app_\l(c[ \sigma ] ,l[ \sigma ] )
\end{eqnarray*}
where $\gamma : \hom_n(\Delta,\Gamma)$ is a term substitution, and $\sigma : \lhom(m,n)$ is a level substitutuion with $\sigma^+ = \tuple{\sigma \circ \lp, \lq}$. 
To check the type of the equation
$$ \forall_\l(B)[ \sigma ] = \forall_\l(B[ \sigma^{+}])$$ we assume $\Gamma : \ctx_n, B : \ty_{\s(n)}(\Gamma[\lp])$. It follows that $B[\sigma^+] : \ty_{s(m)}(\Gamma[\lp][\sigma^+]) = \ty_{s(m)}(\Gamma[\sigma][\lp])$. Hence 
$\forall_\l(B[ \sigma^{+}]) : \ty_m(\Gamma[\sigma])$.

\paragraph{Universal quantification in predicate logic.} In the introduction we mentioned that untyped predicate logic can be captured by ucwf-indexed scwfs. (This gives a proof-relevant logic, just like Lawvere's hyperdoctrines \cite{lawvere:hyperdoctrines}.) We note that the operator symbols and equations for universal quantification in untyped predicate logic are the same as those for universal level quantification above, except the difference between scwfs and cwfs: propositions in predicate logic do not depend on proofs.

\section{Conclusion and further research}

\begin{itemize}
\item More rigorous proofs of initiality of type theory with explicit polymorphism and implicit substitution. Mechanization would be a big project although not too big if one could build on Brunerie and de Boer.
\item It would be interesting to have a generic proof of initiality of type theories with implicit substitution. The operator symbols that are defined implicitly in the model can already be specified on the gat-level.
\item Finish the section on the gat for constraints.
\item Work on gat for dependently typed predicate logic using cwf-indexed scwfs. Compare with Palmgren's work on hyperdoctrines above a cwf, and his discussion of the systems of Makkai, Gambino-Aczel, and Belo.
\end{itemize}
As related work we might want to mention qiits. Qiits are inductively defined (initial) gats inside dependent type theory. Unlike gats they have elimination rules. We have the sequence: inductive type, inductive family, inductive-inductive type, quotient inductive-inductive type. In the work of Kaposi, Kovacs, and Altenkirch there are various classes of qiits. The correspondence between these and the class of gats has not been investigated.

In principle we should also survey other approaches to the initiality conjecture, like Uemura.

%and $\gamma^\dagger = \tuple{\gamma \circ \p, \q}$??
%\end{tiny}
%\footnote{Discussion with Raphael Sterback:
%$$
%\forall_l (B)[\gamma] = \forall_l (B[\gamma[\lp]])
%$$}
\appendix
\section{Complete gat for explicit universe polymorphism}

We will in this appendix display the gat for ucwf-indexed cwfs with extra structure for level-indexed universes closed under small type formers. We will here add the rules omitted in section 3.

\subsection{The ucwf of levels}

We already listed the sort symbols and operator symbols. The equations are
\begin{eqnarray*}
\lid_{n} \circ \sigma &=& \sigma \\
 \sigma \circ \lid_{n} &=& \sigma \\
(\sigma \circ \tau) \circ \upsilon &=& \sigma \circ (\tau \circ \upsilon)\\
%&\vdash& 
%A[\id_{n}] &=& A \\
%a:\tm_n(\sigma,A) &\vdash& 
l[\lid_{n}] &=& l \\
%n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \delta : \Hom_n(\Xi,\Delta), \gamma : \Hom_n(\Delta,\Gamma),
%&\vdash& 
%A[\gamma\circ\delta] &=&A[\gamma][\delta]\\
%: \ty_n(\Xi)\\
%n : \lctx, \Xi,\Delta, : \ctx_n, \delta : \Hom_n(\Xi,\Delta), \gamma : \Hom_n(\Delta,\Gamma),
%a:\tm_n(\Gamma,A) &\vdash&
l[\sigma\circ\tau] &=& l[\sigma][\tau]\\
%: \tm_n(\Xi,A[\gamma\circ\delta])\\
%n : \lctx &\vdash& 
\lid_{0} &=& \tuple{}_{0}\\
 %: \Hom_n(1_n,1_n)\\
%\Gamma,\Delta : \ctx_n , \gamma : \Hom_n (\Delta,\Gamma) &\vdash&
\tuple{}_{n}\circ\sigma &=& \tuple{}_{m}\\
\lp_n \circ \tuple{\sigma,l} &=& \sigma\\
\lq_n [\tuple{\sigma,l}] &=& l\\
\lid_{\s(n)} &=& \tuple{\lp_n,\lq_n}\\
\tuple{\sigma,l} \circ \tau &=& \tuple{\sigma \circ \tau,l[\tau]}
\end{eqnarray*}

\subsection{The level-indexed cwf of small types}

We already listed the sort symbols. The operator symbols are
%We have the following sort symbols:
%\begin{eqnarray*}
%n : \lctx &\vdash& \ctx_n\\
%n : \lctx, \Delta, \Gamma : \ctx_n &\vdash& \Hom_n(\Delta,\Gamma)\\
%\end{eqnarray*}
\begin{eqnarray*}
n : \lctx, \Gamma : \ctx_n &\vdash& \id_{n,\Gamma} : \Hom_n(\Gamma,\Gamma)\\
n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \gamma : \Hom_n(\Delta,\Gamma), \delta : \Hom_n(\Xi,\Delta) &\vdash&
\gamma \circ \delta : \Hom_n(\Xi,\Gamma)\\
n : \lctx, \Gamma,\Delta : \ctx_n, A:\ty_n(\Gamma), \gamma : \Hom_n(\Delta,\Gamma) &\vdash&
A[\gamma] : \ty_n(\Delta)\\
n : \lctx, \Gamma,\Delta : \ctx_n, A:\ty_n(\Gamma), \gamma : \Hom_n(\Delta,\Gamma), a:\tm_n(\Gamma,A) &\vdash&  a[\gamma] : \tm_n(\Delta,A[\gamma])\\
n : \lctx &\vdash& 1_n : \ctx_n\\
n : \lctx, \Gamma : \ctx_n &\vdash& \tuple{}_{n,\Gamma} : \Hom_n(\Gamma,1_n)\\
&\vdots&\\
\end{eqnarray*}
We need to add operator symbols for context comprehension.

The equations are
\begin{eqnarray*}
\id_{n,\Gamma} \circ \gamma &=& \gamma \\
 \gamma \circ \id_{n,\Delta} &=& \gamma \\
(\gamma \circ \delta) \circ \xi &=& \gamma \circ (\delta \circ \xi)\\
%&\vdash& 
A[\id_{n,\Gamma}] &=& A 
%: \ty_n(\Gamma)
\\
%a:\tm_n(\Gamma,A) &\vdash& 
a[\id_{n,\Gamma}] &=& a% : \tm_n(\Gamma,A)
\\
%n : \lctx, \Xi,\Delta,\Gamma : \ctx_n, \delta : \Hom_n(\Xi,\Delta), \gamma : \Hom_n(\Delta,\Gamma),
%&\vdash& 
A[\gamma\circ\delta] &=& A[\gamma][\delta]
%: \ty_n(\Xi)
\\
%n : \lctx, \Xi,\Delta, : \ctx_n, \delta : \Hom_n(\Xi,\Delta), \gamma : \Hom_n(\Delta,\Gamma),
%a:\tm_n(\Gamma,A) &\vdash&
a[\gamma\circ\delta] &=& a[\gamma][\delta]
%: \tm_n(\Xi,A[\gamma\circ\delta])
\\
%n : \lctx &\vdash& 
\id_{n,1_n} = \tuple{}_{1_n} 
%: \Hom_n(1_n,1_n)
\\
%\Gamma,\Delta : \ctx_n , \gamma : \Hom_n (\Delta,\Gamma) &\vdash&
\tuple{}_{n,\Gamma\circ\gamma} = \tuple{}_{n,\Delta}% : \Hom_n (\Delta,1_n )
\\
&\vdots&
\end{eqnarray*}
We need to add equations for context comprehension.

\footnote{MB, check. Perhaps better to describe how to modify \ref{sec:gatPiU}:
prefix every rule with $n:\lctx$ and add index $n$ to every occurrence
of $\ctx,\ty,\tm$.}

We also need to add rules for level-indexed $\Pi$

\subsection{Level-indexed universes}   

Check whether some operator symbols and equations were left out.

%\begin{itemize}
%\item
%Object part of the functor $\L \to \CwF^{\Pi,\UU_l}$
%\begin{itemize}
%\item Level-indexed contexts and context-morphisms
%\item Level-indexed types and terms
%\end{itemize}
%\item
%Arrow part of the functor $\L \to \CwF^{\Pi,\UU_l}$
%\begin{itemize}
%\item Level-substitution in contexts and context-morphisms
%\item Level-substitution in types and terms
%\end{itemize}
%\end{itemize}

\section{Adding level-constraints}

\subsection{The level-indexed scwf of level constraints}

Constraints are lists of equations between level terms. We formalize the theory of constraints as level-indexed scwfs $(\cctx, \chom, \cty, \ctm)$.\footnote{Maybe we don't need the full scwf structure, but only lists of identities and projections to pull them out.} The gat of level-indexed scwf is the same as the gat of level-indexed cwfs defined above, except that in a scwf types don't depend on type contexts.\footnote{In a level-indexed scwf, types do depend on level contexts, though.} \footnote{In the published paper all constraint contexts are loop-free "The second condition is that the finite set of constraints in the extended context $\Gamma, \psi$ is loop-free." Here we prefer to allow arbitrary constraints as a first step. As a second step, suggested by Georges Gonthier, we add a rule that all types are equal to the unit type in a context that is not loop-free. Such a theory still has decidable type-checking.}

The following new sort symbols come from the structure of a level-indexed scwf:
\begin{eqnarray*}
n : \lctx &\vdash& \cctx_n\\
n : \lctx, \psi : \cctx(n), \psi' : \cctx(n) &\vdash& \chom_n(\psi,\psi')\\
n : \lctx &\vdash& \cty_n\\
n : \lctx, \psi : \cctx_n, c : \cty_n &\vdash& \ctm_n(\psi,c)
\end{eqnarray*}

The extra structure for level-indexed scwfs is given by the following operator symbol $\leq$ for {\em level equality} as types in the level-indexed scwf of constraints\footnote{equality reflection in ordinary type theory is the following equation in generalized algebraic theories:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), a, a' : \tm(\Gamma, A),p :  \tm(\Gamma,\Id_A(a,a'))&\vdash& a = a' : \tm(\Gamma,A)
\end{eqnarray*}
}
\begin{eqnarray*}
n : \lctx, l, l' : \ltm_n &\vdash& \leq(l,l') : \cty_n
\end{eqnarray*}
A constraint type $c : \cty_n$ is a level equation 
$\leq(l,l')$ in $n$ variables reflecting a level equation $l = l'$.
We note that $\leq$ is the only constructor for constraint types $\cty$. 
Consequently, by the basic structure for level-indexed scwfs,
a constraint "context" $\psi : \cctx_n$ is a list of constraint types, 
that is, a list of level equation types in $n$ variables. 
A constraint "term" $p : \ctm_n(\psi,c)$ is a proof that the equation $c$ is
in $\psi$.
% imply the equation $c$, see \cref{exa:cctx-entails-lattice-eqs}
%and \cref{lem:cctx-entails-lattice-eqs}.%
\footnote{We don't need 
any term constructors for $\leq$ beyond $\q$ from the basic
scwf set up. The reason is that all reasoning about level equations 
(except using a constraint assumption) is done using judgmental equalities.} 

Reasoning about level equality will be performed on the judgmental level. To this end we introduce a new sort for level terms with respect to constraints:
\begin{eqnarray*}
n : \lctx, \psi : \cctx_n &\vdash& \ltmq_n(\psi)
\end{eqnarray*}
This is to be understood as the quotient sort of $\ltm$ with respect to the equivalence relation generated by the constraints in $\psi$.
%and the laws for $\vee$ and $(-)^+$. 
We have a new operator symbol $[-]_{-}$ for equivalence class formation with its equation:
\begin{eqnarray*}
n : \lctx, \psi : \cctx_n,  l : \ltm_n &\vdash& [l]_\psi  : \ltmq_n(\psi)\\
n : \lctx, \psi : \cctx_n,  l, l' : \ltm_n, p : \ctm_n(\psi,\leq(l,l')) &\vdash& [l]_\psi  = [l']_\psi  : \ltmq_n(\psi)
\end{eqnarray*}
Note that the equation is a version of equality reflection: from a "propositional" level equality $\leq(l,l')$ we derive a judgmental level equality, and it is the latter that enables equational reasoning about $\vee$ and $(-)^+$ and $\psi$.
\begin{example}\label{exa:cctx-entails-lattice-eqs}
In our old paper we have a judgment form $\Gamma \vdash \psi\ \valid$ that expresses that the constraints in $\psi$
hold in $\Gamma$, that is, are implied by the constraints in $\Gamma$.
For example, if $\alpha$ and $\beta$ are level variables we can prove
$$
\alpha = \alpha\vee\beta, \beta\vee\alpha = \beta \vdash \alpha = \beta\ \valid
$$
by equational reasoning using commutativity of $\vee$ (one of the semilattice laws) in our system.

What does this correspond to in the present setting? Recall that each gat with sort symbols, operator symbols and equations in $\Sigma$ has an initial model $\T_\Sigma$. As shown in our paper on gats and cwfs, this can be defined as a variable free, explicit substitution calculus for dependent type theory built from cwf-combinators and the operator symbols in $\Sigma$\cite{bezem:hofmann}. In this calculus the above judgment corresponds to a level equation
$$
[\alpha]_{\psiab} = [\beta]_{\psiab} : \ltmq_2(\psiab)
$$
This is a judgment in the level context $2 = \s(\s(0)) : \lctx$ and the variables are defined as the projections $\alpha = \q[\p] : \ltm_2$ and $\beta = \q  : \ltm_2$ in the ucwf of levels. Moreover, 
$$
\psiab = 1.\leq(\alpha,\alpha\vee\beta).\leq(\beta\vee\alpha,\beta) : \cctx_2
$$
is a constraint context. The derivation of this in $\T_\Sigma$ uses that 
$\alpha$ and $\beta$ are level terms, and so are, 
$\alpha\vee\beta$ and $\beta\vee\alpha$, all in $\ltm_2$.
Hence we have the level equality types
$\leq(\alpha,\alpha\vee\beta)$ and $\leq(\beta\vee\alpha,\beta)$ both in $\cty_2$. Hence, we can form the constraint context $\psiab : \cctx_2$.
%$1.\leq(\alpha,\alpha\vee\beta).\leq(\beta\vee\alpha,\beta) : \cctx_2$,
%which we name $\psiab : \cctx_2$ for short.
We now instantiate the equation for equality reflection
with $n := 2$, $l :=  \beta\vee\alpha, l':= \beta, \psi:= \psiab$, and $p := \q: \ctm_2(\psiab,\leq(\beta\vee\alpha,\beta))$\footnote{check signs for instatiation and definition}
as above and get 
\[
%p : \ctm_2(\psiab,\leq(\beta\vee\alpha,\beta))
%\vdash 
[\beta\vee\alpha]_{\psiab} = [\beta]_{\psiab} : \ltmq_2(\psiab).
\]
We have used that the
level equality type $\leq(\beta\vee\alpha,\beta)$ is the last type
of the constraint context $\psiab$, so that we can use the operator $\q$ 
from the basic vocabulary of cwfs, see \ref{XYZ}.
%Thus the equation for equality reflection gives us:
%\[
%\vdash [\beta\vee\alpha]_{\psiab} = [\beta]_{\psiab} : \ltmq_2(\psiab)
%\]
that is, (MB: discuss) $\beta\vee\alpha$ and $\beta$ are equivalent
modulo $\psiab$, in the empty context.)

In much the same way, using the instantiation $l := \alpha,
l' := \alpha\vee\beta$ and $p := \q[\p]$ instead of $\q$, we get
\[
%p : \ctm_2(\psiab,\leq(\alpha,\alpha\vee\beta))
%\vdash 
[\alpha]_{\psiab}=[\alpha\vee\beta]_{\psiab} : \ltmq_2(\psiab).
\]
that $\alpha$ and $\alpha\vee\beta$ are equivalent modulo $\psiab$, 
in the empty context.

Next we explain how we can get, e.g.,
$
%\vdash 
[\alpha]_{\psiab} = [\beta]_{\psiab} : \ltmq_2(\psiab).
$
This result cannot be obtained by simply using the transitivity of $=$,
we also have to show that
$
%\vdash 
[\beta\vee\alpha]_{\psiab}=[\alpha\vee\beta]_{\psiab} : \ltmq_2(\psiab).
$
The latter follows from 
$
%\vdash 
\beta\vee\alpha=\alpha\vee\beta : \ltm_2$ and the fact that operator symbols preserve equality in gats.
\end{example}


An important observation in the above example is that
both $\leq(\alpha,\alpha\vee\beta)$ and $\leq(\beta\vee\alpha,\beta)$
are elements of $\psiab$, so that we can use the projections $\q$, $\q[\p]$. If there
are more elements in a constraint context, we can use the further projections $\q[\p][\p], \q[\p][\p][\p], \ldots$
to access the other equations in the constraint list.

%\begin{conjecture}\label{conj:cctx-entails-lattice-eqs}
\paragraph{The initiality conjecture for constraints.} We would like to extend the proof in section to 3 to constraints. Roughly, we need to show the following.
Let $n:\lctx$ be a level context, $l,l':\ltm_n$ level terms and 
$\psi:\cctx_n$ a constraint context. Then (in any initial model)
%\begin{eqnarray*}
%&\vdash& 
$$
[l]_\psi = [l']_\psi  : \ltmq_n(\psi)
$$
iff
$$
\psi^* \vdash l^* = l'^*
$$
in the system of our old paper, and $\psi^*$ (of length $n$) is the interpretation of $\psi$ in the initial gat generated by the system of our old paper. Similarly, the interpretation $l^*$ of $l : \ltm_n$ is a level term where variable names in $l^*$ have replaced the projections.
%\end{conjecture}

\subsection{The level- and constraint-indexed cwf of types}

{\bf All of this needs to be rethought!}

Let 
$$
\F : \L \to \SCwF
$$
be the level-indexed scwf of constraints described above.

We have a doubly indexed cwf of types (in our type theory)
$$
\T : (n : \L) \to (\psi : \F(n)) \to \L '(n,\psi) \to \CwF
$$
or alternatively (spell out what this means officially)
$$
\T : \sum_{n : \L}\F(n) \to \CwF
$$
So the contexts $\Ctx(n,\psi)$ in the cwf $\T(n,\psi)$ denotes the (type-theoretic) contexts in $n$ level variables satisfying the constraints in $\psi$, and similarly for the context morphisms, types, and terms.

\subsection{A level- and constraint-indexed non-cumulative tower of universes}


A finitary theory!
\\
\vspace{1ex}
Operator symbols: (We  factor out the common premises $n : \lctx, \psi : \cctx_n, l : \ltmq_n(\psi), \Gamma : \ctx_n(\psi)$. Note that $l$ now ranges over level terms quotiented by constraints in $\psi$).
%\begin{tiny}
\begin{eqnarray*}
%n : \lctx, \psi : \cctx_n, l : \ltm(n), \Gamma : \ctx_n(\psi) 
&\vdash& (\U_{l})_\Gamma : \ty_n(\psi,\Gamma)\\
%n : \lctx, \psi : \cctx_n, l : \ltm(n), \Gamma : \ctx_n(\psi), 
a : \tm_n(\psi,\Gamma,(\U_{l})_\Gamma) &\vdash& {\Ta_{l}}(a) : \ty_n(\psi,\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,(\U_0)_\Gamma) \\
%n : \lctx, \psi : \cctx_n,  l, 
l' : \ltmq_n(\psi),
a : \tm_n(\psi,\Gamma,(\U_{l})_\Gamma),
b :  \tm_n(\psi,\Gamma \cdot \Ta_{l}(a), (\U_{l'})_{\Gamma \cdot \Ta_{l}(a)})
&\vdash&
 \Pihat^{l,l'}(a,b) : \tm_n(\psi,\Gamma,(\U_{l \vee l'})_\Gamma)\\
 %n : \lctx, \psi : \cctx_n, l : \ltm(\psi,n),\Gamma : \ctx_n(\psi)
 &\vdash&\UU^l_\Gamma: \tm_n(\psi,\Gamma,(\UU_{l^+})_\Gamma)
\end{eqnarray*}
Equations:
\begin{eqnarray*}
&\vdots&
\end{eqnarray*}
%\end{tiny}
There are many equations. First for each $l$, $\U_l$ satisfies all the laws of a single universe, including laws of ordinary substitution. Then we have laws for level substitution $(\U_{l})_\Gamma[\sigma] = (\U_{l[\sigma]})_{\Gamma[\sigma]}$


\subsection{Constraint-indexed products of types}
%We add three operator symbols in addition to the operator symbols for cwfs in Section 5.2 and 5.3:
\def\l{\mathrm{l}}
%\begin{tiny}
Operator symbols (universal level quantification, abstraction, and application):
(We  factor out the common premises 
$
n : \lctx, \psi : \cctx_n, c : \cty_n, \Gamma : \ctx_n(\psi), A : \ty_n(\psi.c, \Gamma[\cp])
$.)
\begin{eqnarray*}
%n : \lctx, \psi : \cctx_n, c : \cty_n, \Gamma : \ctx_n(\psi), A : \ty_n(\psi.c, \Gamma[\cp])
&\vdash& [c]A : \ty_n(\psi,\Gamma)\\
%n : \lctx, \psi : \cctx_n, c : \cty_n, \Gamma : \ctx_n(\psi), A : \ty_n(\psi.c,\Gamma[\cp]), 
t : \tm_n(\psi.c,\Gamma[\cp], A) 
&\vdash& \langle c \rangle t : \tm_n(\psi,\Gamma,[c]A)\\
%n : \lctx, \psi : \cctx_n, c : \cty_n, \Gamma : \ctx_n(\psi), A : \ty_n(\psi.c,\Gamma[\cp]), 
f :  \tm_n(\psi,\Gamma,[c]A), pr : \ctm_n(\psi,c) &\vdash& \app_c(f,l) : \tm_n(\psi,\Gamma, A[\tuple{\cid,pr}])
\end{eqnarray*}
Equations ($\beta$ and $\eta$ for level abstraction and application):
 \begin{eqnarray*}
 \app_c(\langle c \rangle(b),pr) &=& b[\tuple{\cid,c}]\\
 \langle c \rangle(\app_c(f[\cp],\cq)) &=& f
 \end{eqnarray*}
 Equations for commutativity of operator symbols wrt constraint substitution $\sigma : \lhom(m,n)$ and a term substitution $\gamma : \hom_n(\Delta,\Gamma)$:
 \begin{eqnarray*}
 ([c]B)[ \sigma ] &=& [c](B[ \sigma^{+}])\\
 ([c]B)[ \gamma ] &=& [c](B[ \gamma^\dagger ])\\
&\vdots&
\end{eqnarray*}
where $\sigma^+ = \tuple{\sigma \circ \cp, \cq}$ and $\gamma^\dagger = \tuple{\gamma \circ \p, \q}$??
%\end{tiny}
\footnote{Check all this. It's easy to get wrong.}

\paragraph{Comparison with the rules in our old paper about explicit universe polymorphism.}
The first two operator symbols correspond $[c]A$ and $\langle c \rangle t$ to the first two rules (with implicit contexts) in our paper:
$$
\frac{\psi \vdash A\ type}{\vdash [\psi]A}
\hspace{5em}
\frac{\psi \vdash t : A}{\vdash \langle \psi \rangle t : [\psi]A}\
$$
The third operator symbol is the application of a constraint abstraction $\langle c \rangle t : [c]A$ to a proof that the constraint $c$ is valid. This suggests the following rule in the setup of our paper:
$$
\frac{\langle \psi \rangle t : [\psi]A\hspace{3em}\psi\ \valid}
{t : A}
$$
This rule is implied by the stronger rules in our paper:
$$
\frac
{\psi\ \valid}
{[\psi]A = A}
\hspace{5em}
\frac
{\psi\ \valid}
{[\psi]t  = t}
$$

\subsection{Level-indexed products of types in the presence of constraints}

{\bf I suggest to omit this although it's somewhat interesting.}
We can also do level-indexing in the theory with constraints, provided the constraints don't depend on the abstracted level variable.

\begin{tiny}
Operator symbols (universal level quantification, abstraction, and application):
\begin{eqnarray*}
n : \lctx, \psi : \cctx_{n}, \Gamma : \ctx_n(\psi), B : \ty_{\s(n)}(\psi[\lp],\Gamma[\lp])&\vdash& \forall_\l(B) : \ty_n(\psi,\Gamma)\\
n : \lctx, \psi : \cctx_{n}, \Gamma : \ctx_n(\psi), B : \ty_{\s(n)}(\psi[\lp],\Gamma[\lp]), b : \tm_{\s(n)}(\psi[\lp],\Gamma[\lp], B) &\vdash&  \lambda_\l(b) : \tm_n(\psi,\Gamma,\forall_\l(B))\\
n : \lctx, \psi : \cctx_{n}, \Gamma : \ctx_n(\psi), B : \ty_{\s(n)}(\psi[\lp],\Gamma[\lp]), f :  \tm_n(\psi,\Gamma,\forall_l(B)),  l : \ltm(n) &\vdash& \app_\l(f,l) : \tm_n(\psi,\Gamma, B[\tuple{\lid,l}])
\end{eqnarray*}
\end{tiny}

Note the similarity with with level-indexed products of types in the absence of constraints in 2.5. We only need to insert the dependence of constraints $\psi$ in $n$ level variables. Then we can abstract with respect to types and terms in $\s(n) = n+1$ variables.
\begin{tiny}
Equations ($\beta$ and $\eta$ for level abstraction and application):
 \begin{eqnarray*}
 \app_\l(\lambda_\l(b),l) &=& b[\tuple{\lid,l}]\\
 \lambda_\l(\app_\l(f[\lp],\lq)) &=& f
 \end{eqnarray*}
 Equations for commutativity of operator symbols wrt a level substitution $\sigma : \lhom(m,n)$ and a term substitution $\gamma : \hom_n(\Delta,\Gamma)$:
 \begin{eqnarray*}
 \forall_\l(B)[ \sigma ] &=& \forall_\l(B[ \sigma^{+}])\\
 \forall_\l(B)[ \gamma ] &=& \forall_\l(B[ \gamma^\dagger ])\\
&\vdots&
\end{eqnarray*}
where $\sigma^+ = \tuple{\sigma \circ \lp, \lq}$ and $\gamma^\dagger = \tuple{\gamma \circ \p, \q}$??
\end{tiny}

What about substitution with respect to constraints?

\subsection{The decision problem}

The decision problem is whether the judgments are decidable in the initial model. In the initial model the ucwf of levels is finitely presented, and so are the constraints.

There is an algorithm for deciding whether a set of constraints $\psi$ is consistent \cite{bezem-coquand:lattices}. If it is consistent then a small modification of the decision algorithm for type theory with an external hierarchy of universes can be employed for the theory with constraints on levels.

If $\psi$ is inconsistent, then the theory is undecidable. If we have a loop $l = l^+$, then $\UU_l : \UU_{l^+}$ implies $\UU_l : \UU_l$.

We can recover decidability by adding the rule that any type is equal to the unit type in an inconsistent level context $\psi$:
\begin{eqnarray*}
 \Gamma : \ctx, A  : \ty(\Gamma), c : \psi &\vdash& A = 1_\Gamma
\end{eqnarray*}

\paragraph{Appendix C.} Here we add the rules
$$
\frac{A\ type\hspace{3em}l < l}{A = \emptyset}
\hspace{5em}
\frac{t : A\hspace{3em}l < l}{t = \emptyset : A}
$$
The first rule corresponds to the following operator in generalized algebraic theories:
$$
n : \lctx, \psi : \cctx_n, \Gamma : \ctx_n(\psi), l : \ltm_n, p : \ctm_n(\psi,l < l), A : \ty_n(\psi,\Gamma)
\vdash
A = 1_\Gamma
$$
where $l < l : \cty_n$ abbreviates $\leq(l^+ \vee l,l) = \leq(l^+,l)$. If we have $A = 1$ rather than $A = \emptyset$ then we don't need an analogue of the second rule.  


\paragraph{Remark.} We need to think more about this.

\section{Set-theoretic models}

\subsection{The system with internal levels but no constraints.}
Assume we have a model in set theory with a hierarchy of universes of type theory with an external hierarchy of universes. The corresponding cwf has the components
 $$
(\Ctx, \Hom, \Ty, \Tm)
 $$
Let’s first consider the system with internal levels (as in our paper) but without constraints. We can now build a corresponding ucwf-indexed cwf (with the appropriate extra structure)
 $$
T : \L^{\op} \to \CwF
$$
where $\L$ is the ucwf with $\Ctx_\L = \N$ and $\Tm_\L(n) = \N^n \to \N$, that is, level expressions in $n$ level variables are interpreted as $n$-place set theoretic functions on $\N$. This has the appropriate sup/+ - structure with $\max$ and $\mathrm{succ}$ on $N$. Now
 $$
T(n) = (\Ctx_n, \Hom_n, \Ty_n, \Tm_n)
 $$
is a cwf modelling type theory with $n$ universe level variables. We have e g
 $$
\Ctx_n = \N^n \to \Ctx
 $$
that maps an assignment of external levels (as numbers) to the $n$ variables. $T$ can be extended to a functor.
 
\subsection{The system with constraints.}
If we then consider the system with constraints, we let the scwf $C(n)$ of constraints (in $n$ level variables) be the poset $\{0,1\}$, where 0 is the empty set and 1 is the singleton set. We interpret $\leq(l,l’) = 1$ iff $l = l’ : \Tm_\L(n)$ in the ucwf of levels.
 
If $\psi$ is a context in $C(n)$, that is, a sequence of level identities in $n$ level variables, then we can define a doubly indexed cwf $T(n, \psi)$ assigning external levels to the $n$ variables, that is, provided this assignment is valid in the sense that all the level identities in $\psi$ are satisfied.
 
Instead of starting with the ucwf of levels as natural numbers we can start with any $\sup/+$ lattice $L$.  We can still model the scwf of constraints in the same way and interpret $\leq(l,l’) = 1$ iff $ l = l’ : Tm(n)$.
 
It is part of the indexed cwf-structure that $T(L) \to T(L’)$ for any map $L’ \to L$ of ucwfs with sup+ structure.


\section{The gat of cwfs with $\Pi$-types and a single universe closed under them}\label{sec:gatPiU}

\paragraph{The gat of categories.}
\begin{tiny}
Sort symbols:
\begin{eqnarray*}
&\vdash& \Obj\\
\Delta, \Gamma : \Obj &\vdash& \Hom(\Delta,\Gamma)\\
\end{eqnarray*}

Operator symbols:
\begin{eqnarray*}
\Gamma : \Obj &\vdash& \id_\Gamma : \Hom(\Gamma,\Gamma)\\
\Xi,\Delta,\Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta) &\vdash&
\gamma \circ \delta : \Hom(\Xi,\Gamma)
\end{eqnarray*}

Equations:
\begin{eqnarray*}
\Delta, \Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma) &\vdash& \id_\Gamma \circ \gamma = \gamma : \Hom(\Delta,\Gamma)\\
\Delta, \Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma) &\vdash& \gamma \circ \id_\Delta = \gamma : \Hom(\Delta,\Gamma)\\
\Theta, \Xi,\Delta,\Gamma : \Obj, \gamma : \Hom(\Delta,\Gamma), \delta : \Hom(\Xi,\Delta), \xi : \Hom(\Theta,\Xi) &\vdash&
(\gamma \circ \delta) \circ \xi = \gamma \circ (\delta \circ \xi): \Hom(\Theta,\Gamma)
\end{eqnarray*}
Note: officially $\circ$ has five arguments rather than two.
\end{tiny}

\paragraph{Adding a family valued functor}

\begin{tiny}
Sort symbols ($\ctx = \Obj$):
\begin{eqnarray*}
\Gamma : \ctx &\vdash& \ty(\Gamma)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \tm(\Gamma,A)
\end{eqnarray*}

Operator symbols:
\begin{eqnarray*}
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma) &\vdash&
A[\gamma] : \ty(\Delta)\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Gamma,A) &\vdash&  a[\gamma] : \tm(\Delta,A[\gamma])
\end{eqnarray*}

Equations:
\begin{eqnarray*}
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& A[\id_\Gamma] = A : \ty(\Gamma)\\
\Gamma : \ctx, A:\ty(\Gamma), a:\tm(\Gamma,A) &\vdash& a[\id_\Gamma] = a : \tm(\Gamma,A)\\
\Xi,\Delta,\Gamma : \ctx, \delta : \Hom(\Xi,\Delta), \gamma : \Hom(\Delta,\Gamma),
A:\ty(\Gamma) &\vdash& A[\gamma\circ\delta] = A[\gamma][\delta]: \ty(\Xi)\\
\Xi,\Delta,\Gamma : \ctx, \delta : \Hom(\Xi,\Delta), \gamma : \Hom(\Delta,\Gamma),
A:\ty(\Gamma), a:\tm(\Gamma,A) &\vdash&
a[\gamma\circ\delta] = a[\gamma][\delta]: \tm(\Xi,A[\gamma\circ\delta])
\end{eqnarray*}
We have dropped some of the official arguments here too, and will do so in the following as well.
\end{tiny}


\paragraph{Adding a terminal object}

\begin{tiny}
%Sort symbols: none
Operator symbols:
\begin{eqnarray*}
&\vdash& 1 : \ctx\\
\Gamma : \ctx &\vdash& \tuple{}_\Gamma : \Hom(\Gamma,1)
\end{eqnarray*}

Equations:
\begin{eqnarray*}
 &\vdash& \id_1 = \tuple{}_1 : \Hom(1,1)\\
\Gamma,\Delta : \ctx, \gamma : \Hom(\Delta,\Gamma) &\vdash&
\tuple{}_\Gamma\circ\gamma = \tuple{}_\Delta : \Hom(\Delta,1)
\end{eqnarray*}
\end{tiny}


%(The latter two equations are better for term rewriting than the
%obvious single one expressing the uniqueness of $\tuple{}_\Gamma$.)

\paragraph{Adding context comprehension}

%No new sorts are added.
\begin{tiny}
Operator symbols:
\begin{eqnarray*}
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \Gamma\cext A : \ctx\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash& \tuple{\gamma,a} : \Hom(\Delta,\Gamma\cext A)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \p: \Hom(\Gamma\cext A,\Gamma)\\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash& \q: \tm(\Gamma\cext A,A[\p])
\end{eqnarray*}

Equations:
\begin{eqnarray*}
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash& \p\circ\tuple{\gamma,a} = \gamma : \Hom(\Delta,\Gamma)\\
\Gamma,\Delta : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]) &\vdash& \q[\tuple{\gamma,a}] = a : \tm(\Delta,A[\gamma]) \\
\Gamma,\Delta,\Xi : \ctx, A:\ty(\Gamma), \gamma : \Hom(\Delta,\Gamma), a:\tm(\Delta,A[\gamma]), \delta : \Hom(\Xi,\Delta) &\vdash&
\tuple{\gamma,a} \circ \delta = \tuple{\gamma\circ\delta,a[\delta]} :
\Hom(\Xi,\Gamma\cext A) \\
\Gamma : \ctx, A:\ty(\Gamma) &\vdash&
\id_{\Gamma\cext A} = \tuple{\p,\q} : \Hom(\Gamma\cext A,\Gamma\cext A)
\end{eqnarray*}
\end{tiny}


\paragraph{Adding $\Pi$-types}
%We add three operator symbols in addition to the operator symbols for cwfs in Section 5.2 and 5.3:
\begin{tiny}
Operator symbols:
\begin{eqnarray*}
\Gamma : \ctx, A : \ty(\Gamma), B : \ty(\Gamma.A)&\vdash& \Pi(A,B) : \ty(\Gamma)\\
\Gamma : \ctx, A : \ty(\Gamma), B : \ty(\Gamma.A), b : \tm(\Gamma.A, B) &\vdash& \lambda(b) : \tm(\Gamma,\Pi(A,B))\\
\Gamma : \ctx, A : \ty(\Gamma), B : \ty(\Gamma.A), c :  \tm(\Gamma,\Pi(A,B)), a : \tm(\Gamma, A) &\vdash& \app(c,a) : \tm(\Gamma, B[\tuple{\id,a}])
\end{eqnarray*}
Equations (omitting the context and type of the equalities):
 \begin{eqnarray*}
 \app(\lambda(b),a) &=& b[\tuple{\id,a}]\\
 \lambda(\app(c[\p],\q)) &=& c
 \end{eqnarray*}
 Equations for commutativity of operator symbols wrt substitution:
 \begin{eqnarray*}
\Pi(A,B)[ \gamma ] &=& \Pi(A [ \gamma ], B[ \gamma^\dagger ])\\
\lambda(b) [ \gamma ] &=& \lambda(b[\gamma^\dagger ])\\
\app(c,a) [ \gamma ] &=& \app(c[ \gamma ], a[ \gamma ] )
\end{eqnarray*}
where $\gamma^\dagger = \tuple{\gamma \circ \p, \q}$.
\end{tiny}


\paragraph{Adding a universe closed under $\Pi$}

\footnote{PD: for comparison only. Should we remove it?}
\begin{tiny}
Operator symbols:
\begin{eqnarray*}
\Gamma : \ctx &\vdash& \U_\Gamma : \ty(\Gamma)\\
\Gamma : \ctx, a : \tm(\Gamma,\U_\Gamma) &\vdash& {\Ta}(a) : \ty(\Gamma)\\
%\Gamma : \ctx &\vdash& (\N^0)_\Gamma : \tm(\Gamma,\U_\Gamma) \\
\Gamma : \ctx,
a : \tm(\Gamma,\U_\Gamma),
b :  \tm(\Gamma \cdot \Ta(a), \U_\Gamma))
&\vdash&
 \Pi^0(a,b) : \tm(\Gamma,\U_\Gamma)
\end{eqnarray*}
%$\U_\Gamma$ is the universe (a type) relative to the context $\Gamma$; $\Ta$ is the decoding operation mapping a term in the universe to the corresponding type; $\N^0$ is the code for $\N$ in the universe, and $\Pi^0$ forms codes for $\Pi$-types in the universe. (Note that we have dropped the context argument of $\Ta$ and $\Pi^0$.)

Equation:
\begin{eqnarray*}
%\Ta(\N^0_\Gamma) &=& \N_\Gamma\\
\Ta(\Pi^0(a,b)) &=& \Pi(\Ta(a),\Ta(b))
\end{eqnarray*}
 Equations for commutativity of operator symbols wrt substitution:
 \begin{eqnarray*}
{\U}_\Gamma [ \gamma ] &=& {\U}_\Delta\\
\Ta(a) [ \gamma ] &=& \Ta(a[ \gamma ] )\\
%\N^0_\Gamma [ \gamma ] &=&\N^0_\Delta\\
\Pi^0(a,b)[ \gamma ] &=& \Pi^0(a [ \gamma ], b[ \gamma^\dagger ])
\end{eqnarray*}
\end{tiny}
%where $\gamma^\dagger = \tuple{\gamma \circ \p, \q}$.
\bibliographystyle{plain}
\bibliography{../refs}
\end{document}
