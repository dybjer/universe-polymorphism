New attempt at algorithm, notions as in alg.tex, but we drop
the condition that the rules have gain <= 1 and assume instead
that the gain is bounded by MAXGAIN.

Remark. Let N+ denote N,∞. When proving from V+n()
with n(): V -> N+, any variable v with n(v)=∞ can be
eliminated from the clause set C: all clauses ... -> v+k
can be left out, and all atoms v+k in ...,v+k,... -> ...
can be deleted from the remaining clauses. 
If we get a clause empty -> x+k, then we can infer n(x)=∞
and continue the simplification process.
In a proof by induction on |V| we can apply the IH
immediately to the simplified situation.

THM: For every non-empty V and every n(): V -> N+ there is a function

m(V,n()): V -> N+ such that for all x in V 

(*) V+n() |- x+k derivable in C_V   iff   k <= m(W,n())(x), 

Proof.

Base: V = x. Either no clauses, so take m(V,n())(x)= n(x), or the 
only (non-trivial) clause is x->x+k+1 and we take m(V,n())(x) = ∞.

Step: assume OK for smaller V. If n(v)=∞ for some v in V,
eliminate v from C and apply the IH. Assume therefore n(_): V -> N.
We compute first the subset W of V of variables w whose value n(w)
can be improved in one step. For any x in V, we have the following 
cases of possible (non-trivial) clauses, each giving a result:

1. x -> x+k, k>0, result is ∞ ; otherwise,

2. A -> x+k, k>n(x), A non-empty, A activated in n(), result is k.

Let m(x) be the maximum of n(x) and the results for x, as obtained
by 1,2 above, and let W be the set of all x in V such that m(x) > n(x).

If W is empty we are done since then n() itself satisfies (*).

If W = V we are done since then m(W,n())(x) = ∞ satisfies (*).

Otherwise, W is a non-empty strict subset of V and we can apply
the IH to W, C_W and m() to obtain m(W,m()) satisfying (*) for
W, C_W and m(W,m()) instead of for V, C and m(W,n()). 
Define p(x)= n(x) for x in V-W and p(w) = m(W,m())(w).
Again, if m(W,m())(w) = ∞ we simplify and apply the IH
to the smaller V, C and restricted p(), keeping the work done
in p(). Assume now p(_): V -> N.

Clauses in C_W are true in p(), but this need not be the case
for other clauses. There are two types of clauses in C_V - C_W :
clauses with conclusion in V-W and clauses with conclusion
in W but at least one atom based on V-W. We treat the latter first,
by subsequent recursive calls with W, C_W and with different
functions, but all with the same values n(x) for x in V-W.
For clauses of the form X,Y -> w+k, with w in W
and non-empty X based on V-W, and (possibly empty) Y based on W,
we have that if X = ...,xi+li,... then k <= min(li)+MAXGAIN.
Thus the maximal value for w one can obtain from a shift of
X,Y -> w+k with activated X in n() is min(li)+MAXGAIN+min(n(xi)-li).
Note that this value is the same for all activated shifts of the
clause, even though the two minima may have different i's.
By shifting downwards we can always get an activated shift with 
min(li)=0, so a simpler upper bound for k is MAXGAIN+min(n(xi)).
However, the more complicated bound can be sharper.
Let max(w) be the maximum of all upperbounds obtained in this way.
A simple expression for max(w) for any w in W is MAXGAIN+max(n(V-W)).
Again, the more complicated bounds can be sharper, but need not.
(Example: clauses a+9 -> w+2 and a,w -> w+1 and a,w+1 -> w+3,
MAXGAIN=3. Let n(a)=9, n(w)=0, then m(w)=2 and max(w)=12, sharp!)

We resume analysing the situation after the first recursive call
with W above. There are now several possibilities, 
followed by different actions:

- A variable w in W can be improved by clauses as in 2 above, with
k > p(w) and A activated in p(). Then A must contain a variable 
in V-W. Note that p(x)=n(x) for all x in V-W.
Like in 2 above we compute the maximal improvement and adapt 
p() accordingly and apply the IH. This iteration of recursive calls
can happen at most Sum_{w in W}(max(w)-p(w)) times, before a fixed 
point p'() is reached, satisfying all clauses with conclusion in W.

Interestingly, loops in C_W causing p(w)= ∞ are all found in
the first recursive call with W. Therefore p'() : V -> N,
and there are only two possibilities left:

- all clauses are satified and we are done, m(V,n()) = p'() 
satisfies (*).

- not all clauses are satisfied, and  
Unsatisfied clauses must have conclusion y+k with y in V-W.
Improve maximally all such y in the way described for w in W
in 1,2 above, add these y's to W to obtain W' and proceed
in a similar way as after 1,2. This terminates since we exhaust V.


Example 1.

y -> x with n(x)=1, n(y)=9. n(x) can be improved to m(x)=9.
So we have m(V,n())(x) = m(V,n())(y) = 9.
Recursive call with W=x and empty set of clauses, nothing changes, done.

Example 2.

a->b+1, b->c+1, c->d+1, d+1->e, e+1->f, f+1->g, with n()= 0000000.

W=bcd, m() = 0111000 with b->c+1, c->d+1

  Recursive call with m(W,n()= 0122000 and c->d+1

     Recursive call with  0123000 and empty

Return 0123000

W'=bcdef, 0123210 model for b->c+1, c->d+1, d+1->e, e+1->f 

Return 0123210, model for all clauses




